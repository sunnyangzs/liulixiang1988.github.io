<!DOCTYPE html>
<html lang="zh">
<head>

        <title>Nancy Web框架</title>
        <meta charset="utf-8" />
        <link href="/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Liu Lixiang的博客 Full Atom Feed" />
        <link href="/feeds/dotnet.atom.xml" type="application/atom+xml" rel="alternate" title="Liu Lixiang的博客 Categories Atom Feed" />


        <!-- Mobile viewport optimized: j.mp/bplateviewport -->
        <meta name="viewport" content="width=device-width,initial-scale=1, maximum-scale=1">

        <link rel="stylesheet" type="text/css" href="./theme/gumby.css" />
        <link rel="stylesheet" type="text/css" href="./theme/style.css" />
        <link rel="stylesheet" type="text/css" href="./theme/pygment.css" />

        <script src="./theme/js/libs/modernizr-2.6.2.min.js"></script>




</head>

<body id="index" class="home">


    <div class="container">

        <div class="row">

          <header id="banner" class="body">
                  <h1><a href="./">Liu Lixiang的博客 <small>数据科学/Python/Java</small></a></h1>
          </header><!-- /#banner -->

            <div id="navigation" class="navbar row">
              <a href="#" gumby-trigger="#navigation &gt; ul" class="toggle"><i class="icon-menu"></i></a>
             
              <ul class="columns">
                <li><a href="./">首页</a></li>

                <li><a href="/categories.html">分类</a></li>
                <li><a href="/tags.html">标签</a></li>
                <li><a href="/archives.html">归档</a></li>
                <li><a href="./pages/guan-yu.html">关于</a></li>

              </ul>
            </div>

<section id="content" class="body">

   <div class="row">
        <div class="eleven columns">


            <header>
              <h2 class="entry-title">
                <a href="./nancy-webkuang-jia.html" rel="bookmark"
                   title="Permalink to Nancy Web框架">Nancy Web框架</a></h2>
           
            </header>
            <footer class="post-info">
              <abbr class="published" title="2014-09-12">
                五 12 九月 2014
              </abbr>
              <address class="vcard author">By 
                <a class="url fn" href="./author/liu-li-xiang.html"> 刘理想</a>
              </address>
            </footer><!-- /.post-info -->
            <div class="entry-content">
                <div class="toc">
<ul>
<li><a href="#nancy">Nancy框架</a><ul>
<li><a href="#nancy_1">一、创建第一个Nancy应用</a></li>
<li><a href="#nancymodule">二、探索Nancy的module</a><ul>
<li><a href="#1">1. 模块能够在全局被发现</a></li>
<li><a href="#2">2. 使用模块为路由创建一个根</a></li>
</ul>
</li>
<li><a href="#_1">三、定义路由</a><ul>
<li><a href="#1_1">1. 方法</a></li>
<li><a href="#2_1">2. 模式</a></li>
<li><a href="#3">3. 模式的优先级</a></li>
<li><a href="#4">4. 动作</a></li>
<li><a href="#5">5. 条件</a></li>
<li><a href="#6">6. 路由片段约束</a><ul>
<li><a href="#61">6.1 自定义约束</a><ul>
<li><a href="#_2">例子</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#7">7. 选择去调用路由的秘诀</a></li>
<li><a href="#8">8. 疯狂的路由</a></li>
</ul>
</li>
<li><a href="#_3">四、自定义路由</a></li>
<li><a href="#_4">五、异步</a><ul>
<li><a href="#1_2">1. 语法</a></li>
<li><a href="#2_2">2 语法例子</a></li>
</ul>
</li>
<li><a href="#dynamicdictionary">六、查看DynamicDictionary</a></li>
<li><a href="#modulebeforeafter">七、module的before/after钩子</a><ul>
<li><a href="#1_3">1. 在路由被调用前拦截请求</a></li>
<li><a href="#2-after">2. After拦截器</a></li>
</ul>
</li>
<li><a href="#applicationbeforeafteronerror">八、Application的Before,After和OnError管道</a><ul>
<li><a href="#1before">1.Before拦截</a></li>
<li><a href="#2-after_1">2. After拦截</a></li>
<li><a href="#3_1">3. 错误拦截器</a></li>
<li><a href="#4_1">4. 构建自己的钩子</a></li>
</ul>
</li>
<li><a href="#_5">九、模型绑定</a><ul>
<li><a href="#1_4">1. 屏蔽不想要的信息</a></li>
<li><a href="#2_3">2. 绑定配置</a></li>
<li><a href="#3-rich-request-body-payloads">3. 反序列化rich request body payloads(负载)</a></li>
<li><a href="#4-checkbox">4. 模型绑定Checkbox</a></li>
<li><a href="#5-list">5. 绑定到list</a><ul>
<li><a href="#51-arrary">5.1 绑定arrary到单独的对象</a></li>
<li><a href="#52-list">5.2 绑定到对象的list</a></li>
<li><a href="#53-html-formlist">5.3 HTML form中的List分隔符</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#bootstrapper">十、Bootstrapper</a><ul>
<li><a href="#1-bootstrapper">1. 简单的修改bootstrapper</a></li>
<li><a href="#2-bootstrapper">2. 找到合适的bootstrapper</a></li>
<li><a href="#3_2">3. 使用自动注册</a></li>
</ul>
</li>
<li><a href="#_6">十一、视图引擎</a><ul>
<li><a href="#1_5">1. 在路由中渲染视图</a></li>
<li><a href="#2_4">2.从模型中解析视图的名称</a></li>
</ul>
</li>
<li><a href="#_7">十二、超简单视图引擎</a><ul>
<li><a href="#1_6">1. 标准变量替换</a></li>
<li><a href="#2_5">2. 循环</a></li>
<li><a href="#3_3">3. 条件</a></li>
<li><a href="#4_2">4. 隐式条件</a></li>
<li><a href="#5-html">5. HTML编码</a></li>
<li><a href="#6-patials">6. 部分Patials</a></li>
<li><a href="#7-mastersection">7. Master页和section</a></li>
<li><a href="#8-token">8. 防止伪造token</a></li>
<li><a href="#9">9. 路径扩展</a></li>
<li><a href="#10-ssve">10. 扩展SSVE</a></li>
</ul>
</li>
<li><a href="#razor">十二、Razor引擎</a><ul>
<li><a href="#1-razor">1. 安装Razor</a></li>
<li><a href="#2-razor">2. 配置Razor</a></li>
</ul>
</li>
<li><a href="#_8">十三、实现自己的视图引擎需要注意的地方</a></li>
<li><a href="#_9">十四、视图位置约定</a><ul>
<li><a href="#1_7">1. 查看默认约定</a><ul>
<li><a href="#11">1.1 根约定</a></li>
<li><a href="#12">1.2 视图文件夹约定</a></li>
<li><a href="#13">1.3 视图和模块路径约定</a></li>
<li><a href="#14">1.4 模块路径约定</a></li>
<li><a href="#15">1.5 模块名称约定</a></li>
<li><a href="#16">1.6 视图模块名称约定</a></li>
</ul>
</li>
<li><a href="#2_6">2. 从模型类型推断是退名</a></li>
<li><a href="#3_4">3. 自定义约定</a></li>
<li><a href="#3-iconventions">3. 使用IConventions定义自己的约定</a></li>
</ul>
</li>
<li><a href="#_10">十五、本地化</a></li>
<li><a href="#_11">十六、测试应用</a></li>
<li><a href="#_12">十七、根路径</a><ul>
<li><a href="#1_8">1. 改变跟路径</a></li>
<li><a href="#2_7">2. 上传文件</a></li>
</ul>
</li>
<li><a href="#_13">十八、管理静态内容</a></li>
<li><a href="#_14">十九、诊断</a><ul>
<li><a href="#1-dashboard">1. 配置到dashboard的访问</a></li>
<li><a href="#2_8">2. 去除诊断</a></li>
<li><a href="#3_5">3. 有哪些工具呢？</a><ul>
<li><a href="#31">3.1 信息</a></li>
<li><a href="#32">3.2 配置</a></li>
<li><a href="#33">3.3 请求跟踪</a></li>
<li><a href="#34">3.4 交互式的诊断</a><ul>
<li><a href="#1idiagnosticsprovider">（1）IDiagnosticsProvider接口</a></li>
<li><a href="#2_9">（2）可诊断的对象</a></li>
<li><a href="#3_6">（3）提供描述给方法</a></li>
<li><a href="#4_3">（4）自定义模板输出</a></li>
<li><a href="#5_1">（5）创建诊断提供者</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><a href="#favicon">二十、添加自己的favicon</a><ul>
<li><a href="#1-favicon">1. 替换默认的FavIcon</a></li>
<li><a href="#2-icon">2. 使用内嵌icon</a></li>
<li><a href="#3-icon">3. 移除ICON</a></li>
</ul>
</li>
<li><a href="#_15">二十一、添加自定义的错误页面</a></li>
<li><a href="#_16">二十二、加密帮助方法</a><ul>
<li><a href="#1-iencryptionprovider">1. IEncryptionProvider 接口</a></li>
<li><a href="#2-ihmacprovider">2. IHmacProvider 接口</a></li>
<li><a href="#3-ikeygenerator">3. IKeyGenerator 接口</a></li>
<li><a href="#4-cryptographyconfiguration">4. 加密配置类型CryptographyConfiguration</a></li>
</ul>
</li>
<li><a href="#content-negotiation">二十三、Content negotiation(内容协商)</a><ul>
<li><a href="#1-response-processor">1. Response Processor</a><ul>
<li><a href="#11_1">1.1 匹配优先级</a></li>
<li><a href="#12_1">1.2 默认响应处理器</a></li>
</ul>
</li>
<li><a href="#2_10">2. 控制协商</a></li>
<li><a href="#3_7">3. 支持文件扩展名</a></li>
<li><a href="#4-accept-header">4. 强制可接受的头(Accept Header)</a></li>
<li><a href="#5-iconventions">5. 使用IConventions来定义自己的约定</a></li>
<li><a href="#6_1">6. 自动协商头</a></li>
<li><a href="#7_1">7. 更多信息</a></li>
</ul>
</li>
<li><a href="#_17">二十四、使用转换器来扩展序列化</a></li>
<li><a href="#_18">二十五、授权</a><ul>
<li><a href="#1_9">1. 了解用户</a></li>
<li><a href="#2_11">2. 保护你的资源</a></li>
<li><a href="#3_8">3. 创造你自己的安全扩展</a></li>
<li><a href="#4-provider">4. 实现自己的验证provider</a></li>
<li><a href="#5_2">5. 无状态认证</a><ul>
<li><a href="#51">5.1 配置并开启无状态认证</a></li>
<li><a href="#52">5.2 简单配置</a></li>
</ul>
</li>
<li><a href="#6-form">6. Form认证</a><ul>
<li><a href="#61-user-mapper">6.1 User mapper</a></li>
<li><a href="#62-form">6.2 修改应用，处理form认证</a></li>
<li><a href="#63-form">6.3 启用form认证</a></li>
<li><a href="#64">6.4 关于加密，还有一些话</a></li>
<li><a href="#65">6.5 跟多</a></li>
</ul>
</li>
<li><a href="#7_2">7. 令牌认证</a><ul>
<li><a href="#71-nancy">7.1 认识Nancy的令牌认证</a></li>
<li><a href="#72">7.2 基本原理</a></li>
<li><a href="#73">7.3 使用</a><ul>
<li><a href="#731-nancy">7.3.1 Nancy配置</a></li>
<li><a href="#732">7.3.2 客户端配置</a></li>
</ul>
</li>
<li><a href="#8_1">8. 幕后的工作</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
              
<h1 id="nancy">Nancy框架</h1>
<h2 id="nancy_1">一、创建第一个Nancy应用</h2>
<ol>
<li>安装<a href="http://visualstudiogallery.msdn.microsoft.com/f1e29f61-4dff-4b1e-a14b-6bd0d307611a">Nancy项目模板</a></li>
<li>创建<code>Nancy Empty Web Application with ASP.NET Hosting</code></li>
<li>添加<code>Nancy module</code>,它是一个标准C#类，通过添加下面几行代码定义了web应用的路由处理方法。</li>
<li>编译并运行。</li>
</ol>
<div class="highlight"><pre><span></span>public class HelloModule : NancyModule
{
    public HelloModule()
    {
        Get["/"] = parameters =&gt; "Hello World";
    }
}
</pre></div>
<h2 id="nancymodule">二、探索Nancy的module</h2>
<p>Module继承自<code>NancyModule</code>类。Module是必不可少的.它不仅定义了路由，还提供了许多其他信息，比如请求、上下文、构造响应的辅助方法、视图渲染等等。</p>
<h3 id="1">1. 模块能够在全局被发现</h3>
<p>可以在任意地方定义module，比如外部的dll等，这为代码的复用带来很大的方便。不用担心效率问题，扫描module只在程序启动时发生。</p>
<h3 id="2">2. 使用模块为路由创建一个根</h3>
<p>类似命名空间的概念，在创建构造方法时传给base一个名称。</p>
<div class="highlight"><pre><span></span>public class ResourceModule : NancyModule
{
    public ResourceModule() : base("/products")
    {
        // would capture routes to /products/list sent as a GET request
        Get["/list"] = parameters =&gt; {
            return "The list of products";
        };
    }
}
</pre></div>
<h2 id="_1">三、定义路由</h2>
<p>路由是在module的构造方法中定义的。为了定义一个路由，你需要声明<code>方法</code>+<code>模式</code>+<code>动作</code>+(可选)<code>条件</code></p>
<p>比如：</p>
<div class="highlight"><pre><span></span>public class ProductsModule : NancyModule
{
    public ProductsModule()
    {
        Get["/products/{id}"] = _ =&gt;
        {
            //do something
        };
    }
}
</pre></div>
<p>或者异步</p>
<div class="highlight"><pre><span></span>public class ProductsModule : NancyModule
{
    public ProductsModule()
    {
        Get["/products/{id}", runAsync: true] = async (_, token) =&gt;
        {
            //do something long and tedious
        };
    }
}
</pre></div>
<h3 id="1_1">1. 方法</h3>
<p>支持HTTP常见方法：<code>DELETE</code>, <code>GET</code>, <code>HEAD</code>, <code>OPTIONS</code>, <code>POST</code>, <code>PUT</code>, <code>PATCH</code></p>
<h3 id="2_1">2. 模式</h3>
<p>模式能够自定义，Nancy提供了一些常用的：</p>
<ol>
<li>字面量 - <code>/some/literal/segments</code></li>
<li>捕获片段 - <code>/{name}</code>，获取URL的片段，并传给路由的Action</li>
<li>捕获可选片段 - <code>/{name?}</code>，添加了一个问号，片段就是可选的了</li>
<li>捕获可选/默认片段 - <code>/{name?default}</code></li>
<li>正则片段 - <code>/(?&lt;age&gt;[\d]{1,2})</code>，使用命名捕获组来捕获片段，如果不需要捕获，使用非捕获组，比如<code>(?:regex-goes-here)</code></li>
<li>贪心片段 - <code>/{name*}</code>，从/处开始捕获</li>
<li>贪心正则捕获 - <code>^(?&lt;name&gt;[a-z]{3, 10}(?:/{1})(?&lt;action&gt;[a-z]{5, 10}))$</code></li>
<li>多个捕获片段 - <code>/{file}.{extension}</code>或者<code>/{file}.ext</code></li>
</ol>
<h3 id="3">3. 模式的优先级</h3>
<h3 id="4">4. 动作</h3>
<p>动作时一个lambda表达式<code>Func&lt;dynamic, dynamic&gt;</code>，输入时<code>DynamicDictionary</code>，详见<a href="https://github.com/NancyFx/Nancy/wiki/Taking-a-look-at-the-DynamicDictionary">此处</a>.</p>
<p>响应可以使任意的model，最终的结果会被<a href="https://github.com/NancyFx/Nancy/wiki/Content-Negotiation">Content Negotiation</a>处理。但是如果返回值是<code>Response</code>类型，则原样返回。</p>
<p><code>Response</code>对象有几个隐形转换操作：
1. <code>int</code>变为Http的状态
2. <code>HttpStatusCode</code>枚举值
3. <code>string</code>直接是相应的body
4. <code>Action&lt;Stream&gt;</code>则写道response stream中</p>
<h3 id="5">5. 条件</h3>
<p>路由条件用来过滤（比如登录非登录）。使用<code>Func&lt;NancyContext, bool&gt;</code>的lambda表达式定义.</p>
<div class="highlight"><pre><span></span>Post["/login", (ctx) =&gt; ctx.Request.Form.remember] = _ =&gt; 
{
     return "Handling code when remember is true!";
}

Post["/login", (ctx) =&gt; !ctx.Request.Form.remember] = _ =&gt; 
{
     return "Handling code when remember is false!";
}
</pre></div>
<h3 id="6">6. 路由片段约束</h3>
<div class="highlight"><pre><span></span><span class="nt">Get</span><span class="cp">[</span><span class="s2">"/intConstraint/{value:int}"</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">_</span> <span class="o">=&gt;</span> <span class="s2">"Value "</span> <span class="o">+</span> <span class="nt">_</span><span class="nc">.value</span> <span class="o">+</span> <span class="s2">" is an integer."</span><span class="o">;</span>
</pre></div>
<p>只有为int的才会匹配。</p>
<p>约束：
- <code>int</code>
- <code>decimal</code>
- <code>guid</code>
- <code>bool</code>
- <code>alpha</code>
- <code>datetime</code>
- <code>datetime(format)</code>
- <code>min(minimum)</code>
- <code>max(maximum)</code>
- <code>range(minimum, maximum)</code>
- <code>minlength(length)</code>
- <code>maxlength(length)</code>
- <code>length(minimum, maximum)</code></p>
<h4 id="61">6.1 自定义约束</h4>
<p>实现<code>IRouteSegmentConstraint</code>接口，或者继承自
- <code>RouteSegmentConstraintBase&lt;T&gt;</code> - Base class for a named constraint.
- <code>ParameterizedRouteSegmentConstraintBase&lt;T&gt;</code> - Base class for a named constraint that accepts arguments.</p>
<h5 id="_2">例子</h5>
<p>一个email约束</p>
<div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nl">EmailRouteSegmentConstraint</span> <span class="p">:</span> <span class="n">RouteSegmentConstraintBase</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="n">public</span> <span class="n">override</span> <span class="n">string</span> <span class="n">Name</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="s">"email"</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">protected</span> <span class="n">override</span> <span class="kt">bool</span> <span class="n">TryMatch</span><span class="p">(</span><span class="n">string</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">string</span> <span class="n">segment</span><span class="p">,</span> <span class="k">out</span> <span class="n">string</span> <span class="n">matchedValue</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">segment</span><span class="p">.</span><span class="n">Contains</span><span class="p">(</span><span class="s">"@"</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">matchedValue</span> <span class="o">=</span> <span class="n">segment</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">matchedValue</span> <span class="o">=</span> <span class="n">null</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<p>用法</p>
<div class="highlight"><pre><span></span><span class="nt">Get</span><span class="cp">[</span><span class="s2">"/profile/{value:email}"</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">_</span> <span class="o">=&gt;</span> <span class="s2">"Value "</span> <span class="o">+</span> <span class="nt">_</span><span class="nc">.value</span> <span class="o">+</span> <span class="s2">" is an e-mail address."</span><span class="o">;</span>
</pre></div>
<h3 id="7">7. 选择去调用路由的秘诀</h3>
<p>一个请求有时符合多个模式，此时记住：
1. module的顺序在启动时不定
2. 同一module中的路由是按顺序来的
3. 多个匹配中，得分最高的匹配
4. 得分相同的匹配按照启动时的顺序匹配</p>
<h3 id="8">8. 疯狂的路由</h3>
<p>一些可能的用法：</p>
<div class="highlight"><pre><span></span><span class="c1">// would capture routes like /hello/nancy sent as a GET request</span>
<span class="n">Get</span><span class="p">[</span><span class="s">"/hello/{name}"</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"Hello "</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /favoriteNumber/1234, but not /favoriteNumber/asdf as a GET request</span>
<span class="n">Get</span><span class="p">[</span><span class="s">"/favoriteNumber/{value:int}"</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">"So your favorite number is "</span> <span class="o">+</span> <span class="n">parameters</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="s">"?"</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /products/1034 sent as a DELETE request</span>
<span class="n">Delete</span><span class="p">[</span><span class="s">@"/products/(?&lt;id&gt;[\d]{1,7})"</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">200</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// would capture routes like /users/192/add/moderator sent as a POST request</span>
<span class="n">Post</span><span class="p">[</span><span class="s">"/users/{id}/add/{category}"</span><span class="p">]</span> <span class="o">=</span> <span class="n">parameters</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">HttpStatusCode</span><span class="p">.</span><span class="n">OK</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
<h2 id="_3">四、自定义路由</h2>
<p>http://www.philliphaydon.com/2013/04/nancyfx-implementing-your-own-routing/</p>
<h2 id="_4">五、异步</h2>
<h3 id="1_2">1. 语法</h3>
<p>Before/After管道、主路由委托都可以使用async.语法绝大部分与同步代码一致，但需要注意下面的变化：</p>
<ul>
<li>before/after钩子接受两个参数，context和cancellation token(取消令牌)，而不仅仅是context</li>
<li>路由定义有一个附加的bool参数，并且委托接受两个参数，一个捕获的参数，另一个cancellation token.</li>
</ul>
<h3 id="2_2">2 语法例子</h3>
<div class="highlight"><pre><span></span><span class="nt">public</span> <span class="nt">MainModule</span><span class="o">()</span>
<span class="p">{</span>
    <span class="n">Before</span> <span class="o">+=</span> <span class="n">async</span> <span class="p">(</span><span class="n">ctx</span><span class="o">,</span> <span class="n">ct</span><span class="p">)</span> <span class="o">=&gt;</span>
        <span class="err">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"Before Hook Delay\n"</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="o">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>

            <span class="n">return</span> <span class="n">null</span><span class="p">;</span>
        <span class="p">}</span><span class="o">;</span>

    <span class="nt">After</span> <span class="o">+=</span> <span class="nt">async</span> <span class="o">(</span><span class="nt">ctx</span><span class="o">,</span> <span class="nt">ct</span><span class="o">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"After Hook Delay\n"</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="o">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"After Hook Complete\n"</span><span class="p">);</span>

            <span class="n">ctx</span><span class="o">.</span><span class="n">Response</span> <span class="o">=</span> <span class="n">this</span><span class="o">.</span><span class="n">GetLog</span><span class="p">();</span>
        <span class="p">}</span><span class="o">;</span>

    <span class="nt">Get</span><span class="cp">[</span><span class="s2">"/"</span><span class="p">,</span> <span class="kc">true</span><span class="cp">]</span> <span class="o">=</span> <span class="nt">async</span> <span class="o">(</span><span class="nt">x</span><span class="o">,</span> <span class="nt">ct</span><span class="o">)</span> <span class="o">=&gt;</span>
        <span class="p">{</span>
            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"Delay 1\n"</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="o">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>

            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"Delay 2\n"</span><span class="p">);</span>
            <span class="n">await</span> <span class="n">Task</span><span class="o">.</span><span class="n">Delay</span><span class="p">(</span><span class="m">1000</span><span class="p">);</span>

            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"Executing async http client\n"</span><span class="p">);</span>
            <span class="n">var</span> <span class="n">client</span> <span class="o">=</span> <span class="n">new</span> <span class="n">HttpClient</span><span class="p">();</span>
            <span class="n">var</span> <span class="n">res</span> <span class="o">=</span> <span class="n">await</span> <span class="n">client</span><span class="o">.</span><span class="n">GetAsync</span><span class="p">(</span><span class="s2">"http://nancyfx.org"</span><span class="p">);</span>
            <span class="n">var</span> <span class="nb">content</span> <span class="o">=</span> <span class="n">await</span> <span class="n">res</span><span class="o">.</span><span class="n">Content</span><span class="o">.</span><span class="n">ReadAsStringAsync</span><span class="p">();</span>

            <span class="n">this</span><span class="o">.</span><span class="n">AddToLog</span><span class="p">(</span><span class="s2">"Response: "</span> <span class="o">+</span> <span class="nb">content</span><span class="o">.</span><span class="n">Split</span><span class="p">(</span><span class="s1">'\n'</span><span class="p">)</span><span class="cp">[</span><span class="mi">0</span><span class="cp">]</span> <span class="o">+</span> <span class="s2">"\n"</span><span class="p">);</span>

            <span class="n">return</span> <span class="p">(</span><span class="n">Response</span><span class="p">)</span><span class="n">this</span><span class="o">.</span><span class="n">GetLog</span><span class="p">();</span>
        <span class="p">}</span><span class="o">;</span>
<span class="err">}</span>
</pre></div>
<h2 id="dynamicdictionary">六、查看DynamicDictionary</h2>
<p><code>DynamicDictionary</code>类似字典，但功能更多.从请求中获取的值都保存到它里面。可以使用属性或者index来使用捕获的值。</p>
<div class="highlight"><pre><span></span>Get["/hello/{name}"] = parameters =&gt; {
    return "Hello " + parameters.name;
};

Get["/goodbye/{name}"] = parameters =&gt; {
    return "Goodbye " + parameters["name"];
};
</pre></div>
<p>存储的值可以显示或者隐式的转换为基础类型或者特殊属性.使用<code>HasValue</code>决定是否被赋值。值已经实现了<code>IEquatable&lt;&gt;</code>和<code>IConvertible</code>接口。</p>
<h2 id="modulebeforeafter">七、module的before/after钩子</h2>
<p>除了为特定的路由定义处理程序,module还可以拦截匹配某个路由的请求,请求前后都能做到。重要的是要理解,只有传入的请求匹配模块的路由之一，这些拦截器才会被调用。</p>
<h3 id="1_3">1. 在路由被调用前拦截请求</h3>
<p>Before拦截器能让你修改请求，甚至可以通过返回一个response来放弃请求。</p>
<div class="highlight"><pre><span></span>Before += ctx =&gt; {
    return &lt;null or a Response object&gt;;
};
</pre></div>
<p>定义Before拦截器的语法与定义路由有些不同。因为它是定义在module上，被所有路由调用，所以不需要匹配模式。</p>
<p>传给拦截器的是当前请求的NancyContext实例。</p>
<p>最后的不同就是拦截器的返回值，如果返回<code>null</code>，拦截器将主动权转给路由；如果返回<code>Response</code>对象，则路由不起作用。</p>
<h3 id="2-after">2. After拦截器</h3>
<p>与定义Before烂机器相同，但是没有返回值。</p>
<div class="highlight"><pre><span></span>After += ctx =&gt; {
    // Modify ctx.Response
};
</pre></div>
<p>Before拦截器可以修改Request，相应的，After拦截器可以修改Response。</p>
<h2 id="applicationbeforeafteronerror">八、Application的Before,After和OnError管道</h2>
<p>应用管道能在所有的路由上执行，是全局性的。</p>
<h3 id="1before">1.Before拦截</h3>
<p>应用级的<code>Before</code>钩子通过<code>Func&lt;NancyContext, Response&gt;</code>函数定义：</p>
<div class="highlight"><pre><span></span>pipelines.BeforeRequest += (ctx) =&gt; {
    return &lt;null or a Response object&gt;;
};
</pre></div>
<p>异步版本的：</p>
<div class="highlight"><pre><span></span>pipelines.BeforeRequest += async (ctx, token) =&gt; {
    return &lt;null or a Response object&gt;;
};
</pre></div>
<h3 id="2-after_1">2. After拦截</h3>
<p>After拦截器通过`Action<nancycontext>定义：</nancycontext></p>
<div class="highlight"><pre><span></span>pipelines.AfterRequest += (ctx) =&gt; {
    // Modify ctx.Response
};
</pre></div>
<h3 id="3_1">3. 错误拦截器</h3>
<p><code>OnError</code>拦截器用来拦截路由发生的错误。通过它可以获取<code>NancyContext</code>和发生的异常。</p>
<p><code>OnError</code>拦截器通过<code>Func&lt;NancyContext, Exception, Response&gt;</code>函数定义：</p>
<div class="highlight"><pre><span></span>pipelines.OnError += (ctx, ex) =&gt; {
    return null;
};
</pre></div>
<p><strong>System.AggregateExceptions在OnError管道中的注意事项：</strong></p>
<p>路由是通过许多嵌套的Task(<code>System.Threading.Tasks.Task</code>)来执行的。如果那个任务出现了问题，异常会被包装到<code>System.AggregateException</code>。<code>System.AggregateException</code>可以持有任意个异常。</p>
<p>如果只有一个异常，Nancy会解包异常并且交给<code>OnError</code>管道。如果发生多个异常，Nancy会使用<code>System.AggregateException</code>，以避免吞异常。</p>
<h3 id="4_1">4. 构建自己的钩子</h3>
<p>在<a href="https://github.com/NancyFx/Nancy/wiki/Bootstrapper">Bootstrapper</a>中创建系统级的钩子.可以在<code>ApplicationStartup</code>或者<code>RequestStartup</code>方法中定义它们。这是因为也许你需要在钩子中使用容器中的一些东西。两个方法的不同之处在于范围不同。</p>
<div class="highlight"><pre><span></span>protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines)
{
}

protected override void RequestStartup(TinyIoCContainer requestContainer, IPipelines pipelines, NancyContext context)
{
}
</pre></div>
<p>通过使用<code>pipelines</code>中适当的属性来创建钩子。它允许你获取<code>BeforeRequest</code>, <code>AfterRequest</code>和<code>OnError</code>属性。</p>
<h2 id="_5">九、模型绑定</h2>
<p>发送数据给Nancy可以有多种方法，比如Query String, 路由捕获参数、请求体request body。手工处理这些不同的方法也可以，但是还有一种方法就是统一处理，绑定到<code>model</code>。</p>
<p>Nancy只用一行代码就能处理上述的所有情况，并且能接受<code>JSON</code>和<code>XML</code>形式的请求。</p>
<p>也可以扩展Nancy的模型绑定。</p>
<p>Nancy的模型绑定在<code>NancyModule</code>中被定义为一个单独的扩展方法。该扩展在<code>Nancy.ModelBinding</code>命名空间里，并且添加了Bind()和BindTo()方法</p>
<div class="highlight"><pre><span></span>Foo f = this.Bind();

var f = this.Bind&lt;Foo&gt;();

var f = this.BindTo(instance);
</pre></div>
<p>上面3个有着相同的功能，他们提供了做同一事物的不同方法。前两个使用Bind()重载来创建<code>Foo</code>类型的实例，并且绑定；BindTo()则绑定到现有实例。</p>
<h3 id="1_4">1. 屏蔽不想要的信息</h3>
<div class="highlight"><pre><span></span>var f = this.Bind&lt;Foo&gt;(f =&gt; f.id, f =&gt; f.creator, f =&gt; f.createddate);
</pre></div>
<p>或者</p>
<div class="highlight"><pre><span></span>var f = this.Bind&lt;Foo&gt;("id", "creator", "createddate");
</pre></div>
<p>当绑定到到arrary, list或者ienumerable时，屏蔽的是序列中的元素。</p>
<h3 id="2_3">2. 绑定配置</h3>
<p>使用<code>BindingConfig</code>实例来修改model binder的默认行为。</p>
<p>下面是<code>BindingConfig</code>提供的一些配置项：</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>默认</th>
</tr>
</thead>
<tbody>
<tr>
<td>BodyOnly</td>
<td>是否只绑定request body。这种情况下，request和context参数都不会被绑定。如果没有body并且没有选项，那么绑定就不会放生</td>
<td>false</td>
</tr>
<tr>
<td>IgnoreErrors</td>
<td>是否忽略绑定错误并且继续下一个属性</td>
<td>false</td>
</tr>
<tr>
<td>Overwrite</td>
<td>丙丁是否可以覆盖没有默认值的属性</td>
<td>true</td>
</tr>
</tbody>
</table>
<p>不准Overwrite还有一个快捷方法：<code>BindingConfig.NoOverwrite</code></p>
<h3 id="3-rich-request-body-payloads">3. 反序列化rich request body payloads(负载)</h3>
<p>有时你像在请求中发送结构化的数据，比如<code>JSON</code>或者<code>XML</code>，并且绑定到模型。模型绑定器支持这种反序列化。</p>
<p>Nancy支持两种反序列化：JSON和XML。绑定器根据Http的<code>Content-type</code>头来决定使用哪一种反序列化。</p>
<p>默认使用JSON反序列化来处理<code>application/json</code>, <code>text/json</code>和<code>application/vnd....+json</code>。同样的使用XML反序列化来处理<code>application/xml</code>, <code>text/xml</code>和<code>application/vnd....+xml</code></p>
<p>对于其他模型绑定器，你可以使用自己的反序列化，并且Nancy会自动检测他们，任何用户定义的绑定器的优先级都高于内建的。
<strong>注意：</strong>如果你使用Nancy.Json.JsonSetting.MaxJsonLength Exceeded错误，那是因为你的payloads太高了，在Bootstrapper中更改限制：<code>ApplicationStartup</code>中设置<code>Nancy.Json.JsonSettings.MaxJsonLength=int.MaxValue</code></p>
<h3 id="4-checkbox">4. 模型绑定Checkbox</h3>
<p>要绑定复选框到bool值，确定设置<code>value=true</code>：</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"checkbox"</span> <span class="na">name</span><span class="o">=</span><span class="s">"rememberMe"</span> <span class="na">value</span><span class="o">=</span><span class="s">"true"</span><span class="p">/&gt;</span>
</pre></div>
<div class="highlight"><pre><span></span>public class LoginModel
{
    public bool RememberMe { get; set; }
}
</pre></div>
<h3 id="5-list">5. 绑定到list</h3>
<h4 id="51-arrary">5.1 绑定arrary到单独的对象</h4>
<p>如果有一个form:</p>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">"/ArrayOnObject"</span> <span class="na">method</span><span class="o">=</span><span class="s">"post"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Tags"</span> <span class="na">value</span><span class="o">=</span><span class="s">"Tag1,Tag2,Tag3"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Ints"</span> <span class="na">value</span><span class="o">=</span><span class="s">"1,2,3,4,4,5,6,3,2,21,1"</span><span class="p">/&gt;</span>
  <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">value</span><span class="o">=</span><span class="s">"Submit"</span><span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</pre></div>
<p>而且有一个类：</p>
<div class="highlight"><pre><span></span>public class Posts
{
  public string[] Tags { get; set; }
  public int[] Ints { get; set; }
}
</pre></div>
<p>使用一个简单的语句：</p>
<div class="highlight"><pre><span></span>var listOfPosts = this.Bind&lt;Posts&gt;();
</pre></div>
<h4 id="52-list">5.2 绑定到对象的list</h4>
<div class="highlight"><pre><span></span><span class="p">&lt;</span><span class="nt">form</span> <span class="na">action</span><span class="o">=</span><span class="s">"/SimpleListDemo"</span> <span class="na">method</span><span class="o">=</span><span class="s">"post"</span><span class="p">&gt;</span>
      User 1:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Name[0]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"thecodejunkie"</span> <span class="p">/&gt;</span> 
      Commits <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Commits[0]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"1068"</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">br</span> <span class="p">/&gt;</span>
      User 2:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Name[1]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"grumpydev"</span> <span class="p">/&gt;</span>  
      Commits <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Commits[1]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"1049"</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">br</span> <span class="p">/&gt;</span>
      User 3:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Name[2]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"jchannon"</span> <span class="p">/&gt;</span>  
      Commits <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Commits[2]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"109"</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">br</span> <span class="p">/&gt;</span>
      User 4:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Name[3]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"prabirshrestha"</span> <span class="p">/&gt;</span>  
      Commits <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Commits[3]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"75"</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">br</span> <span class="p">/&gt;</span>
      User 5:<span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Name[4]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"phillip-haydon"</span> <span class="p">/&gt;</span>  
      Commits <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"text"</span> <span class="na">name</span><span class="o">=</span><span class="s">"Commits[4]"</span> <span class="na">value</span><span class="o">=</span><span class="s">"40"</span><span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">br</span> <span class="p">/&gt;</span>
      <span class="p">&lt;</span><span class="nt">input</span> <span class="na">type</span><span class="o">=</span><span class="s">"submit"</span> <span class="na">value</span><span class="o">=</span><span class="s">"Test the binding thingy"</span><span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="nt">form</span><span class="p">&gt;</span>
</pre></div>
<p>可以使用<code>this.Bind&lt;List&lt;User&gt;&gt;();</code>来绑定对象列表：</p>
<div class="highlight"><pre><span></span>public class User
{
   public string Name { get; set; }
   public int Commits { get; set; }
}
</pre></div>
<h4 id="53-html-formlist">5.3 HTML form中的List分隔符</h4>
<p>两种分隔符</p>
<ul>
<li>下划线(<code>Name_1</code>, <code>Name_2</code>等)</li>
<li>括号(<code>Name[1]</code>, <code>Name[2]</code>等)</li>
</ul>
<h2 id="bootstrapper">十、Bootstrapper</h2>
<p>bootstrapper负责自动发现模型、自定义模型绑定、依赖等等。可以被替换掉。</p>
<h3 id="1-bootstrapper">1. 简单的修改bootstrapper</h3>
<div class="highlight"><pre><span></span>public class CustomBootstrapper : DefaultNancyBootstrapper
{
    protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines)
    {
         // your customization goes here
    }
}
</pre></div>
<h3 id="2-bootstrapper">2. 找到合适的bootstrapper</h3>
<p>应用启动时，它会寻找自定义的bootstrap，如果没有找到，则使用<code>DefaultNancyBootstrap</code>。每个应用只能有<strong>一个</strong>bootstrapper. 如果有多个，则Nancy寻找最底层的bootstrapper。</p>
<h3 id="3_2">3. 使用自动注册</h3>
<p>注入自己的依赖到NancyModule中</p>
<div class="highlight"><pre><span></span>public class Home : NancyModule
{
    public Home(IMessageService service)
    {
        //If there is only one implementation of IMessageService in the application,
        // TinyIoC will resolve the dependency on its own and inject it in the module.
    }
}
</pre></div>
<h2 id="_6">十一、视图引擎</h2>
<p>视图引擎就是输入“模板”和“模型”，输出HTML（大部分情况下）到浏览器。</p>
<p>Nancy默认使用<a href="https://github.com/grumpydev/SuperSimpleViewEngine"><code>SuperSimpleViewEngine</code></a>。它支持一些必要的功能：layout布局、partials部分、models模型、conditions条件和iterations循环。你可以使用这个而不无需其他依赖。它支持<code>.html</code>和<code>.sshtml</code>文件。</p>
<div class="highlight"><pre><span></span>@Master['MasterPage']

@Section['Content']
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>This content from the index page<span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span>Partials<span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Login box below rendered via a partial view with no model.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"login"</span><span class="p">&gt;</span>
        @Partial['login'];
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Box below is rendered via a partial with a sub-model passed in.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>The submodel is a list which the partial iterates over with Each<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">div</span> <span class="na">id</span><span class="o">=</span><span class="s">"users"</span><span class="p">&gt;</span>
        @Partial['user', Model.Users];
    <span class="p">&lt;/</span><span class="nt">div</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">h3</span><span class="p">&gt;</span>Encoding<span class="p">&lt;/</span><span class="nt">h3</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>Model output can also be encoded:<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="nt">p</span><span class="p">&gt;</span>@!Model.NaughtyStuff<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;</span>
@EndSection
</pre></div>
<p>除此之外，Nancy还支持Razor, Spark, NDjango和dotLiquid引擎。通过添加引用，Nancy会自动的根据文件后缀名调用对应的引擎。</p>
<h3 id="1_5">1. 在路由中渲染视图</h3>
<div class="highlight"><pre><span></span>Get["/products"] = parameters =&gt; {
    return View["products.html", someModel];
};
</pre></div>
<p>模板说明：
1. 视图文件名: "products.html"
2. 如果没有后缀，而且有多个同名模板，则会收到<code>AmbigiousViewsException</code>错误。
3. 一个相对于跟的路径(比如：<code>products/products.html</code>)</p>
<p>更多参见<a href="https://github.com/NancyFx/Nancy/wiki/View-location-conventions">视图位置约定</a></p>
<h3 id="2_4">2.从模型中解析视图的名称</h3>
<p>如果值传递给View一个模型，Nancy会用模型名（去掉"Model"后缀）作为视图名。</p>
<div class="highlight"><pre><span></span>Get["/products"] = parameters =&gt; {
    return View[new ProductsModel()];
};
</pre></div>
<p>如果找不到，就会报406 Not Acceptable.</p>
<h2 id="_7">十二、超简单视图引擎</h2>
<p>SSVE基于正则，支持<code>sshtml</code>, <code>html</code>, <code>html</code>文件后缀。</p>
<p>模型可以是标准类型，或者<code>ExpandoObjects</code>（或者实现了<code>IDynamicMetaObjectProvider</code> 实现了<code>IDictionary&lt;string, object&gt;</code>的对象）。</p>
<p>所有的命令都可以有分号，但不是必须的。<code>[.Parameters]</code>这样的参数可以使任意层级的，比如<code>This.Property.That.Property</code>。</p>
<p>注意：所有引号都是_单引号_.</p>
<h3 id="1_6">1. 标准变量替换</h3>
<p>如果变量不能替换，则使用<code>[Err!]</code>替换。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@Model[.Parameters]
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>Hello @Model.Name, your age is @Model.User.Age
</pre></div>
<h3 id="2_5">2. 循环</h3>
<p>循环不能嵌套</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@Each[.Parameters]
   [@Current[.Parameters]]
@EndEach
</pre></div>
<p><code>@Each</code>表示循环；<code>@Current</code>表示当前变量，使用方法同<code>@Model</code>。</p>
<p>例子：</p>
<div class="highlight"><pre><span></span>@Each.Users
   Hello @Current.Name!
@EndEach
</pre></div>
<h3 id="3_3">3. 条件</h3>
<p>参数必须是bool，或能隐式转化。嵌套的@If @IfNot不支持。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@If[Not].Parameters
   [contents]
@EndIf
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>@IfNot.HasUsers
   No users found!
@EndIf
</pre></div>
<h3 id="4_2">4. 隐式条件</h3>
<p>如果module实现了<code>ICollection</code>，那你就能使用隐式转换。使用<code>Has</code>前缀。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>Has[CollectionPropertyName]
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>@If.HasUsers
   Users found!
@EndIf
</pre></div>
<h3 id="5-html">5. HTML编码</h3>
<p><code>@Model</code>和<code>@Current</code>都可以有一个<code>!</code>，用来编码HTML：</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@!Model[.Parameter]
@!Current[.Parameter]
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>@!Model.Test

@Each
   @!Current.Test
@EndEach
</pre></div>
<h3 id="6-patials">6. 部分Patials</h3>
<p>语法：</p>
<div class="highlight"><pre><span></span>@Partial['&lt;view name&gt;'[, Model.Property]]
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>// Renders the partial view with the same model as the parent
@Partial['subview.sshtml'];

// Renders the partial view using the User as the model
@Partial['subview.sshtml', Model.User];
</pre></div>
<h3 id="7-mastersection">7. Master页和section</h3>
<p>可以声明master页和节。不必为每个节提供内容。Master能用<code>@Module</code>，并且扩展名可以省略。</p>
<p>可以多次使用<code>@Section</code></p>
<p>语法</p>
<div class="highlight"><pre><span></span>@Master['&lt;name&gt;']

@Section['&lt;name&gt;']
@EndSection
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>// master.sshtml
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;body&gt;</span>
@Section['Content'];
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

// index.sshtml
@Master['master.sshtml']

@Section['Content']
   This is content on the index page
@EndSection
</pre></div>
<h3 id="8-token">8. 防止伪造token</h3>
<p>防止CSRF</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@AntiForgeryToken
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>@AntiForgeryToken
</pre></div>
<h3 id="9">9. 路径扩展</h3>
<p>扩展相对路径为整体路径。</p>
<p>语法：</p>
<div class="highlight"><pre><span></span>@Path['&lt;relative-path&gt;']
</pre></div>
<p>例子：</p>
<div class="highlight"><pre><span></span>@Path['~/relative/url/image.png']
</pre></div>
<h3 id="10-ssve">10. 扩展SSVE</h3>
<h2 id="razor">十二、Razor引擎</h2>
<p>这个Razor引擎跟ASP.NET MVC的有点不一样。</p>
<p>注意，Nancy仍然绑定模型到<code>@Model</code>，而不是ASP.NET中的<code>@model</code></p>
<h3 id="1-razor">1. 安装Razor</h3>
<p>只需要添加<code>Nancy.ViewEngines.Razor.dll</code>（使用nuget安装<code>Nancy.ViewEngines.Razor</code>）。然后试图模板以<code>cshtml</code>或<code>vbhtml</code>结尾即可。</p>
<h3 id="2-razor">2. 配置Razor</h3>
<h2 id="_8">十三、实现自己的视图引擎需要注意的地方</h2>
<h2 id="_9">十四、视图位置约定</h2>
<h3 id="1_7">1. 查看默认约定</h3>
<p>视图位置的约定通过<code>Func&lt;string, dynamic, ViewLocationContext, string&gt;</code>方法以及下面的一些默认约定来定义。</p>
<h4 id="11">1.1 根约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return viewName;
}
</pre></div>
<p>这个约定会在根目录里寻找视图。但是如果视图包含一个相对路径，视图名称执行对应于根路径的路径。比如，视图<code>admin/index</code>会在<code>admin/index</code>目下寻找视图。</p>
<h4 id="12">1.2 视图文件夹约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return string.Concat("views/", viewName);
}
</pre></div>
<p>很简单，视图<code>admin/index</code>会在<code>views/admin/index</code>下查找对应的视图。</p>
<h4 id="13">1.3 视图和模块路径约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return string.Concat("views/", viewLocationContext.ModulePath, "/", viewName);
}
</pre></div>
<p>对于模块products的视图<code>admin/index</code>，会在<code>views/products/admin/index</code>中查找视图。</p>
<h4 id="14">1.4 模块路径约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return string.Concat(viewLocationContext.ModulePath, "/", viewName);
}
</pre></div>
<p>这个约定会在与模块名相同的文件夹中查找视图。</p>
<h4 id="15">1.5 模块名称约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return string.Concat(viewLocationContext.ModuleName, "/", viewName);
}
</pre></div>
<p>查找以模块名为前缀的对应视图。</p>
<h4 id="16">1.6 视图模块名称约定</h4>
<div class="highlight"><pre><span></span>(viewName, model, viewLocationContext) =&gt; {
    return string.Concat("views/", viewLocationContext.ModuleName, "/", viewName);
}
</pre></div>
<p>查找views文件夹下以模块名为前缀的对应视图。</p>
<h3 id="2_6">2. 从模型类型推断是退名</h3>
<p>如果没有提供视图名而只提供了视图，那么：</p>
<ul>
<li><code>Customer</code>类型的模型-&gt;<code>Customer</code>视图名</li>
<li><code>CustomerModel</code>类型的模型-&gt; <code>Customer</code>视图名</li>
</ul>
<h3 id="3_4">3. 自定义约定</h3>
<p>自定义一个bootstrapper，然后添加约定到<code>Conventions.ViewLocationConventions</code>集合。</p>
<p>比如：</p>
<div class="highlight"><pre><span></span>public class CustomConventionsBootstrapper : DefaultNancyBootstrapper
{
    protected override void ApplicationStartup(TinyIoCContainer container, Nancy.Bootstrapper.IPipelines pipelines)
    {
        this.Conventions.ViewLocationConventions.Add((viewName, model, context) =&gt;
        {
            return string.Concat("custom/", viewName);
        });
    }
}
</pre></div>
<p>比如这个会查找custom文件夹下的视图名称。</p>
<p><code>ViewLocationConventions</code>是一个标准的列表，可以进行修改。</p>
<h3 id="3-iconventions">3. 使用IConventions定义自己的约定</h3>
<p>你也可以实现<code>IConvention</code>接口，并在<code>Initialise</code>方法中添加约定到<code>ViewLocationConventions</code>属性中。</p>
<p>Nancy会定位所有接口的实现，并且执行约定，这些发生在他们被传递给bootstrapper的<code>ConfigureConventions</code>方法之前。</p>
<h2 id="_10">十五、本地化</h2>
<p>Nancy内建了本地化。有一系列的<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Conventions/DefaultCultureConventions.cs">约定</a>描述了如何决定当前文化，还有一些根据文化选择视图的<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Conventions/DefaultViewLocationConventions.cs">约定</a>。</p>
<p>所以，对于<code>de-DE</code>的文化他会寻找<code>Home-de-DE</code>的视图。</p>
<p>不仅如此，还会有rese文件，比如<code>Text.resx</code>， <code>Text.de-DE.resx</code>（可以被<a href="https://github.com/NancyFx/Nancy/blob/master/src/Nancy/Localization/ResourceBasedTextResource.cs">重写</a>).</p>
<p>Razor本地化的<a href="https://github.com/NancyFx/Nancy/tree/master/src/Nancy.Demo.Razor.Localization">例子</a></p>
<h2 id="_11">十六、测试应用</h2>
<p>使用<a href="http://nuget.org/">NuGet</a>来安装<code>Nancy.Testing</code>。</p>
<p>测试应当与主应用分开。</p>
<p>为了测试路由，使用helper类<code>Browser</code>。使用bootstrap实例化Browser。</p>
<div class="highlight"><pre><span></span><span class="k">[Fact]</span>
<span class="err">public</span> <span class="err">void</span> <span class="err">Should_return_status_ok_when_route_exists()</span>
<span class="err">{</span>
    <span class="err">//</span> <span class="err">Given</span>
    <span class="na">var bootstrapper</span> <span class="o">=</span> <span class="s">new DefaultNancyBootstrapper();</span>
<span class="s">    var browser = new Browser(bootstrapper);</span>

    <span class="err">//</span> <span class="err">When</span>
    <span class="na">var result</span> <span class="o">=</span> <span class="s">browser.Get("/", with =&gt; {</span>
<span class="s">        with.HttpRequest();</span>
<span class="s">    });</span>

    <span class="err">//</span> <span class="err">Then</span>
    <span class="err">Assert.Equal(HttpStatusCode.OK,</span> <span class="err">result.StatusCode)</span><span class="c1">;</span>
<span class="err">}</span>
</pre></div>
<h2 id="_12">十七、根路径</h2>
<p>Nancy通过<code>IRootPathProvider</code>接口的唯一方法<code>GetRootPath</code>来确定根路径。</p>
<h3 id="1_8">1. 改变跟路径</h3>
<p>改变根路径需要做两件事：</p>
<p>首先，自定义一个类实现<code>IRootPathProvider</code>：</p>
<div class="highlight"><pre><span></span>public class CustomRootPathProvider : IRootPathProvider
{
    public string GetRootPath()
    {
        return "What ever path you want to use as your application root";
    }
}
</pre></div>
<p>注意，根路径是绝对路径。</p>
<p>其次，在自定义的Bootstrapper中重写<code>RootPathProvider</code>属性。</p>
<div class="highlight"><pre><span></span>public class CustomBootstrapper : DefaultNancyBootstrapper
{
    protected override IRootPathProvider RootPathProvider
    {
        get { return new CustomRootPathProvider(); }
    }
}
</pre></div>
<h3 id="2_7">2. 上传文件</h3>
<p>在Nancy中要上传文件，你需要接受上传文件的content stream, 在磁盘上创建文件，并将stream写入到磁盘。</p>
<div class="highlight"><pre><span></span>var uploadDirectory =  Path.Combine(pathProvider.GetRootPath(), "Content", "uploads");

if (!Directory.Exists(uploadDirectory))
{
    Directory.CreateDirectory(uploadDirectory);
}

foreach (var file in Request.Files)
{
    var filename = Path.Combine(uploadDirectory, file.Name);
    using (FileStream fileStream = new FileStream(filename, FileMode.Create))
    {
        file.Value.CopyTo(fileStream);
    }
}
</pre></div>
<p>上例中的<code>pathProvider</code>是在模块的构造函数中传递进来的，通过它的<code>GetRootPath()</code>来获取跟路径。</p>
<div class="highlight"><pre><span></span>public HomeModule(IRootPathProvider pathProvider)
</pre></div>
<h2 id="_13">十八、管理静态内容</h2>
<p><strong>简而言之：把东西都放到<code>/Content</code>文件夹内，仅此而已</strong></p>
<h2 id="_14">十九、诊断</h2>
<p>Nancy自带诊断功能：<code>http://&lt;address-of-your-application&gt;/_Nancy/</code></p>
<h3 id="1-dashboard">1. 配置到dashboard的访问</h3>
<p>添加密码：</p>
<div class="highlight"><pre><span></span><span class="n">public</span> <span class="k">class</span> <span class="nl">CustomBootstrapper</span> <span class="p">:</span> <span class="n">DefaultNancyBootstrapper</span>
<span class="p">{</span>
    <span class="n">protected</span> <span class="n">override</span> <span class="n">DiagnosticsConfiguration</span> <span class="n">DiagnosticsConfiguration</span>
    <span class="p">{</span>
        <span class="n">get</span> <span class="p">{</span> <span class="k">return</span> <span class="n">new</span> <span class="n">DiagnosticsConfiguration</span> <span class="p">{</span> <span class="n">Password</span> <span class="o">=</span> <span class="s">@"A2</span><span class="se">\6</span><span class="s">mVtH/XRT\p,B"</span><span class="p">};</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
<h3 id="2_8">2. 去除诊断</h3>
<div class="highlight"><pre><span></span>public class CustomBootstrapper : DefaultNancyBootstrapper
{
    protected override void ApplicationStartup(TinyIoc.TinyIoCContainer container, IPipelines pipelines)
    {
        DiagnosticsHook.Disable(pipelines);
    }
}
</pre></div>
<h3 id="3_5">3. 有哪些工具呢？</h3>
<p><code>Information</code>, <code>Interactive Diagnostics</code>, <code>Request Tracing</code>, <code>Configuration</code></p>
<h4 id="31">3.1 信息</h4>
<h4 id="32">3.2 配置</h4>
<p>Nancy中<code>StaticConfiguration</code>可以用来配置程序的行为，配置页面提供了配置方法。</p>
<p>注意，系统重启后配置页面的内容失效。</p>
<p>要想永久保存配置，请在bootstrapper的<code>ApplicationStartup</code>中设置。</p>
<h4 id="33">3.3 请求跟踪</h4>
<p>请求跟踪因为性能原因默认关闭，可以再<code>Configuration</code>页开启，也可以这样：</p>
<div class="highlight"><pre><span></span>public class CustomBootstrapper : DefaultNancyBootstrapper
{
    protected override void ApplicationStartup(TinyIoC.TinyIoCContainer container, IPipelines pipelines)
    {
        StaticConfiguration.EnableRequestTracing = true;
    }
}
</pre></div>
<p>跟踪日志可以通过<code>NancyContext</code>中得到。和容易添加自己的内容：</p>
<div class="highlight"><pre><span></span>public class HomeModule : NancyModule
{
    public HomeModule()
    {
        Get["/"] = parameters =&gt; {
            this.Context.Trace.TraceLog.WriteLog(s =&gt; s.AppendLine("Root path was called"));
            return HttpStatusCode.Ok;
        };
    }
}
</pre></div>
<p><code>WriteLog</code>方法是用一个接受<code>StringBuilder</code>的函数是为了调试关闭时直接不调用函数，从而避免性能损耗。</p>
<h4 id="34">3.4 交互式的诊断</h4>
<p>只要实现了<code>IDiagnosticsProvider</code>接口，Nancy诊断会自动发现它，并且把它暴露给交互工具。</p>
<h5 id="1idiagnosticsprovider">（1）IDiagnosticsProvider接口</h5>
<div class="highlight"><pre><span></span>/// <span class="nt">&lt;summary&gt;</span>
/// Defines the functionality a diagnostics provider.
/// <span class="nt">&lt;/summary&gt;</span>
public interface IDiagnosticsProvider
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets the name of the provider.
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;value&gt;</span>A <span class="nt">&lt;see</span> <span class="na">cref=</span><span class="s">"string"</span><span class="nt">/&gt;</span> containing the name of the provider.<span class="nt">&lt;/value&gt;</span>
   string Name { get; }

   /// <span class="nt">&lt;summary&gt;</span>
   /// Gets the description of the provider.
   /// <span class="nt">&lt;/summary&gt;</span>
   /// <span class="nt">&lt;value&gt;</span>A <span class="nt">&lt;see</span> <span class="na">cref=</span><span class="s">"string"</span><span class="nt">/&gt;</span> containing the description of the provider.<span class="nt">&lt;/value&gt;</span>
   string Description { get; }

   /// <span class="nt">&lt;summary&gt;</span>
   /// Gets the object that contains the interactive diagnostics methods.
   /// <span class="nt">&lt;/summary&gt;</span>
   /// <span class="nt">&lt;value&gt;</span>An instance of the interactive diagnostics object.<span class="nt">&lt;/value&gt;</span>
   object DiagnosticObject { get; }
}
</pre></div>
<h5 id="2_9">（2）可诊断的对象</h5>
<p>任何公共方法都会暴露给交互诊断面板。方法可以是能被JSON序列化的任意类型。类型的返回值会被返回成<a href="http://www.servicestack.net/docs/framework/json-report-format">JSON Report Format</a></p>
<h5 id="3_6">（3）提供描述给方法</h5>
<p>两种方法：
1、使用attribute: <code>Nancy.Diagnostics.DescriptionAttribute</code></p>
<p>2、使用property：使用与方法同名但添加了<code>Description</code>后缀的属性，比如<code>NameOfYourMethodDescription</code>描述了<code>NameOfYourMethod</code>方法。</p>
<h5 id="4_3">（4）自定义模板输出</h5>
<h5 id="5_1">（5）创建诊断提供者</h5>
<h2 id="favicon">二十、添加自己的favicon</h2>
<h3 id="1-favicon">1. 替换默认的FavIcon</h3>
<p>在应用中防止一个_favicon_的文件，名称以<code>.icon</code>或<code>.png</code>结尾即可。</p>
<h3 id="2-icon">2. 使用内嵌icon</h3>
<p>在Bootstrapper中重写<code>FavIcon</code>属性：</p>
<div class="highlight"><pre><span></span>public class Bootstrapper : DefaultNancyBootstrapper
{
    private byte[] favicon;

    protected override byte[] FavIcon
    {
        get { return this.favicon?? (this.favicon= LoadFavIcon()); }
    }

    private byte[] LoadFavIcon()
    {
        //TODO: remember to replace 'AssemblyName' with the prefix of the resource
        using (var resourceStream = GetType().Assembly.GetManifestResourceStream("AssemblyName.favicon.ico"))
        {
            var tempFavicon = new byte[resourceStream.Length];
            resourceStream.Read(tempFavicon, 0, (int)resourceStream.Length);
            return tempFavicon;
        }
    }
}
</pre></div>
<h3 id="3-icon">3. 移除ICON</h3>
<p>设置Bootstrapper的<code>FavIcon</code>属性为<code>null</code>。</p>
<h2 id="_15">二十一、添加自定义的错误页面</h2>
<p>第一篇:http://mike-ward.net/blog/post/00824/custom-error-pages-in-nancyfx</p>
<p>第二篇：https://blog.tommyparnell.com/custom-error-pages-in-nancy/</p>
<h2 id="_16">二十二、加密帮助方法</h2>
<p>命名空间:<code>Nancy.Cryptography</code></p>
<h3 id="1-iencryptionprovider">1. IEncryptionProvider 接口</h3>
<div class="highlight"><pre><span></span>/// <span class="nt">&lt;summary&gt;</span>
/// Provides symmetrical encryption support
/// <span class="nt">&lt;/summary&gt;</span>
public interface IEncryptionProvider
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Encrypt and base64 encode the string
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"data"</span><span class="nt">&gt;</span>Data to encrypt<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Encrypted string<span class="nt">&lt;/returns&gt;</span>
    string Encrypt(string data);

    /// <span class="nt">&lt;summary&gt;</span>
    /// Decrypt string
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"data"</span><span class="nt">&gt;</span>Data to decrypt<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Decrypted string<span class="nt">&lt;/returns&gt;</span>
    string Decrypt(string data);
}
</pre></div>
<p>Nancy提供了两个默认实现</p>
<ul>
<li><code>NoEncryptionProvider</code>:没有加密，仅仅是base64</li>
<li><code>RijndaelEncryptionProvider</code>: 使用Rijndael算法，使用256位的key和128为的初始向量，加密base64字符串。</li>
</ul>
<h3 id="2-ihmacprovider">2. IHmacProvider 接口</h3>
<p>用来签名，防止篡改。</p>
<div class="highlight"><pre><span></span>/// <span class="nt">&lt;summary&gt;</span>
/// Creates Hash-based Message Authentication Codes (HMACs)
/// <span class="nt">&lt;/summary&gt;</span>
public interface IHmacProvider
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets the length of the HMAC signature in bytes
    /// <span class="nt">&lt;/summary&gt;</span>
    int HmacLength { get; }

    /// <span class="nt">&lt;summary&gt;</span>
    /// Create a hmac from the given data
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"data"</span><span class="nt">&gt;</span>Data to create hmac from<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Hmac bytes<span class="nt">&lt;/returns&gt;</span>
    byte[] GenerateHmac(string data);

    /// <span class="nt">&lt;summary&gt;</span>
    /// Create a hmac from the given data
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"data"</span><span class="nt">&gt;</span>Data to create hmac from<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Hmac bytes<span class="nt">&lt;/returns&gt;</span>
    byte[] GenerateHmac(byte[] data);
}
</pre></div>
<p>Nancy也提供了一个默认实现：<code>DefaultHmacProvider</code>，使用<code>IKeyGenerator</code>来产生一个key来用SHA-256来进行hash。</p>
<h3 id="3-ikeygenerator">3. IKeyGenerator 接口</h3>
<p>用来产生key来加密和数字签名。</p>
<div class="highlight"><pre><span></span>/// <span class="nt">&lt;summary&gt;</span>
/// Provides key byte generation
/// <span class="nt">&lt;/summary&gt;</span>
public interface IKeyGenerator
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Generate a sequence of bytes
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"count"</span><span class="nt">&gt;</span>Number of bytes to return<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Array <span class="nt">&lt;see</span> <span class="na">cref=</span><span class="s">"count"</span><span class="nt">/&gt;</span> bytes<span class="nt">&lt;/returns&gt;</span>
    byte[] GetBytes(int count);
}
</pre></div>
<p>Nancy提供了两个默认实现。</p>
<ul>
<li>
<p><code>RandomKeyGenerator</code>使用<code>RNGCryptoServiceProvider</code>产生了一个随机定长的key</p>
</li>
<li>
<p><code>PassphraseKeyGenerator</code>使用密码、静态盐以及可选循环数字，以及<code>Rfc2898DeriveBytes</code>来产生一个key</p>
</li>
</ul>
<p><strong>注意</strong>，如果使用<code>PassphraseKeyGenerator</code>，它的初始化应当在应用启动时使用，因为它太慢了。这意味着盐是静态的，因此密码一定要足够长和复杂。</p>
<h3 id="4-cryptographyconfiguration">4. 加密配置类型CryptographyConfiguration</h3>
<p>这是一个存储<code>IEncryptionProvider</code>和<code>IHmacProvider</code>的简便方法。它有两个静态属性：</p>
<ul>
<li><code>Default</code>使用<code>RijndaelEncryptionProvider</code>和<code>DefaultHmacProvider</code>，两个都使用<code>RandomKeyGenerator</code>。</li>
<li><code>NoEncryption</code>使用<code>NoEncryption</code>和<code>DefaultHmacProvider</code>，两个也都使用<code>RandomKeyGenerator</code>.</li>
</ul>
<p>可以单独使用<code>CryptographyConfiguration</code>，也可以在bootstrapper中配置一个：</p>
<div class="highlight"><pre><span></span>/// <span class="nt">&lt;summary&gt;</span>
/// Gets the cryptography configuration
/// <span class="nt">&lt;/summary&gt;</span>
protected virtual CryptographyConfiguration CryptographyConfiguration
{
    get { return CryptographyConfiguration.Default; }
}
</pre></div>
<h2 id="content-negotiation">二十三、Content negotiation(内容协商)</h2>
<p>当返回不是<code>Response</code>类型时，使用response processor来根据请求的<code>Accept</code>来处理。</p>
<h3 id="1-response-processor">1. Response Processor</h3>
<div class="highlight"><pre><span></span>public interface IResponseProcessor
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets a set of mappings that map a given extension (such as .json)
    /// to a media range that can be sent to the client in a vary header.
    /// <span class="nt">&lt;/summary&gt;</span>
    IEnumerable<span class="nt">&lt;Tuple</span><span class="err">&lt;string,</span> <span class="err">MediaRange</span><span class="nt">&gt;</span>&gt; ExtensionMappings { get; }

    /// <span class="nt">&lt;summary&gt;</span>
    /// Determines whether the the processor can handle a given content type and model.
    /// <span class="nt">&lt;/summary&gt;</span>
    ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context);

    /// <span class="nt">&lt;summary&gt;</span>
    /// Process the response.
    /// <span class="nt">&lt;/summary&gt;</span>
    Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context);
}
</pre></div>
<p>Response Processor是自发现的，也可以在Bootstrap中配置。</p>
<div class="highlight"><pre><span></span>public class Bootstrapper : DefaultNancyBootstrapper
{
    protected override NancyInternalConfiguration InternalConfiguration
    {
        get
        {
            var processors = new[]
            {
                typeof(SomeProcessor),
                typeof(AnotherProcessor)
            };

            return NancyInternalConfiguration.WithOverrides(x =&gt; x.ResponseProcessors = processors);
        }
    }
}
</pre></div>
<h4 id="11_1">1.1 匹配优先级</h4>
<p>当相应准备转化请求媒体的格式时，Nancy会查询所有的processor的<code>CanProcess</code>方法，并且会聚合<code>ProcessorMatch</code>的返回值。</p>
<p><code>ProcessorMatch</code>类型确保每个processor让Nancy知道它们对媒体类型的支持程度。</p>
<div class="highlight"><pre><span></span>public class ProcessorMatch
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets or sets the match result based on the content type
    /// <span class="nt">&lt;/summary&gt;</span>
    public MatchResult RequestedContentTypeResult { get; set; }

    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets or sets the match result based on the model
    /// <span class="nt">&lt;/summary&gt;</span>
    public MatchResult ModelResult { get; set; }
}
</pre></div>
<p><code>MatchResult</code>枚举了匹配程度：</p>
<div class="highlight"><pre><span></span>public enum MatchResult
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// No match, nothing to see here, move along
    /// <span class="nt">&lt;/summary&gt;</span>
    NoMatch,

    /// <span class="nt">&lt;summary&gt;</span>
    /// Will accept anything
    /// <span class="nt">&lt;/summary&gt;</span>
    DontCare,

    /// <span class="nt">&lt;summary&gt;</span>
    /// Matched, but in a non-specific way such as a wildcard match or fallback
    /// <span class="nt">&lt;/summary&gt;</span>
    NonExactMatch,

    /// <span class="nt">&lt;summary&gt;</span>
    /// Exact specific match
    /// <span class="nt">&lt;/summary&gt;</span>
    ExactMatch
}
</pre></div>
<p>所有的<code>ProcessorMatch</code>会按照Match程度降序排列，最匹配的被执行。如果有两个匹配程度相同，Nancy会选择其中一个。</p>
<h4 id="12_1">1.2 默认响应处理器</h4>
<p>Nancy提供了一些默认响应处理器</p>
<ul>
<li><code>JsonProcessor</code> - 当请求类型为<code>application/json</code>或者<code>application/vnd.foobar+json</code>时，转化返回值为json；</li>
<li><code>ViewProcessor</code> - 当请求类型为<code>text/html</code>时，使用返回值作为model，返回视图。视图使用<a href="https://github.com/NancyFx/Nancy/wiki/View-location-conventions">视图位置约定</a>；</li>
<li><code>XmlProcessor</code> - 当请求为<code>application/xml</code>或者为<code>application/vnd.foobar+xml</code>时，返回xml。</li>
</ul>
<h3 id="2_10">2. 控制协商</h3>
<p><code>Nancy.Responses.Negotiation</code>命名空间中的<code>Negotiator</code>用来控制协商。<code>Negotiator</code>有一个属性：<code>NegotiationContext</code>. <code>NegotiationContext</code>可以用来控制响应的协商。</p>
<p>但是一般不会直接使用<code>Negotiator</code>和<code>NegotiationContext</code>，因为<code>NancyModule</code>包含了一个帮助方法<code>Negotiate</code>，用来更好的创造<code>Negotiator</code>实例。</p>
<p>在路由中使用<code>Negotiator</code>的例子：</p>
<div class="highlight"><pre><span></span>Get["/"] = parameters =&gt; {
    return Negotiate
        .WithModel(new RatPack {FirstName = "Nancy "})
        .WithMediaRangeModel("text/html", new RatPack {FirstName = "Nancy fancy pants"})
        .WithView("negotiatedview")
        .WithHeader("X-Custom", "SomeValue");
};
</pre></div>
<p><code>Negotiator</code>包含了用来配置返回<code>Negotiator</code>实例的一些方法。</p>
<ul>
<li><code>WithHeader</code> - 添加一个Http头；</li>
<li><code>WithHeaders</code> - 添加一个Http的头集合；</li>
<li><code>WithView</code> - 使用视图；</li>
<li><code>WithModel</code> - 使用模型；</li>
<li><code>WithMediaRangeModel</code> - 使用特定的媒体类型和模型，如果失败了，就使用<code>WithModel</code>指定的模型；</li>
<li><code>WithFullNegotiation</code> - 设置允许媒体类型为<code>*/*</code>的帮助方法；</li>
<li><code>WithAllowedMediaRange</code> - 指定允许的媒体范围。默认是"/",但是一旦指定一个特定的内容类型，通配符就会被移走。</li>
<li><code>WithStatusCode</code> - 状态码</li>
</ul>
<h3 id="3_7">3. 支持文件扩展名</h3>
<p>Nancy支持基于扩展名来设置协商的处理，此时传递正常的可接受的头。</p>
<p>例子：</p>
<div class="highlight"><pre><span></span>Get["/ratpack"] = parameters =&gt; {
    return new RatPack {FirstName = "Nancy "});
};
</pre></div>
<p>它既可以通过<code>/ratpack</code>和设置的<code>application/json</code>头来调用，也可以使用<code>/ratpack.json</code>并且不设置<code>application/json</code>来调用，两个结果一样。</p>
<p>内部Nancy是通过检测扩展名，并查询可用的响应处理器的<code>ExtensionMappings</code>属性来查看是否有支持的扩展。如果有，就调用并且设置对应的头信息，但是如果有更优先的处理器，则用更优先的处理器，除非更优先的处理器失败了，才会使用扩展。</p>
<h3 id="4-accept-header">4. 强制可接受的头(Accept Header)</h3>
<p>约定的格式：</p>
<div class="highlight"><pre><span></span>Func&lt;
   IEnumerable&lt;Tuple&lt;string, decimal&gt;&gt;,
   NancyContext,
   IEnumerable&lt;Tuple&lt;string, decimal&gt;&gt;&gt;
</pre></div>
<p>这个函数接受<code>NancyContext</code>和当前头，并且期望你返回修改后的可接受头列表。</p>
<p>默认情况下，Nancy在<code>Nancy.Conventions.BuiltInAcceptHeaderCoercions class</code>中提供了如下约定，其中加*的表示是默认默认被转换的：</p>
<ul>
<li><code>BoostHtml</code>(*) - 如果text/html的优先级低于其他内容类型，则提高优先级；</li>
<li><code>CoerceBlankAcceptHeader</code>(*) - 如果没有指定请求头，就分配一个默认的；</li>
<li><code>CoerceStupidBrowsers</code> - 对于老浏览器，替换请求头，即使它们说是请求xml还是返回html。</li>
</ul>
<p>更改哪一个强制起作用时在bootstrapper中的<code>ConfigureConventions</code>来设置的：</p>
<div class="highlight"><pre><span></span>public class Bootstrapper : DefaultNancyBootstrapper
{
    protected override void ConfigureConventions(NancyConventions nancyConventions)
    {
        base.ConfigureConventions(nancyConventions);

        this.Conventions.AcceptHeaderCoercionConventions.Add((acceptHeaders, ctx) =&gt; {

            // Modify the acceptHeaders by adding, removing or updating the current
            // values.

            return acceptHeaders;
        });
    }
}
</pre></div>
<p>当然你也可以继承你自己的bootstrapper。</p>
<h3 id="5-iconventions">5. 使用IConventions来定义自己的约定</h3>
<p>可以通过实现<code>IConventions</code>接口来创造一个类，并在它的<code>Initialise</code>方法中添加自己的约定到传递进来的参数的<code>AcceptHeaderCoercionConventions</code>属性中。</p>
<p>在所有的接口被传递给bootstrapper的<code>ConfigureConventions</code>的方法之前，Nancy会定位所有的接口实现，并且激发这些约定。</p>
<h3 id="6_1">6. 自动协商头</h3>
<p>Nancy会自动添加链接和各种各样的头到协商响应中。链接头链接。连接头会连接到根据文件扩展来的其他代表中。</p>
<h3 id="7_1">7. 更多信息</h3>
<ul>
<li><a href="http://www.philliphaydon.com/2012/11/nancy-and-content-negotiation/">Nancy and Content Negotiation</a></li>
<li><a href="http://www.philliphaydon.com/2013/04/nancyfx-revisiting-content-negotiation-and-apis-part-1/">Revisting Content Negotiation and APIs part 1</a></li>
<li><a href="http://www.philliphaydon.com/2013/05/nancyfx-revisiting-content-negotiation-and-apis-part-2/">Revisting Content Negotiation and APIs part 2</a></li>
<li><a href="http://www.philliphaydon.com/2013/05/nancyfx-revisiting-content-negotiation-and-apis-part-3/">Revisting Content Negotiation and APIs part 3</a></li>
</ul>
<h2 id="_17">二十四、使用转换器来扩展序列化</h2>
<h2 id="_18">二十五、授权</h2>
<p>Nancy中的验证使用扩展点：比如应用管道、模块管道、<code>NancyContext</code>和其他的一些扩展方法。所以你可以写自己的验证来替换默认提供的验证。</p>
<p>Nancy提供了以下几种验证，通过Nuget安装：</p>
<ul>
<li>表单(<code>Nancy.Authentication.Forms</code>)</li>
<li>基本(<code>Nancy.Authentication.Basic</code>)</li>
<li>无状态(<code>Nancy.Authentication.Stateless</code>)</li>
</ul>
<h3 id="1_9">1. 了解用户</h3>
<p>Nancy中用户使用<code>IUserIdentity</code>接口代表，它提供了一些用户的基本信息：</p>
<div class="highlight"><pre><span></span>public interface IUserIdentity
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets or sets the name of the current user.
    /// <span class="nt">&lt;/summary&gt;</span>
    string UserName { get; set; }

    /// <span class="nt">&lt;summary&gt;</span>
    /// Gets or set the claims of the current user.
    /// <span class="nt">&lt;/summary&gt;</span>
    IEnumerable<span class="nt">&lt;string&gt;</span> Claims { get; set; } 
}
</pre></div>
<p>你应当提供基于自己应用需求的类来实现自己的用户接口。</p>
<p>要获得当前用户，只需要获取<code>NancyContext</code>的<code>CurrentUser</code>属性。返回<code>null</code>值表明当前请求未认证，其他的则表示已认证。</p>
<p>context在Nancy的大部分地方都能获取，所以不必担心能否获取当前请求的用户身份。</p>
<h3 id="2_11">2. 保护你的资源</h3>
<p>可以在模块级和应用级来保护资源，方法是检测<code>NancyContext.CurrentUser</code>属性不为null。</p>
<p>这个任务可以通过在<a href="https://github.com/NancyFx/Nancy/wiki/The%20before%20and%20after%20module%20hooks">模块管道</a>的<code>Before</code>中实现。这个钩子允许我们终结当前请求的执行，返回其它资源，比如当未验证用户视图访问安全资源时：</p>
<div class="highlight"><pre><span></span>public class SecureModule : NancyModule
{
    public SecureModule()
    {
        Before += ctx =&gt; {
            return (this.Context.CurrentUser == null) ? new HtmlResponse(HttpStatusCode.Unauthorized) : null;
        };

        // Your routes here
    }
}
</pre></div>
<p>在每个模块上添加安全代码违反了DRY原则，更是一个无聊的任务。使用扩展方法！</p>
<p>Nancy有一些扩展方法包装了这些任务，彻底的减少了要写的代码量。</p>
<p>下面是一些可用的扩展方法：</p>
<ul>
<li><code>RequiresAuthentication</code> - 确保验证用户是可用的，或者返回<code>HttpStatusCode.Unauthorized</code>. 对于认证的用户，<code>CurrentUser</code>不能为<code>null</code>，而且<code>UserName</code>不能为空；</li>
<li><code>RequiresClaims</code> - 用户必须满足声明列表中所有的条件才能获取资源；</li>
<li><code>RequiresAnyClaim</code> - 见上一条，但是只需满足任意一条；</li>
<li><code>RequiresValidatedClaims</code> - 通过自定义函数，来全部自我掌控验证流程，函数格式<code>Func&lt;IEnumerable&lt;string&gt;, bool&gt;</code>；</li>
<li><code>RequiresHttps</code> - 只允许https访问；</li>
</ul>
<p>这些都是<code>NancyModule</code>类的扩展方法，要使用它们需要添加<code>Nancy.Security</code>命名空间。</p>
<p>使用扩展方法，前面的例子可以这样写：</p>
<div class="highlight"><pre><span></span>public class SecureModule : NancyModule
{
    public SecureModule()
    {
        this.RequiresAuthentication();
    }

    // Your routes here
}
</pre></div>
<p>当然还可以这样写：</p>
<div class="highlight"><pre><span></span>public class SecureModule : NancyModule
{
    public SecureModule()
    {
        this.RequiresHttps();
        this.RequiresAuthentication();
        this.RequiresClaims(new [] { "Admin" });
    }

    // Your routes here
}
</pre></div>
<p>用户必须通过https，被授权，而且拥有Admin claim才能访问上面的路由。</p>
<h3 id="3_8">3. 创造你自己的安全扩展</h3>
<p>为了创造自己的安全扩展，你只需要添加扩展方法到<code>NancyModule</code>，并且绑定到<code>Before</code>管道，并检查证书。</p>
<p>比如，下面说明了<code>RequiresAuthentication</code>如何工作的：</p>
<div class="highlight"><pre><span></span>public static class ModuleSecurity
{
    public static void RequiresAuthentication(this NancyModule module)
    {
        module.Before.AddItemToEndOfPipeline(RequiresAuthentication);
    }

    private static Response RequiresAuthentication(NancyContext context)
    {
        Response response = null;
        if ((context.CurrentUser == null) ||
            String.IsNullOrWhiteSpace(context.CurrentUser.UserName))
        {
            response = new Response { StatusCode = HttpStatusCode.Unauthorized };
        }

        return response;
    }

}
</pre></div>
<h3 id="4-provider">4. 实现自己的验证provider</h3>
<p>实际的验证provider实现根据不同的需求变化很大，但是基本模式如下：</p>
<ol>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20Application%20Before,%20After%20and%20OnError%20pipelines">应用管道</a>的<code>Before</code>钩子用来检查请求的证书（比如cookie, headers等等）。如果发现证书，则验证用户并授权给<code>NancyContext</code>的<code>CurrentUser</code>属性。</li>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20before%20and%20after%20module%20hooks">模块管道</a>的<code>Before</code>钩子用来确认当前的请求是被认证的用户执行，如果不是，则拒绝并返回<code>HttpStatusCode.Unauthorized</code></li>
<li><a href="https://github.com/NancyFx/Nancy/wiki/The%20Application%20Before,%20After%20and%20OnError%20pipelines">应用管道</a>的<code>After</code>钩子用来检查请求是否因为认证失败而被丢弃，比如检查<code>HttpStatusCode.Unauthorized</code>(401)状态码。如果检测到了就帮助用户去认证，比如重定向到login表单或者使用header的帮助通知客户端。</li>
</ol>
<h3 id="5_2">5. 无状态认证</h3>
<p>无状态认证就是在每个请求中进行检查，根据请求的一些信息，来决定是否应该被确认为一个已认证的请求。</p>
<p>比如你检查请求来确认查询字符串的参数是否传递了api key，或者是否包含某些head， 有或者请求是否来自某些特定的ip。</p>
<p>使用无状态认证需要做下面几件事：
1. 安装<code>Nancy.Authentication.Stateless</code>包
2. 配置并开启无状态认证
3. <a href="https://github.com/NancyFx/Nancy/wiki/Authentication-overview">保护资源</a></p>
<h4 id="51">5.1 配置并开启无状态认证</h4>
<p>在bootstrapper中添加：</p>
<div class="highlight"><pre><span></span>StatelessAuthentication.Enable(pipelines, statelessAuthConfiguration);
</pre></div>
<p>被传递到<code>StatelessAuthentication.Enable</code>方法中的<code>statelessAuthConfiguration</code>变量，是一个<code>StatelessAuthenticationConfiguration</code>类型的实例，它能够让你自定义无状态认证提供者的行为。</p>
<p>定义<code>StatelessAuthenticationConfiguration</code>类型实例的时候，需要有一个<code>Func&lt;NancyContext, IUserIdentity&gt;</code>类型的参数。这个函数用来检查请求或者context中的其他相关内容，并且在请求未通过验证时返回<code>null</code>，否则返回合适的<a href="https://github.com/NancyFx/Nancy/wiki/Authentication-overview"><code>IUserIdentity</code></a>.</p>
<h4 id="52">5.2 简单配置</h4>
<div class="highlight"><pre><span></span>var configuration =
    new StatelessAuthenticationConfiguration(ctx =&gt;
    {
        if (!ctx.Request.Query.apikey.HasValue)
        {
            return null;
        }

        // This would where you authenticated the request. IUserApiMapper is
        // not a Nancy type.
        var userValidator = 
            container.Resolve&lt;IUserApiMapper&gt;();

        return userValidator.GetUserFromAccessToken(ctx.Request.Query.apikey);
    });
</pre></div>
<h3 id="6-form">6. Form认证</h3>
<p>详细例子见Nancy解决方案中<code>Nancy.Demo.Authentication.Forms</code>例子</p>
<p>为了开启form认证，需要完成：</p>
<ol>
<li>安装<code>Nancy.Authentication.Forms</code>包</li>
<li>实现<code>IUserMapper</code></li>
<li>实现路由来处理login和logout</li>
<li>配置并开启Form认证</li>
</ol>
<h4 id="61-user-mapper">6.1 User mapper</h4>
<p>User mapper用来负责从标示符identifier映射到用户。标示符是一个令牌，被存储在认证cookie中，用来代表执行请求的用户身份，避免每次请求时输入证书。</p>
<p>使用GUID来做标示符，如果用username来做标示符容易被嗅探并攻击。GUID还很难读取，而且每个GUID都不一样，增加了嗅探的难度。</p>
<p>注意，需要知道标示符对每个用户来说都是永久的并且是唯一的。</p>
<p><code>IUserMapper</code>接口的定义：</p>
<div class="highlight"><pre><span></span>public interface IUserMapper
{
    /// <span class="nt">&lt;summary&gt;</span>
    /// Get the real username from an identifier
    /// <span class="nt">&lt;/summary&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"identifier"</span><span class="nt">&gt;</span>User identifier<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;param</span> <span class="na">name=</span><span class="s">"context"</span><span class="nt">&gt;</span>The current NancyFx context<span class="nt">&lt;/param&gt;</span>
    /// <span class="nt">&lt;returns&gt;</span>Matching populated IUserIdentity object, or empty<span class="nt">&lt;/returns&gt;</span>
    IUserIdentity GetUserFromIdentifier(Guid identifier, NancyContext context);
}
</pre></div>
<h4 id="62-form">6.2 修改应用，处理form认证</h4>
<p>有了<code>IUserMapper</code>后，下一步就是在不需要认证的地方添加login和logout了。</p>
<p>下面是一个模块的基础框架。请注意资源的路径和模块的名称可以使任意的：</p>
<div class="highlight"><pre><span></span>public class LoginModule : NancyModule
{
    public LoginModule()
    {
        Get["/login"] = parameters =&gt; {
            // Called when the user visits the login page or is redirected here because
            // an attempt was made to access a restricted resource. It should return
            // the view that contains the login form
        };

        Get["/logout"] = parameters =&gt; {
            // Called when the user clicks the sign out button in the application. Should
            // perform one of the Logout actions (see below)
        };

        Post["/login"] = parameters =&gt; {
            // Called when the user submits the contents of the login form. Should
            // validate the user based on the posted form data, and perform one of the
            // Login actions (see below)
        };
    }
}
</pre></div>
<p><code>Nancy.Authentication.Forms</code>命名空间中有一些扩展方法可供使用：</p>
<ul>
<li><code>LoginAndRedirect</code> - 登录用户并重定向用户到他们来时的url。或者也可以提供一个预留的url，用来在没有重定向url时使用。如果使用form提交，注意使用action=""，因为它会保留returnUrl原封不动。</li>
<li><code>LoginWithoutRedirect</code> - 登录用户，并且返回响应和状态码200(ok)</li>
<li><code>Login</code>会调用当前请求的<code>IsAjaxRequest</code>的扩展方法，并且如果不是Ajax调用，则执行<code>LoginAndRedirect</code>方法，否则执行<code>LoginWithoutRedirect</code>方法</li>
<li><code>LogoutAndRedirect</code> - 登出用户，并提供重定向</li>
<li><code>LogoutWithoutRedirect</code> - 登出用户并返回状态码为200(OK)的响应</li>
<li><code>Logout</code>会调用当前请求的<code>IsAjaxRequest</code>方法，如果不是ajax请求，则执行<code>LogoutAndRedirect</code>，否则执行<code>LogoutWithoutRedirect</code></li>
</ul>
<p><strong>注意1：</strong> <code>Nancy.Extensions.RequestExtensions</code>中的<code>IsAjaxRequest</code>扩展方法会检查<code>X-Requested-With</code>头，并且在其包含值<code>XMLHttpRequest</code>时返回true</p>
<p><strong>注意2：</strong> 请确认路径的定义login和logout的页面没有要求使用登录。</p>
<h4 id="63-form">6.3 启用form认证</h4>
<p>在bootstrapper中添加：</p>
<div class="highlight"><pre><span></span>FormsAuthentication.Enable(pipelines, formsAuthConfiguration);
</pre></div>
<p>既可以在<code>ApplicationStartup</code>中又可以在<code>RequestStartup</code>中添加。到底在何处加，取决于<code>IUserMapper</code>，即user mapper到底是有应用级的生命周期还是请求级的生命周期。</p>
<p>传递给<code>FormsAuthentication.Enable</code>方法的<code>formsAuthConfiguration</code>变量是<code>FormsAuthenticationConfiguration</code>类型，它能让你自定义form认证提供者的行为。</p>
<p>比如，下面是一个基本的认证配置：</p>
<div class="highlight"><pre><span></span>var formsAuthConfiguration =
new FormsAuthenticationConfiguration()
{
    RedirectUrl = "~/login",
    UserMapper = container.Resolve&lt;IUserMapper&gt;(),
};
</pre></div>
<p>下面是一些配置项：</p>
<ul>
<li><code>RedirectingQuerystringKey</code>：默认名是<code>returnUrl</code></li>
<li><code>RedirectingUrl</code>：未认证的用户应当被重定向的url，一般是登录页面<code>~/login</code></li>
<li><code>UserMapper</code>: <code>IUserMapper</code>在认证时应该被使用</li>
<li><code>RequiresSSL</code>: SSL</li>
<li><code>DisableRedirect</code>: 遇到未认证时，是否重定向到登陆页</li>
<li><code>CryptographyConfiguration</code>: <code>CryptographyConfiguration.Default</code>与form认证cookie配合使用。<code>CryptographyConfiguration.Default</code>是默认的。</li>
</ul>
<h4 id="64">6.4 关于加密，还有一些话</h4>
<p>默认使用<code>RandomKeyGenerator</code>，这意味着每次程序启动时会产生一个新的秘钥，那么应用重启回到这认证cookie失效，在多台机器负载均衡时也会出现这种问题，别怕，看看<a href="https://github.com/NancyFx/Nancy/wiki/The%20cryptography%20helpers">加密配置</a></p>
<p>下面是一个例子：</p>
<div class="highlight"><pre><span></span>var cryptographyConfiguration = new CryptographyConfiguration(
    new RijndaelEncryptionProvider(new PassphraseKeyGenerator("SuperSecretPass", new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 })),
    new DefaultHmacProvider(new PassphraseKeyGenerator("UberSuperSecure", new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 })));

var config = 
    new FormsAuthenticationConfiguration()
    {
        CryptographyConfiguration = cryptographyConfiguration,
        RedirectUrl = "/login",
        UserMapper = container.Resolve&lt;IUserMapper&gt;(),
    };
</pre></div>
<h4 id="65">6.5 跟多</h4>
<ul>
<li>
<p><a href="http://www.philliphaydon.com/2012/12/forms-authentication-with-nancyfx/">Forms authentication with nancyfx</a></p>
</li>
<li>
<p><a href="http://www.philliphaydon.com/2012/12/configuring-multiple-forms-authentication-sections-with-nancyfx/">Multiple forms authentication sections</a></p>
</li>
</ul>
<h3 id="7_2">7. 令牌认证</h3>
<p>详细例子在Nancy解决方案中的<code>Nancy.Demo.Authentication.Token</code>中。</p>
<h4 id="71-nancy">7.1 认识Nancy的令牌认证</h4>
<p>Nancy令牌认证工程是为了多种客户端(iOS, Android, Angular SPA等等)能与统一后台Nancy应用而创建的。</p>
<h4 id="72">7.2 基本原理</h4>
<p>令牌认证与授权在下面这些需求下应运而生：</p>
<ul>
<li>没有cookie（不适所有的客户端都是浏览器）</li>
<li>避免一旦用户被认证/授权后，从后端数据存储中取回用户和权限信息</li>
<li>允许客户端应用在第一次授权后保存令牌，以便为后续请求使用</li>
<li>通过单向加密算法确保令牌没有被篡改，阻止嗅探冒充令牌攻击</li>
<li>使用有期限的可配置的key来进行令牌生成</li>
<li>使用server端的文件系统来存储私钥，这样即使应用重启也能恢复。注意：可以使用内存存储作为测试。</li>
</ul>
<h4 id="73">7.3 使用</h4>
<h5 id="731-nancy">7.3.1 Nancy配置</h5>
<p>令牌认证可以像form认证那样：</p>
<div class="highlight"><pre><span></span>public class Bootstrapper : DefaultNancyBootstrapper
{
    protected override void RequestStartup(TinyIoCContainer container, IPipelines pipelines, NancyContext context)
    {
        TokenAuthentication.Enable(pipelines, new TokenAuthenticationConfiguration(container.Resolve&lt;ITokenizer&gt;()));
    }
}
</pre></div>
<p>令牌从<code>IUserIdentity</code>和<code>NancyContext</code>中，通过实现<code>ITokenizer</code>接口产生。默认实现是<code>Tokenizer</code>，它提供了一些可配置的方法。默认情况下，它产生一个令牌包含下面部分：</p>
<ul>
<li>用户名</li>
<li>Pipe separated list of user claims</li>
<li>UTC当前时间</li>
<li>客户端的"User-Agent"头（必须）</li>
</ul>
<p>建议配置Tokenizer，使用其他附加能代表用户唯一设备的信息。</p>
<p>下面举例说明了如何初始化用户认证，并且返回生成的令牌给客户端：</p>
<div class="highlight"><pre><span></span>public class AuthModule : NancyModule
{
    public AuthModule(ITokenizer tokenizer)
        : base("/auth")
    {
        Post["/"] = x =&gt;
            {
                var userName = (string)this.Request.Form.UserName;
                var password = (string)this.Request.Form.Password;

                var userIdentity = UserDatabase.ValidateUser(userName, password);

                if (userIdentity == null)
                {
                    return HttpStatusCode.Unauthorized;
                }

                var token = tokenizer.Tokenize(userIdentity, Context);

                return new
                    {
                        Token = token,
                    };
            };

        Get["/validation"] = _ =&gt;
            {
                this.RequiresAuthentication();
                return "Yay! You are authenticated!";
            };

        Get["/admin"] = _ =&gt;
        {
            this.RequiresClaims(new[] { "admin" });
            return "Yay! You are authorized!";
        };
    }
}
</pre></div>
<h5 id="732">7.3.2 客户端配置</h5>
<p>一旦你的客户端接收到了token，那么你必须使用token来设置HTTP头：</p>
<div class="highlight"><pre><span></span><span class="n">Authorization</span><span class="o">:</span> <span class="n">Token</span> <span class="o">{</span><span class="n">your</span><span class="o">-</span><span class="n">token</span><span class="o">-</span><span class="n">goes</span><span class="o">-</span><span class="n">here</span><span class="o">}</span>
</pre></div>
<h4 id="8_1">8. 幕后的工作</h4>
<p>https://github.com/NancyFx/Nancy/commit/9ae0a5494bc335c3d940d730ae5d5f18c1018836</p>
            </div><!-- /.entry-content -->
        
 
            <section>
            <div id="DuoShuoComment" aria-live="polite">
<!-- 多说评论框 start -->
    <div class="ds-thread" data-thread-key="nancy-webkuang-jia.html" data-title="Nancy Web框架" data-url="./nancy-webkuang-jia.html"></div>
<!-- 多说评论框 end -->
<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
<script type="text/javascript">
var duoshuoQuery = {short_name:"liulixiang1988blog"};
    (function() {
        var ds = document.createElement('script');
        ds.type = 'text/javascript';ds.async = true;
        ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
        ds.charset = 'UTF-8';
        (document.getElementsByTagName('head')[0] 
         || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
    </script>
<!-- 多说公共JS代码 end -->
            </div>
            </section> 

        </div><!-- /.eleven.columns -->

<div class="three columns">

<nav class="widget">
  <h4>社交</h4>
  <ul class="blank">
    <li><a href="https://www.zhihu.com/people/liulixiang1988">知乎</a></li>
    <li><a href="http://weibo.com/liulixiang1988">微博</a></li>
  </ul>
</nav>

<h4>分类</h4>
<ul class="blank">
		<li><a href="./category/android.html">Android</a></li>
		<li><a href="./category/database.html">Database</a></li>
		<li><a href="./category/dotnet.html">DotNet</a></li>
		<li><a href="./category/ionic.html">ionic</a></li>
		<li><a href="./category/java.html">Java</a></li>
		<li><a href="./category/python.html">Python</a></li>
		<li><a href="./category/sheng-huo.html">生活</a></li>
		<li><a href="./category/web.html">Web</a></li>
		<li><a href="./category/yi-dong-kai-fa.html">移动开发</a></li>
</ul>


<h4>标签</h4>
	<ul class="blank">
	    <li class="tag-[<pelican.contents.Article object at 0x104ba74e0>, <pelican.contents.Article object at 0x104e094e0>, <pelican.contents.Article object at 0x1046a52e8>, <pelican.contents.Article object at 0x1045d3cc0>, <pelican.contents.Article object at 0x10467a2b0>, <pelican.contents.Article object at 0x104a94cf8>, <pelican.contents.Article object at 0x104abc390>, <pelican.contents.Article object at 0x104ac6710>, <pelican.contents.Article object at 0x104594470>, <pelican.contents.Article object at 0x105104470>, <pelican.contents.Article object at 0x105107ef0>, <pelican.contents.Article object at 0x104a11128>]"><a href="./tag/html.html">HTML</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a94668>]"><a href="./tag/maven.html">Maven</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104aa5e48>]"><a href="./tag/phonegap.html">PhoneGap</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104899898>]"><a href="./tag/jquery.html">jQuery</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046ae128>, <pelican.contents.Article object at 0x10513a2b0>, <pelican.contents.Article object at 0x104e09a90>, <pelican.contents.Article object at 0x105180860>, <pelican.contents.Article object at 0x10517fc88>, <pelican.contents.Article object at 0x104dac0b8>, <pelican.contents.Article object at 0x104adf940>, <pelican.contents.Article object at 0x10482c198>, <pelican.contents.Article object at 0x104676588>, <pelican.contents.Article object at 0x1051047b8>, <pelican.contents.Article object at 0x10463ca58>, <pelican.contents.Article object at 0x1048a7c50>]"><a href="./tag/javascript.html">JavaScript</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048a3780>]"><a href="./tag/nancy.html">Nancy</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104bd6dd8>]"><a href="./tag/androiyue-hou-ji-fen.html">Androi阅后即焚</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104ebcdd8>, <pelican.contents.Article object at 0x10517fa20>, <pelican.contents.Article object at 0x104b87d30>]"><a href="./tag/compass.html">compass</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1051047b8>]"><a href="./tag/requirejs.html">RequireJS</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a81630>, <pelican.contents.Article object at 0x104a815c0>]"><a href="./tag/ionic.html">ionic</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048054a8>, <pelican.contents.Article object at 0x10480ff60>, <pelican.contents.Article object at 0x10483fda0>, <pelican.contents.Article object at 0x104668940>, <pelican.contents.Article object at 0x1046ee048>]"><a href="./tag/dotnet.html">DotNet</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1045c5f98>, <pelican.contents.Article object at 0x104671f28>, <pelican.contents.Article object at 0x104642f98>, <pelican.contents.Article object at 0x10468dbe0>, <pelican.contents.Article object at 0x1045d5048>, <pelican.contents.Article object at 0x10464e128>]"><a href="./tag/angular.html">Angular</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a396a0>, <pelican.contents.Article object at 0x10460ddd8>, <pelican.contents.Article object at 0x104a608d0>, <pelican.contents.Article object at 0x104a60358>, <pelican.contents.Article object at 0x10467add8>, <pelican.contents.Article object at 0x104a9e7f0>, <pelican.contents.Article object at 0x1048b67f0>, <pelican.contents.Article object at 0x10467ab38>, <pelican.contents.Article object at 0x104abc9b0>]"><a href="./tag/jsp.html">JSP</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104aa1c18>, <pelican.contents.Article object at 0x1048a36d8>]"><a href="./tag/xue-xi-bi-ji.html">学习笔记</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046d77b8>]"><a href="./tag/gulp.html">Gulp</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104676588>, <pelican.contents.Article object at 0x1046e19b0>, <pelican.contents.Article object at 0x104ebcdd8>, <pelican.contents.Article object at 0x10517fa20>, <pelican.contents.Article object at 0x104b87d30>]"><a href="./tag/css3.html">CSS3</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x105307470>, <pelican.contents.Article object at 0x1046b8a90>, <pelican.contents.Article object at 0x1046a5fd0>, <pelican.contents.Article object at 0x1046db278>, <pelican.contents.Article object at 0x10531e940>, <pelican.contents.Article object at 0x1045e2b70>]"><a href="./tag/python.html">Python</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104601518>, <pelican.contents.Article object at 0x105180588>, <pelican.contents.Article object at 0x1045f3048>, <pelican.contents.Article object at 0x1046126a0>, <pelican.contents.Article object at 0x104826128>]"><a href="./tag/androibo-ke-yue-du.html">Androi博客阅读</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048a3780>]"><a href="./tag/net.html">.NET</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x103bf6f98>, <pelican.contents.Article object at 0x1045c5da0>, <pelican.contents.Article object at 0x1045f0780>, <pelican.contents.Article object at 0x1051e64a8>, <pelican.contents.Article object at 0x104e31f98>, <pelican.contents.Article object at 0x104bd6dd8>, <pelican.contents.Article object at 0x104601518>, <pelican.contents.Article object at 0x105180588>, <pelican.contents.Article object at 0x1045f3048>, <pelican.contents.Article object at 0x1046126a0>, <pelican.contents.Article object at 0x104826128>, <pelican.contents.Article object at 0x104594358>, <pelican.contents.Article object at 0x1045f32e8>, <pelican.contents.Article object at 0x1045d34e0>, <pelican.contents.Article object at 0x1045d3278>, <pelican.contents.Article object at 0x104590fd0>, <pelican.contents.Article object at 0x10458ff98>]"><a href="./tag/android.html">Android</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048054a8>, <pelican.contents.Article object at 0x10480ff60>, <pelican.contents.Article object at 0x10483fda0>, <pelican.contents.Article object at 0x104668940>, <pelican.contents.Article object at 0x1046ee048>]"><a href="./tag/aspnet-mvc.html">ASP.NET MVC</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1045d0fd0>]"><a href="./tag/mysql.html">MySQL</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a22e48>, <pelican.contents.Article object at 0x104a394a8>]"><a href="./tag/servlet.html">Servlet</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x10482b3c8>, <pelican.contents.Article object at 0x104665f98>]"><a href="./tag/pelican.html">Pelican</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104aa1c18>, <pelican.contents.Article object at 0x1048a36d8>]"><a href="./tag/kotlin.html">Kotlin</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046ae128>, <pelican.contents.Article object at 0x10513a2b0>, <pelican.contents.Article object at 0x104e09a90>, <pelican.contents.Article object at 0x105180860>, <pelican.contents.Article object at 0x104dac0b8>, <pelican.contents.Article object at 0x104adf940>, <pelican.contents.Article object at 0x10482c198>]"><a href="./tag/react.html">React</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1045c5f98>, <pelican.contents.Article object at 0x104671f28>, <pelican.contents.Article object at 0x104642f98>, <pelican.contents.Article object at 0x10468dbe0>, <pelican.contents.Article object at 0x1045d5048>, <pelican.contents.Article object at 0x10464e128>, <pelican.contents.Article object at 0x104a22f28>, <pelican.contents.Article object at 0x104a22e48>, <pelican.contents.Article object at 0x104a394a8>, <pelican.contents.Article object at 0x104a396a0>, <pelican.contents.Article object at 0x10460ddd8>, <pelican.contents.Article object at 0x104a608d0>, <pelican.contents.Article object at 0x104a60358>, <pelican.contents.Article object at 0x10467add8>, <pelican.contents.Article object at 0x104a9e7f0>, <pelican.contents.Article object at 0x1048b67f0>, <pelican.contents.Article object at 0x10467ab38>, <pelican.contents.Article object at 0x104abc9b0>, <pelican.contents.Article object at 0x1048054a8>, <pelican.contents.Article object at 0x10480ff60>, <pelican.contents.Article object at 0x10483fda0>, <pelican.contents.Article object at 0x104668940>, <pelican.contents.Article object at 0x1046ee048>, <pelican.contents.Article object at 0x1048a3780>]"><a href="./tag/web.html">Web</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a1b588>]"><a href="./tag/gradle.html">Gradle</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104805438>]"><a href="./tag/flaskbi-ji.html">Flask笔记</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104eaeac8>, <pelican.contents.Article object at 0x105114c88>, <pelican.contents.Article object at 0x1051044a8>, <pelican.contents.Article object at 0x105118dd8>, <pelican.contents.Article object at 0x104ea2f60>, <pelican.contents.Article object at 0x1048da198>, <pelican.contents.Article object at 0x104e09940>]"><a href="./tag/spring.html">Spring</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046b8a90>]"><a href="./tag/bu-shu.html">部署</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x103bdcf28>, <pelican.contents.Article object at 0x1046e1c18>, <pelican.contents.Article object at 0x104665f98>]"><a href="./tag/life.html">life</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046e91d0>]"><a href="./tag/exmobi.html">Exmobi</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046b8a90>, <pelican.contents.Article object at 0x1046a5fd0>, <pelican.contents.Article object at 0x1046db278>]"><a href="./tag/django.html">Django</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1051047b8>]"><a href="./tag/mo-kuai-hua.html">模块化</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104eaeac8>, <pelican.contents.Article object at 0x105114c88>, <pelican.contents.Article object at 0x1051044a8>, <pelican.contents.Article object at 0x105118dd8>, <pelican.contents.Article object at 0x104ea2f60>, <pelican.contents.Article object at 0x1048da198>, <pelican.contents.Article object at 0x104aa5be0>, <pelican.contents.Article object at 0x10462f668>, <pelican.contents.Article object at 0x104a1b588>, <pelican.contents.Article object at 0x1046fdfd0>, <pelican.contents.Article object at 0x1046eefd0>, <pelican.contents.Article object at 0x104e09940>, <pelican.contents.Article object at 0x104a22f28>, <pelican.contents.Article object at 0x104a22e48>, <pelican.contents.Article object at 0x104a394a8>, <pelican.contents.Article object at 0x104a396a0>, <pelican.contents.Article object at 0x10460ddd8>, <pelican.contents.Article object at 0x104a608d0>, <pelican.contents.Article object at 0x104a60358>, <pelican.contents.Article object at 0x10467add8>, <pelican.contents.Article object at 0x104a9e7f0>, <pelican.contents.Article object at 0x1048b67f0>, <pelican.contents.Article object at 0x10467ab38>, <pelican.contents.Article object at 0x104abc9b0>]"><a href="./tag/java.html">Java</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a42fd0>, <pelican.contents.Article object at 0x104a13048>, <pelican.contents.Article object at 0x104a56f60>, <pelican.contents.Article object at 0x1051925f8>, <pelican.contents.Article object at 0x10461a550>, <pelican.contents.Article object at 0x10461b7b8>, <pelican.contents.Article object at 0x104ba74e0>, <pelican.contents.Article object at 0x104e094e0>, <pelican.contents.Article object at 0x1046a52e8>, <pelican.contents.Article object at 0x1045d3cc0>, <pelican.contents.Article object at 0x10467a2b0>, <pelican.contents.Article object at 0x104a94cf8>, <pelican.contents.Article object at 0x104abc390>, <pelican.contents.Article object at 0x104ac6710>, <pelican.contents.Article object at 0x104594470>, <pelican.contents.Article object at 0x105104470>, <pelican.contents.Article object at 0x105107ef0>, <pelican.contents.Article object at 0x104a11128>, <pelican.contents.Article object at 0x104bdeac8>]"><a href="./tag/css.html">CSS</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104a81630>, <pelican.contents.Article object at 0x104a815c0>]"><a href="./tag/yi-dong-kai-fa.html">移动开发</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048059b0>, <pelican.contents.Article object at 0x104805438>]"><a href="./tag/flask.html">Flask</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1051dd5c0>, <pelican.contents.Article object at 0x1051d2d30>, <pelican.contents.Article object at 0x104ea5da0>]"><a href="./tag/netty.html">Netty</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1048a3780>]"><a href="./tag/c.html">C#</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104ba74e0>, <pelican.contents.Article object at 0x104e094e0>, <pelican.contents.Article object at 0x1046a52e8>, <pelican.contents.Article object at 0x1045d3cc0>, <pelican.contents.Article object at 0x10467a2b0>, <pelican.contents.Article object at 0x104a94cf8>, <pelican.contents.Article object at 0x104abc390>, <pelican.contents.Article object at 0x104ac6710>, <pelican.contents.Article object at 0x104594470>, <pelican.contents.Article object at 0x105104470>, <pelican.contents.Article object at 0x105107ef0>, <pelican.contents.Article object at 0x104bdeac8>]"><a href="./tag/less.html">LESS</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x10468dcf8>, <pelican.contents.Article object at 0x104a92518>, <pelican.contents.Article object at 0x1048570f0>, <pelican.contents.Article object at 0x104aba470>]"><a href="./tag/shu-ju-fen-xi.html">数据分析</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046eefd0>]"><a href="./tag/hibernate.html">Hibernate</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x104ebcdd8>, <pelican.contents.Article object at 0x10517fa20>, <pelican.contents.Article object at 0x104b87d30>, <pelican.contents.Article object at 0x104a42fd0>, <pelican.contents.Article object at 0x104a13048>, <pelican.contents.Article object at 0x104a56f60>, <pelican.contents.Article object at 0x1051925f8>, <pelican.contents.Article object at 0x10461a550>, <pelican.contents.Article object at 0x10461b7b8>]"><a href="./tag/sass.html">sass</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x103c1c240>]"><a href="./tag/android-studio.html">Android Studio</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1045c5da0>, <pelican.contents.Article object at 0x1045f0780>, <pelican.contents.Article object at 0x104bd6dd8>, <pelican.contents.Article object at 0x104601518>, <pelican.contents.Article object at 0x105180588>, <pelican.contents.Article object at 0x1045f3048>, <pelican.contents.Article object at 0x1046126a0>, <pelican.contents.Article object at 0x104826128>, <pelican.contents.Article object at 0x104594358>, <pelican.contents.Article object at 0x1045f32e8>, <pelican.contents.Article object at 0x1045d34e0>, <pelican.contents.Article object at 0x1045d3278>, <pelican.contents.Article object at 0x104590fd0>, <pelican.contents.Article object at 0x10458ff98>]"><a href="./tag/androidxue-xi-bi-ji.html">Android学习笔记</a></li>
	    <li class="tag-[<pelican.contents.Article object at 0x1046fdfd0>]"><a href="./tag/functional-programming.html">Functional Programming</a></li>
</ul>

</div> </div><!-- /.row -->


</section>

       </div><!-- /.row -->
    </div><!-- /.container -->


       <div class="container.nopad bg">

    
        <footer id="credits" class="row">
          <div class="seven columns left-center">

                   <address id="about" class="vcard body">
                    Proudly powered by <a href="http://getpelican.com/">Pelican</a>,
                    which takes great advantage of <a href="http://python.org">Python</a>.
                    <br />
                    Based on the <a target="_blank" href="http://gumbyframework.com">Gumby Framework</a>
                    </address>
          </div>


          <div class="seven columns">
            <div class="row">
              <ul class="socbtns">





              </ul>
            </div>
          </div>
        </footer>

    </div>


  <script src="./theme/js/libs/jquery-1.9.1.min.js"></script>
  <script src="./theme/js/libs/gumby.min.js"></script>
  <script src="./theme/js/plugins.js"></script>
</body>
</html>