{"pages":[{"title":"关于","text":"My Name is Liu Lixiang. I'm a software engineer in iFlytek.","tags":"pages","url":"/pages/guan-yu.html"},{"title":"Netty笔记03-Netty组件和设计","text":"本章包含： Netty的技术与架构 Channel , EventLoop , 和 ChannelFuture ChannelHandler 和 ChannelPipeline Bootstrapping 3.1 Channel, EventLoop和ChannelFuture Channel , EventLoop 和 ChannelFuture 可以看成是Netty对网络的抽象： Channel : Socket EventLoop : 控制流、多线程和并发 ChannelFuture ：异步通知 3.1.1 Channel接口 基本IO操作( bind() , connect() , read() , write() )依赖于底层网络传输。在基于Java的网络中，基础组成是 Socket 类。Netty的 Channel 接口提供了的API能大幅度减少直接操作 Socket 的复杂度。此外， Channel 是所有扩展类的根类。下面是一些继承的类： EmbeddedChannel LocalServerChannel NioDatagramChannel NioSctpChannel NioSocketChannel 3.1.2 EventLoop接口 EventLoop 定义了Netty对连接生命区间事件处理的核心抽象。在后面的章节里我们会讨论 EventLoop 的细节。下图展示了 Channel , EventLoop , Thread 和 EventLoopGroup 之间的关系。 关系是： 一个 EventLoopGroup 包含一个或多个 EventLoop EventLoop 在其生命周期内绑定到单个 Thread 所有的IO事件由 EventLoop 在其专属 Thread 内处理 Channel 注册到一个 EventLoop 内 一个 EventLoop 可以关联多个 Channel 注意，这个实际中，对于给定 Channel 的IO操作都是在同一个线程内执行的，这样可以避免同步问题。 3.1.3 ChannelFuture接口 Netty中所有的操作都是异步的。因为操作不一定能立即返回，因此我们需要一个方法来在后期获取结果。Netty提供了 ChannelFuture ,它的 addListener() 方法注册了 ChannelFutureListener 用来在操作完成后发出通知。 后面我们会深入讨论 EventLoop 和 EventLoopGroup 3.2 Channelhandler和ChannelPipeline 下面我们来详细讨论如何管理数据流和执行应用处理逻辑。 3.2.1 ChannelHandler接口 从开发者角度看，Netty的最基本构建式 ChannelHandler ，它包含着用来处理inbound和outbound数据的逻辑。这是因为 ChannelHandler 方法由网络事件触发。事实上， ChannelHandler 几乎可以用来黑醋栗任何类型的动作，比如数据转换和异常处理。 例如， ChannelInboundHandler 是经常实现的子接口。这个类型接收inbound事件和数据用于处理业务逻辑。也可以从 ChannelInboundHandler 中将数据作为响应flush给客户端。应用的业务逻辑通常分布在多个 ChannelInboundHandler 中。 3.2.2 ChanelPipeline接口 ChannelPipeline 提供了 ChannelHandler 链的容器，并且定义了API用来在链上传递inbound和outbound事件。当有 Channel 创建时，它会自动的赋值给它的 ChannelPipeline 。 ChannelHandler 安装到 ChannelPipeline 的过程： ChannelInitializer 被注册到 ServerBootstrap 调用 ChannelInitializer.initChannel() 时， ChannelInitializer 安装一系列自定义的 ChannelHandler 到pipeline中 ChannelInitializer 将自己从 ChannelPipeline 中删除 ChannelHandler 可以看作是一个通用容器用来处理时间和数据。 ChannelPipeline 中 ChannelHandler 的执行顺序按照他们加入到链中的顺序。 对于客户端来说，outbound是从客户端到服务器的方向，inbound则相反。 上图也说明inbound和outbound可以添加到同一个pipeline中。如果读取到一个消息，它会从pipeline头开始，并且传递给第一个 ChanneiInboundHandler 。这个handler可能修改也可能不修改数据，之后再将数据传递给下一个 ChannelInboundHandler 。最后数据到达pipeline的尾部，所有的处理会被终止。 outbound数据流动先从尾部开始，直到到达到头部，此时，outbound数据到达网络传输，这里是一个 Socket 。 更多关于inbound和outbound handler 时间可以通过每个方法的 ChannelHandlerContext 方法进行向前传递。有时你想忽略一些不感兴趣的事件，Netty提供了抽象基础类 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 。每一个都提供了一个实现，用于将事件传递给下一个handler。我们可以扩展这个类，重写感兴趣的方法。 虽然inbound和outbound handler都继承自 ChannelHandler , Netty还是会区分 ChannelInboundHandler 和 ChannelOutboundHandler ，并且确保数据只在同一类型的handler间传递。 当 ChannelHandler 添加到 ChannelPipeline 中时，它也被传递了一个 ChannelHandlerContext 参数。这个参数代表着 ChannelHandler 和 ChannelPiepline 之间的一个绑定。虽然这个对象可以被用于获取底层的 Channel ，但更多的是用来写outbound数据。 Netty中有两种方法用来发送数据。你可以直接向 Channel 或者与 ChannelHandler 关联的 ChannelHandlerContext 对象中写数据。前者由 ChannelPipeline 的尾部开始消息，后者由 ChannelHandlerPipeline 的下一个handler开始消息。 3.2.3 ChannelHandler Netty以多种adpater类实现的默认handler。常用的adapter有： ChannelHandlerAdapter ChannelInboundHandlerAdapter ChannelOutboundHandlerAdapter ChannelDuplexHandlerAdapter 线面我们来看看 ChannelHandler 子类型：encoder, decoder, SimpleChannelInboundHandler<T> ( ChannelInboundHandlerAdapter 的子类型) 3.2.4 Encode和Decoder 当Netty发送或者接受消息时，数据会发生转换。inbound消息会被decode，也就是会从bytes到其他格式，一般是Java对象。outbound消息会被从当前格式转换到bytes格式，这是encode。这是因为网络数据的传输都是bytes格式。 许多抽象类用来做encoder和decoder. 一般来说，基本类型都会有类似 ByteToMEssageDecoder 或者 MessageToByteEncoder 的名字。 Netty提供的所有的encoder/decoder adapter类都实现了 ChannelInboundHandler 或 ChannelOutboundHandler 。 对于inbound数据， channelRead 方法/事件会被重写。这个方法会会调用 decode 方法，并且将decoded bytes传递给后面的 ChannelInboundHandler 。 outbound消息于此相反。 3.2.5 抽象类SimpleChannelInboundHandler 应用中常用的场景是解析消息，对数据执行逻辑。要创建这样一个 ChannelHandler ，只需要继承 SimpleChannelInboundHandler<T> ，其中 T 是想要处理的消息类型。在这个handler中，重写一个或多个方法，并且获取 ChannelHandlerContext 引用。 在这种类型场景下，最重要的方法是 channelRead0(ChannelHandlerContext, T) 。 3.3 Bootstrapping Netty的bootstrap类提供了为应用网络层配置的容器。包含配置端口、主机地址等。 有两种类型的bootstrap，一种用于客户端( Bootstrap )，一种鱼鱼服务端( ServerBootstrap )。 类别 Bootstrap ServerBootstrap 网络功能 连接远程主机和端口 绑定到本地端口 EventLoopGroup数量 1 2 启动一个客户端只需要一个 EventLoopGroup ，但是 ServerBootStrap 却需要两个。这是因为服务端需要两个不同集合的 Channel ，第一个包含一个单独的 ServerChannel 来代表服务器本身监听的socket。第二个集合代表用于处理客户端请求的 Channel 。 与 ServerChannel 关联的 EventLoopGroup 分配一个 EventLoop 用来负责为连接请求创建 Channel 。一旦接受了连接请求，第二个 EventLoopGroup 分配一个 EventLoop 给 Channel 。 3.4 总结 本章主要讨论了Netty的技术和架构。详细回顾了 ChannelHandler , ChannelPipeline 和bootstrapping. 后续章节会深入讨论这些。","tags":"Java","url":"/nettybi-ji-03-nettyzu-jian-he-she-ji.html"},{"title":"Netty笔记02-第一个Netty应用","text":"本章包含： - 设置开发环境 - 一个Echo服务和客户端 - 构建和测试应用 2.1 设置开发环境 下载安装JDK和MAVEN，设置 JAVA_HOME ，并且设置 M2_HOME 2.2 Netty的客户端和服务器概览 下图是我们的Echo服务器和客户端一览。虽然我们大部分是在写web应用，但实现服务器和客户端有助于更好的理解Netty API. 2.3 编写Echo服务器 所有的Netty Server都需要： - 至少一个 ChannelHandler :这个组建实现了服务端用于处理客户端提交的数据，它是业务逻辑。 - Bootstrapping :用来配置服务的启动代码。最少的启动代码是绑定端口。 2.3.1 ChannelHandler 和业务逻辑 在 上一篇 中，我们介绍了 Future 和回调，并且介绍了他们用于事件驱动设计。我们也讨论了 ChannelHandler ，用于接收和响应事件通知。在Netty应用中，所有的数据处理逻辑都是包含在这个核心概念里面的。 因为Echo服务用于响应进来的消息，它需要实现 interface ChannelInboundHandler ，它定义了用于响应 inbound 事件的方法。这个简单的应用只包含几个方法，所以从 ChannelInboundHandlerAdapter 继承就可以了，它是 ChannelInboundHandler 的一个默认实现。 下面的几个方法对我们很有用： - channelRead() ：每个incoming消息都会调用 - channelReadComplete() : 本批消息中最后一个 channelRead() 被调用时通知 - exceptionCaught() :读操作发生异常时会调用。 Echo服务的 ChannelHandler 实现是 EchoServerHandler ，如下： @ChannelHandler.Sharable public class EchoServerHandler extends ChannelInboundHandlerAdapter { Logger logger = LoggerFactory . getLogger ( EchoServerHandler . class ); @Override public void channelRead ( ChannelHandlerContext ctx , Object msg ) throws Exception { ByteBuf in = ( ByteBuf ) msg ; logger . info ( \"Server received: {}\" , in . toString ( CharsetUtil . UTF_8 )); ctx . write ( in ); } @Override public void channelReadComplete ( ChannelHandlerContext ctx ) throws Exception { //flush pending messages to the remote peer and closes the channel ctx . writeAndFlush ( Unpooled . EMPTY_BUFFER ) . addListener ( ChannelFutureListener . CLOSE ); } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . error ( \"Error: {}, {}\" , cause . getMessage (), cause . getStackTrace ()); //关闭channel ctx . close (); } } ChannelInboundHandlerAdapter 有很只管的API，每个方法都可以被重写。因为你要接受数据，因此需要重写 channelRead() 。 重写 exceptionCaought() 允许你对任何 Throwable 子类型做出响应。 每个 Channel 都有一个 ChannelPipeline 关联，后者有一个 ChannelHandler 实例链。他们一个挨一个的调用。因此如果没有 exceptionCaught() 实现，就回一直传递到 ChannelPipeline 结束，并且被日志记录。因此，在应用中至少有一个 ChannelHandler 提供 exceptionCaught() 。 除了 ChannelInboundHandlerAdapter 之外，还有很多其他 ChannelHandler 子类型。现在只需要知道： - ChannelHandler 被不同事件类型调用 - 应用实现或扩展 ChannelHandler 以便在时间不同生命周期挂载并且提供自定义应用逻辑 - 架构上， ChannelHandler 帮助我们将业务逻辑从网络代码中解耦。 2.3.2 Bootstrapping服务 在实现了业务逻辑 EchoServerHandler 之后，现在要启动服务，这包含： 绑定端口用来监听请求 配置 Channel 用来将 inbound 消息到通知 EchoServerHandler 实例 传输 传输层是用来提供端到端的通信服务。Internet通信是基于TCP传输的。 NIO 传输 几乎与TCP等同，只是它使用Java NIO对服务端性能进行了增强。 下面是 EchoServer 类的代码 public class EchoServer { private static final Logger logger = LoggerFactory . getLogger ( EchoServer . class ); public final int port ; public EchoServer ( int port ){ this . port = port ; } public static void main ( String [] args ) throws Exception { if ( args . length != 1 ) { logger . error ( \"Usage: {} <port>\" , EchoServer . class . getSimpleName ()); return ; } int port = Integer . parseInt ( args [ 0 ]); new EchoServer ( port ). start (); } public void start () throws Exception { final EchoServerHandler serverHandler = new EchoServerHandler (); //1. 创建事件循环组 EventLoopGroup group = new NioEventLoopGroup (); try { //2. 创建ServerBootstrap ServerBootstrap b = new ServerBootstrap (); b . group ( group ) //3. 指定使用NIO传输Channel . channel ( NioServerSocketChannel . class ) //4.指定socket端口 . localAddress ( new InetSocketAddress ( port )) //5. 添加EchoServerHandler到ChannelPipeline . childHandler ( new ChannelInitializer < SocketChannel >() { @Override protected void initChannel ( SocketChannel socketChannel ) throws Exception { //因为EchoServerHandler是@Sharable的,所以我们一直可以使用同一个 socketChannel . pipeline (). addLast ( serverHandler ); } }); //6. 异步绑定,使用sync()等待绑定完成 ChannelFuture f = b . bind (). sync (); //7. 获取Chaneel的CloseFuture,阻塞当前线程,知道其完成 f . channel (). closeFuture (). sync (); } finally { //8. 关闭EventLoopGroup,释放所有资源 group . shutdownGracefully (). sync (); } } } @2中创建了 ServerBootstrap 实例。因为使用的是NIO传输，所以指定 NioEventLoopGroup @1来接受和处理新的连接，并且使用 NioServerSocketChannel @3作为channel类型。之后，设置本地地址和端口给 InnetSocketAddress @4. 服务会丙丁到这个地址监听新的连接请求。 在@5中，创建了一个特殊的类 ChannelInitializer ，这是关键。当接收一个新连接时，一个新的 Channel 子类型会被创建， ChannelInitializer 会添加一个 DchoServerHandler 的实例到 Channel 的 ChannelPipeline 中。 虽然NIO可扩展，但对它的恰当配置，尤其是多线程配置，却不容易。Netty封装了这些复杂性。 然后我们绑定服务@6， 登台绑定完成（ sync() 调用一起当前 Thread 阻塞直到完成）。在@7中，应用汇等待，直到服务的 Channel 关闭（因为调用了 Channel 的 CloseFuture 的 sync() ）。然后可以关闭 EventLoopGroup 并且释放资源（包括所创建的线程）@8 这里使用NIO时因为它是目前应用最广泛的传输，得益于它的扩展性和异步性。但是也可以使用别的传输实现。如果你想在服务端使用OIO传输，那就指定 OioServerSocketChannel 和 OioEventLoopGroup 。 同时，我们回顾一下服务端实现的重要步骤。下面的是服务端的基础代码。 EchoServerHandler 实现业务逻辑 main() 方法启动服务 启动服务的步骤： 创建 ServerBootstrap 实例 创建 NioEventLoopGroup 实例用来处理事件，比如接收新连接，并且读写数据 指定本地 InetSocketAddress 用来做服务绑定 为每一个 Channel 使用 EchoServerHandler 实例初始化 调用 ServerBootstrap.bind() 绑定到服务。 至此，服务被初始化并且处于可用状态了。下一节我们实现客户端应用。 2.4 实现Echo客户端 Echo客户端将： 连接服务 发送一个或多个消息 对于每个消息，等待并接受服务器返回 关闭连接 服务端同样需要两步：业务逻辑和bootstrap 2.4.1 使用 ChannelHandler 实现客户端逻辑 客户端也使用 ChannelInboundHandler 来处理数据。这个例子中，我们扩展类 SimpleChannelInboundHandler 来处理所有的任务。这需要重写以下的方法： channelActive() ：与服务的链接建立后调用 channelRead0() : 从服务端读取到消息后调用 exceptionCaught() : 如果发生异常时调用 @ChannelHandler.Sharable public class EchoClientHandler extends SimpleChannelInboundHandler < ByteBuf > { private static final Logger logger = LoggerFactory . getLogger ( EchoClientHandler . class ); @Override public void channelActive ( ChannelHandlerContext ctx ) throws Exception { //当链接建立时调用,发送消息 ctx . writeAndFlush ( Unpooled . copiedBuffer ( \"Netty rocks!\" , CharsetUtil . UTF_8 )); } protected void channelRead0 ( ChannelHandlerContext ctx , ByteBuf msg ) throws Exception { //记录收到的消息 logger . info ( \"Client received: {}\" , msg . toString ( CharsetUtil . UTF_8 )); } @Override public void exceptionCaught ( ChannelHandlerContext ctx , Throwable cause ) throws Exception { logger . error ( \"Error: {}, {}\" , cause . getMessage (), cause . getStackTrace ()); ctx . close (); } } 当有数据从服务端返回时调用 channelRead0() 。注意服务端返回的数据可能是分块的。也就是说，如果服务器返回5个字节，并不能保证5各字节一次性杯接收。及时如此小的数据， channelRead0() 也有可能被调用两次，第一次用 ByteBuf （Netty的 byte 容器）保存3个字节，第二个用 ByteBuf 保存2个字节。作为一个流协议，TCP保证每个字节按顺序接收。 SimpleChannelInboundHandler vs ChannelInboundHandler 在客户端，当 channelRead0() 完成，你就有了incoming消息。当方法返回时， SimpleChannelInboundHandler 负责释放 ByteBuf 的内存。 在服务端，你也要响应incoming消息，然后使用 write() （它是异步的），但当 channelRead() 返回时操作还可能没完成。因此， EchoServerHandler 继承 ChannelInboundHandlerAdapter ，它不负责释放消息。消息由 EchoServerHandler 的 channelReadComplet() 中 writeAndFlush() 释放。 2.4.2 启动客户端 public class EchoClient { private static final Logger logger = LoggerFactory . getLogger ( EchoClient . class ); private final String host ; private final int port ; public EchoClient ( String host , int port ) { this . host = host ; this . port = port ; } public void start () throws Exception { EventLoopGroup group = new NioEventLoopGroup (); try { Bootstrap b = new Bootstrap (); b . group ( group ) . channel ( NioSocketChannel . class ) . remoteAddress ( new InetSocketAddress ( host , port )) . handler ( new ChannelInitializer < SocketChannel >() { protected void initChannel ( SocketChannel ch ) throws Exception { ch . pipeline (). addLast ( new EchoClientHandler ()); } }); ChannelFuture f = b . connect (). sync (); f . channel (). closeFuture (). sync (); } finally { group . shutdownGracefully (). sync (); } } public static void main ( String [] args ) throws Exception { if ( args . length != 2 ) { logger . error ( \"Usage: {} <host> <port>\" , EchoClient . class . getSimpleName ()); return ; } String host = args [ 0 ]; int port = Integer . parseInt ( args [ 1 ]); new EchoClient ( host , port ). start (); } } 2.5 启动运行Server/Client 2.5.1 构建 mvn clean package 2.5.2 运行Echo Server和Client 你可以直接使用Java命令行直接运行，也可以在pom中使用 exec-maven-plugin 插件来配置。 打开两个窗口，分别切换到server和client对应的目录，然后运行: mvn exec:java 源码：https://github.com/liulixiang1988/javademo/tree/master/netty/EchoNetty","tags":"Java","url":"/nettybi-ji-02-di-yi-ge-nettyying-yong.html"},{"title":"Netty笔记01-Netty简介","text":"Netty(http://netty.io )是一个用来快速开发可维护高性能服务器和客户端应用的异步事件驱动网络应用框架。 高性能系统不仅需要我们有优秀的编码技巧，还需要对网络、多线程与并发有相关的经验。 1.1 Java网络 早期版本Java的 java.net 支持本地系统的socket库提供的阻塞函数。 accept() 一直阻塞直到 ServerSocket 简历了链接，它返回一个 Socket 对象用来在客户端和服务器之间进行通信。 BufferedRead 用来从 Socket 中读取文本； PrintWriter 用来写入。 readLine 阻塞直到发送了回车换行 上面的代码每次只能处理一个链接。要管理多个并发的客户端，需要为每一个新的 Socket 来分配一个 Thread ,如图： 我们来思考一下这个方法： - 首先，很多时间线程处于等待状态，这是一种资源的浪费； - 每个线程需要在内存上分配64k到1M的空间； - 即使JVM支持大量的线程，但上下文之间的切换耗时。 1.1.1 Java NIO setsockopt() 能够配置 sockets ，如果没有数据就立即返回。Java从1.4版开始支持 java.nio 。 1.1.2 Selector（选择器） 下图展示了一个非阻塞的设计用来避免前面讲的缺点。 类 java.nio.channels.Selector 是Java非阻塞IO实现的关键。它使用事件通知API来指导 socket 集合。因为可以随时检查每个 socket 的读写完成状态，所以单个线程可以处理多并发连接。 总而言之，这种模型提供了一个比阻塞IO模型更好的资源管理： - 使用更少的线程来处理多链接，内存和上下文切换开销都更小； - 当一个线程没有IO操作时可以被重新分配到其他任务上去。 虽然很多应用都直接使用Java NIO API来创建，但要做到正确和安全还是很难。尤其是重负载的情况下处理和分发IO会很麻烦而且容易出错。这就有了高性能网络专家-Netty。 1.2 Netty核心组建 Channels 回调 Futures 事件和handler 这些构建块代表了不同的构造类型：资源、逻辑和通知。 1.2.1 Channel Channel 是Java NIO的基本构造。 an open connection to an entity such as a hardware device, a file, a network socket, or a program component that is capable of performing one or more distinct I/O operations, for example reading or writing 可以认为 Channel 是一个用来传输数据的通道，可以被打开、关闭、链接的和断开的 1.2.2 回调 Netty使用回调来处理事件。一个回调被触发后，时间可以使用 interface ChannelHandler 的实现来处理。下面的例子是党新链接简历时 ChannelHandler 的回调 channelActive 就会被调用并且打印一个消息。 1.2.3 Futures Future 提供了另外一种方法用来在操作完成时通知应用。可以把它看成是异步操作返回结果的占位符，只有在将来的某个点完成并且提供结果的存取。 JDK提供了 interface java.util.concurrent.Future ，但提供的实现只允许手工检查操作是否完成或者一直阻塞到完成为止。这种实现很笨拙，Netty提供了自己的实现 ChannelFuture 。 ChannelFuture 提供了附加的方法，让我们注册一个或多个 ChannelFutureListener 实例。listener(监听器)的回调方法 operationComplete() 在操作完成后背调用。监听器此时可以决定操作是否完成还是有错误。如果是后者，我们能获得一个产生的 Throwable 。简而言之，通知机制通过 ChannelFutureListener 避免了对操作是否完成的手工检查。 Netty的所有outbound IO操作都返回 ChannelFuture ，也就是所都是非阻塞的。 下面展示了 ChannelFuture 作为IO操作的一部分被返回，这里 connect() 用来直接非阻塞返回，并且将在后台完成。 下面展示了如何利用 ChannelFutureListener .首先你链接到远程节点(remote peer)。然后对 ChannelFuture （由 connect() 返回的）注册一个新的 ChannelFutureListener 。如果操作成功，就向 Channel 写数据，否则，会从 ChannelFuture 收到 Throwable 。 如何进行错误的处理完全由你自己定，比如失败时去连接另一个同级节点。 回调和 Future 是整个Netty的核心。 1.2.4 事件和handler Netty使用不同的时间用来通知状态和操作的变化。它允许我们根据不同的事件触发不同的操作。这些动作包括： Logging日志 Data transformation 数据转换 流程控制Flow-control 应用逻辑Application logic Netty是一个网络框架，因此它的事件被氛围inbound和outbound相关的数据流。 被inbound数据或相关状态触发的事件有： - Active或inactive connections - 读数据(Data read) - 用户事件(User events) - 错误事件(Error events) outbound事件是将来要触发动作的操作结果，可能是： - 打开或关闭远程peer - 写或flush数据到socket 时间能够被分发到用户实现的handler类中的方法去。 Netty的 ChannelHandler 提供上图中一些基本的抽象。目前为止，可以把每个handler实例看作是响应里用来处理具体事件的。 1.2.5 合在一起 我们讨论了 Future ,回调和 handler 。Netty的异步编程模型建立在 Future 和回调的概念之上的。有了这个之后，我们的应用逻辑可以避免关心这些网络操作概念。这是Netty的设计目标。 截取操作和转换inbound和outbound数据只需要我们提供回调或者利用返回的 Future 。这使得链式操作简单和搞笑，并且提倡书写可重用、泛型代码。 Selectors ， Events 和 Event loops Netty从应用中通过触发事件、消除所有硬编码分发代码来抽象 Selector 。在内部， EventLoop 用来复制给每个 Channel 用来处理所有事件，包括： - 注册感兴趣的事件 - 分发事件到 ChannelHandlers - 调度将来的动作 EventLoop 自身是由单个线程来驱动的，并且在整个生命周期中都不会改变。","tags":"Java","url":"/nettybi-ji-01-nettyjian-jie.html"},{"title":"Java8中的并行流","text":"此笔记是我在阅读《Java8实战》中的一些记录。 Java8中增加了流(stream)的概念，为数据的处理带来了很大的方便。 并行流将数据分割成不同的块，并且用不同的线程处理不同的块。 现在要根据输入 n ，求从1到n的和，这里我们不使用 n*(1+n)/2 的方式，而是使用累加。我们分别写出迭代、顺序流、并行流的写法。 public class ParallelStreams { public static long sequentialSum ( long n ) { return Stream . iterate ( 1L , i -> i + 1 ) . limit ( n ) . reduce ( 0 L , Long :: sum ); } public static long iterativeSum ( long n ) { long result = 0 ; for ( long i = 1L ; i <= n ; i ++) { result += i ; } return result ; } public static long parallelSum ( long n ) { return Stream . iterate ( 1L , i -> i + 1 ) . limit ( n ) . parallel () . reduce ( 0 L , Long :: sum ); } } 我们可以看到，将顺序流转换为并行流只需要 parallel() 方法即可。 现在我们来测量这几个方法的性能： public static long measureSumPerf ( Function < Long , Long > adder , long n ) { long fastest = Long . MAX_VALUE ; for ( int i = 0 ; i < 10 ; i ++) { long start = System . nanoTime (); long sum = adder . apply ( n ); long duration = ( System . nanoTime () - start ) / 1_000_000 ; //毫秒 System . out . println ( \"Result: \" + sum ); if ( duration < fastest ) fastest = duration ; } return fastest ; } 然后分别测试这三个方法: public static void main ( String [] args ) { System . out . println ( \"顺序流:\" + measureSumPerf ( ParallelStreams :: sequentialSum , 10_000_000 )+ \" 毫秒\" ); System . out . println ( \"循环:\" + measureSumPerf ( ParallelStreams :: iterativeSum , 10_000_000 )+ \" 毫秒\" ); System . out . println ( \"并行流:\" + measureSumPerf ( ParallelStreams :: parallelSum , 10_000_000 )+ \" 毫秒\" ); } 结果出乎我们的预料： 顺序流 : 173 毫秒 循环 : 4 毫秒 并行流 : 697 毫秒 为什么会这样？ - iterate 生成的是 Stream<Long> 对象，需要拆箱才能求和； - iterate 很难分割成独立的小块，因为每次应用这个函数都需要前一次应用的结果，也就是说它其实是顺序执行的。这样反而在并行时增加了分配线程的开销。 这里我们使用 LongStream.rangeClosed 方法来优化，它的特点有： - LongStream.rangeClosed 直接产生原始类型的 long 数字，没有拆箱与装箱的开销。 - LongStream.rangeClosed 产生一个数字范围，很容易拆分成多个小块。 我们再用 LongStream.rangeClosed 写出顺序和并行计算的版本： public static long parallelRangedSum ( long n ) { return LongStream . rangeClosed ( 1 , n ) . parallel () . reduce ( 0 , Long :: sum ); } public static long measureSumPerf ( Function < Long , Long > adder , long n ) { long fastest = Long . MAX_VALUE ; for ( int i = 0 ; i < 10 ; i ++) { long start = System . nanoTime (); long sum = adder . apply ( n ); long duration = ( System . nanoTime () - start ) / 1_000_000 ; //秒 System . out . println ( \"Result: \" + sum ); if ( duration < fastest ) fastest = duration ; } return fastest ; } 然后进行测试： System . out . println ( \"顺序Range流:\" + measureSumPerf ( ParallelStreams :: rangedSum , 10_000_000 )+ \" 毫秒\" ); System . out . println ( \"并行Range流:\" + measureSumPerf ( ParallelStreams :: parallelRangedSum , 10_000_000 )+ \" 毫秒\" ); 执行结果如下： 顺序 Range流 : 7 毫秒 并行 Range流 : 3 毫秒 这个速度就快多了，但是我们要记住，使用并行时，在多个内核直接移动数据的代价也比较大，因此，要保证在内核中并行执行工作的时间比在内核之间传输数据的时间要长才比较划算。 现在我们来总结一下如何高效使用并行流： - 如果用循环还是顺序流或者是并行流，像我们上面那样测试一下； - 注意装箱，尽量使用 IntStream , LongStream ，和 DoubleStream 来避免装箱拆箱; - 有些操作在并行流上性能很差，比如 limit , findFirst 等依赖顺序的操作。 unordered 方法可以把有序流转为无序流，使用 findAny 等好很多，在无序流上用 limit 也好很多; - 计算流水线操作总成本，处理单个元素用时越多，并行就越划算； - 对于较小的数据量，用并行不一定是好事儿； - 数据结果是否易于分解，比如 ArrayList 比 LinkedList 易于分解， range 创建的原始流也易于分解； - 终端操作中的合并大家是否很大，大了也不划算。","tags":"Java","url":"/java8zhong-de-bing-xing-liu.html"},{"title":"Maven项目管理","text":"maven快速入门 Maven是基于项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建、报告和文档的软件项目管理工具。 maven安装配置 下载好maven后，需要配置环境变量。 设置 JAVA_HOME ： D:\\program files\\Java\\jdk1.8.0_91 , path添加 %JAVA_HOME%\\bin 新建 M2_HOME ,指向maven安装目录： D:\\app\\apache-maven-3.3.9 修改path，添加 %M2_HOME%\\bin 在命令行中输入 mvn -v 看看是否输出正确。 maven helloworld案例 maven目录结构结构 src -main -java -package -test -java -package -resources 按照上面的目录结构创建目录，package目录先不要创建package。 分别新建 package lx.maven.model; public class HelloWorld{ public String sayHello() { return \"Helo world!\"; } } 和测试 package lx . maven . model ; import org.junit. * ; import org.junit.Assert. * ; public class HelloWorldTest { @Test public void testHello () { Assert . assertEquals ( \"Hello world!\" , new HelloWorld () . sayHello ()); } } 这里需要注意的是分别新建包。 然后需要新建pom.xml，保存在项目根目录下。 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> lx.maven </groupId> <artifactId> maven01 </artifactId> <version> 1.0-SNAPSHOT </version> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> </dependency> </dependencies> </project> 说明： - modelVersion :固定，不管 - groupId 项目的包名 - artifactId 模块名 - version 版本，SNAPSHOT快照版本 编译： mvn compile 运行测试用例： mvn test 运行后我们看到项目更目录下创建了target文件夹，这个文件夹下面又有几个子文件夹，分别是： - classes 生成的类文件字节码 - surefire-reports 测试报告 然后运行 mvn package 进行打包。打好的包在target根目录下。 Maven核心知识 常用的构建命令 之前我们已经学习了以下命令： - mvn -v :查看maven版本 - mvn compile : 编译 - mvn test : 测试 - mvn package :打包 本节主要学习以下两个命令： - mvn clean : 删除target - mvn install : 安装jar包到本地仓库中 我们新建一个项目 maven02 package lx . maven02 . util ; import lx.maven.model.HelloWorld ; public class Speak { public String sayHi () { return new HelloWorld () . sayHello (); } } package lx . maven02 . util ; import org.junit. * ; import org.junit.Assert. * ; public class SpeakTest { @Test public void testsayHi () { Assert . assertEquals ( \"Hello world!\" , new Speak () . sayHi ()); } } <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> lx.maven02 </groupId> <artifactId> maven02-util </artifactId> <version> 1.0-SNAPSHOT </version> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.10 </version> </dependency> </dependencies> </project> 此时运行 mvn compile 会报错，表示找不到对应的 lx.maven.model 包。之所以会这样是因为我们需要讲 maven01 的项目运行 mvn install 先安装到本地仓库，然后在 maven02 项目中添加依赖： <dependency> <groupId> lx.maven </groupId> <artifactId> maven01 </artifactId> <version> 1.0-SNAPSHOT </version> </dependency> 自动建立目录骨架 之前一直手动创建很麻烦，maven提供了archetype插件，用于创建符合maven规定的目录骨架。 我们先创建一个项目目录 maven03 ，然后在命令行输入： mvn archetype:generate 然后会让我们选择 archetype 版本，选择最大的就好了，然后要求我们输入 groupId ，我们输入 lx.maven03 ， artifactId 我们输入 maven03-service ， version 我们输入 1.0-SNAPSHOT .然后会要求我们输入包名，不过会根据你之前输入的 groupId 自动提供一个，我们直接回车就可以了。最后会让我们确认信息，没问题就回车。 还有一种方法是一次性设置所有参数： mvn archetype:generate -DgroupId=lx.maven03 -DartifactId=maven04-demo -Dversion=1.0SNAPSHOT -Dpackage=lx.maven03.demo maven中的坐标和仓库 坐标：构件的唯一标识。 groupId , artifactId , version 构成了坐标的基本要素。 仓库：管理项目依赖，分为两种： - 本地仓库 - 远程仓库：如果本地仓库找不到，会到maven的全球仓库去找。 镜像仓库：打开maven/conf/settings.xml文件，在 mirrors 节添加： <mirror> <id> maven.oschina.net </id> <mirrorOf> central </mirrorOf> <name> oschina maven mirror </name> <url> http://maven.oschina.net/content/groups/public </url> </mirror> mirrorOf 表示为哪个仓库指定镜像，默认是 central ，也可以使用 * 通配符。 现在看如何修改仓库位置： 默认情况下，仓库是在用户文件夹下的.m2文件中，我们可以修改settings.xml的 settings 下的位置： <localRepository> D:/mavenrepo </localRepository> 然后将 settings.xml 文件复制到 d:/mavenrepo 下，这样以后要是修改maven版本就不用再次修改settings.xml. maven的声明周期和插件 完整的项目构建过程包括： 清理、编译、测试、打包、集成测试、验证、部署 clean\\compile\\test\\package\\install maven声明周期： - clean 清理项目 - default 构建项目 - site 生成项目站点 对于clean清理项目 - pre-clean 执行清理前的工作 - clean 清理上一次构建生成的所有文件 - post-clean 执行清理后的文件 default构建项目（最核心） compile test package install都属于default阶段 site生成项目站点 - pre-site - site - post-site - site-deploy 现在加入我们要添加插件source，让打包时同时打包源码。我们修改pom.xml，加入： <build> <plugins> <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-source-plugin </artifactId> <version> 3.0.0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> jar-no-fork </goal> </goals> </execution> </executions> </plugin> </plugins> </build> 说明： - plugin的phase表明阶段 - goal表示目标 具体请看apache官方文档。 然后运行 mvn clean package 看到会生成源码的jar包。 pom.xml常用元素介绍 pom.xml用于项目描述、组织管理、依赖管理和项目信息的管理。下面我们来介绍一下常用元素。 <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <!--指定了当前的POM版本--> <modelVersion> 4.0.0 </modelVersion> <!--主项目标识：反写公司网址+项目名--> <groupId></groupId> <!--项目名+模块名--> <artifactId></artifactId> <!--当前版本项目本：大版本号.分支版本号.小版本号;SNAPSHOT:快照，ALPHA:内部测试,BETA:公测,RELEASE:稳定版,GA:正式发布--> <version> 0.0.1-SNAPSHOT </version> <!--打包方式，默认为jar .war,zip,pom--> <packaging> jar </packaging> <!--项目描述名，产生文档时使用--> <name> hi </name> <!--项目地址--> <url></url> <!--项目描述--> <description></description> <!--开发人员信息--> <developers></developers> <!--许可证信息--> <licenses></licenses> <!--组织信息--> <organization></organization> <!-- 依赖列表 --> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 3.8.1 </version> <type></type> <!-- 只在一个范围内使用 --> <scope> test </scope> <!-- 设置依赖是否可选，默认为false,默认是继承的 --> <optional></optional> <!-- 排除依赖传递列表。如果A依赖B，B依赖C，A就传递依赖C --> <exclusions> <exclusion> <groupId></groupId> <artifactId></artifactId> <version></version> </exclusion> </exclusions> </dependency> </dependencies> <!-- 依赖的管理.不会实际被引入，主要用于定义在父模块，用于子模块继承 --> <dependencyManagement> <dependencies> <dependency></dependency> </dependencies> </dependencyManagement> <build> <!-- 插件列表 --> <plugins> <plugin> <groupId></groupId> <artifactId></artifactId> <version></version> </plugin> </plugins> </build> <!-- 在子模块中对父模块POM的继承 --> <parent></parent> <!-- 多模块 --> <modules></modules> </project> 依赖范围 之前已经见过junit依赖： <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 3.8.1 </version> <scope> test </scope> </dependency> 我们平时在开发时，如果要使用某个框架就需要将该框架的jar包添加到项目的classpath中，maven为我们提供了3种classpath，分别是： - 编译 - 测试 - 运行 所以 scope 就是用来指定依赖范围的。maven官方文档上说 scope 有六种取值： compile:编译，默认的范围，编译测试运行都有效 provided:测试和编译时有效，运行时不会用 runtime:测试和运行时有效 test:测试，只在测试时有效 system:测试和编译时有效,可移植性差，与本机想关联 import：导入的范围，只使用在dependencyManagement中，表示从其他的pom中导入dependency的配置 依赖传递 A依赖B，B依赖C，则就可以说A间接依赖C。 首先，我们在B中引入对C的依赖(C应该 mvn compile install ). <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 3.8.1 </version> <type></type> <!-- 只在一个范围内使用 --> <scope> test </scope> <!-- 设置依赖是否可选，默认为false,默认是继承的 --> <optional></optional> <!-- 排除依赖传递列表。如果A依赖B，B依赖C，A就传递依赖C --> <exclusions> <exclusion> <groupId></groupId> <artifactId></artifactId> <version></version> </exclusion> </exclusions> </dependency> 有时我们需要指定JDK默认版本，在settings.xml中的 profile 配置版本。 依赖冲突 短路优先 A->B-C-X(jar) 和 A->D->X(jar) ，则A优先引用D所指向的X。 先声明先优先 如果路径长度相同，则谁先声明，先解析谁。 聚合和继承 先来说聚合。 如果有多个项目，A\\B\\C，我们想要把他们聚合起来，一起安装，我们新建一个项目D，修改它的pom.xml: <modules> <module> ../A </module> <module> ../B </module> <module> ../C </module> </modules> 然后运行 mvn clean install 就能直接安装A/B/C了。 再来说继承。 在父pom中添加： <!-- 指定类型为POM --> <packaging> pom </packaging> <properties> <!-- 定义变量 --> <junit.version> 3.8.1 </junit.version> </properties> <dependencyManagement> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> ${ junit . version } </version> </dependency> </dependencies> </dependencyManagement> 在子POM中使用： <parent> <groupId></groupId> <artifactId></artifactId> <version></version> </parent> 使用maven构建web项目 我们使用maven创建一个web项目，然后发布到jetty中。 使用IDEA创建一个maven项目，选择 maven-archetype-webapp 类型，GroupId输入 lx.webdemo ，artifectId输入 webdemo 。 在http://mvnrepository.com/ 中添加 我们打开pom.xml，添加Java Servlet API依赖，注意， servlet 的f范围是 provided ： <?xml version=\"1.0\" encoding=\"UTF-8\"?> <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> lx.webdemo </groupId> <artifactId> webdemo </artifactId> <version> 1.0-SNAPSHOT </version> <packaging> war </packaging> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 4.12 </version> <scope> test </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.1.0 </version> <!--只在编译时和测试时运行--> <scope> provided </scope> </dependency> </dependencies> </project> 然后添加 Jetty maven plugin <project xmlns= \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\" > <modelVersion> 4.0.0 </modelVersion> <groupId> lx.webdemo </groupId> <artifactId> webdemo </artifactId> <packaging> war </packaging> <version> 1.0-SNAPSHOT </version> <name> webdemo Maven Webapp </name> <url> http://maven.apache.org </url> <dependencies> <dependency> <groupId> junit </groupId> <artifactId> junit </artifactId> <version> 3.8.1 </version> <scope> test </scope> </dependency> <dependency> <groupId> javax.servlet </groupId> <artifactId> javax.servlet-api </artifactId> <version> 3.1.0 </version> </dependency> </dependencies> <build> <finalName> webdemo </finalName> <plugins> <plugin> <groupId> org.eclipse.jetty </groupId> <artifactId> jetty-server </artifactId> <version> 9.4.0.M0 </version> <executions> <execution> <phase> package </phase> <goals> <goal> run </goal> </goals> </execution> </executions> </plugin> </plugins> </build> </project> 然后运行 mvn clean package 即可。","tags":"Java","url":"/mavenxiang-mu-guan-li.html"},{"title":"Pelican使用多说评论框","text":"使用之前已经讲过，现在我们要使用多说评论框。首先找到模板目录下 comments.html ，添加： {% if DUOSHUO_SITENAME and SITEURL and article.status ! = \"draft\" %} <section> <h1> 评论 </h1> <div id= \"DuoShuoComment\" aria-live= \"polite\" > {% include '_includes/DuoShuo_Script.html' %} </div> </section> {% endif %} 然后新建 DuoShuo_Script.html : {% if DUOSHUO_SITENAME %} <!-- 多说评论框 start --> <div class= \"ds-thread\" data-thread-key= \" {{ article.url }} \" data-title= \" {{ article.title | striptags }} \" data-url= \" {{ SITEURL }} / {{ article.url }} \" ></div> <!-- 多说评论框 end --> <!-- 多说公共JS代码 start (一个网页只需插入一次) --> <script type= \"text/javascript\" > var duoshuoQuery = {short_name:\"liulixiang1988blog\"}; (function() { var ds = document.createElement('script'); ds.type = 'text/javascript';ds.async = true; ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js'; ds.charset = 'UTF-8'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(ds); })(); </script> <!-- 多说公共JS代码 end --> {% endif %}","tags":"Python","url":"/pelicanshi-yong-duo-shuo-ping-lun-kuang.html"},{"title":"使用Spark进行Java Web开发","text":"1.搭建Spark项目 使用Idea创建Gradle项目，包名是： io.github.liulixiang.course ,Artifactid是 course-ideas 。 在builder.gradle里添加spark依赖。 compile \"com.sparkjava:spark-core:2.5\" compile \"org.slf4j:slf4j-simple:1.7.21\" 然后创建 io.github.liulixiang.course.Main 类。 import static spark . Spark . get ; public class Main { public static void main ( String [] args ) { get ( \"/hello\" , ( req , res ) -> \"Hello World\" ); get ( \"/\" , ( req , res ) -> \"欢迎\" ); } } 此时，访问http://localhost:4567 就能看到返回的页面了。 2.返回响应 Spark支持多种模板引擎，我们使用Handlebars。 添加依赖： compile \"com.sparkjava:spark-template-handlebars:2.3\" 为了让IDEA支持Handlebars，我们在plugin上搜索Handlebars。关于handlebars的使用，可以参考https://github.com/perwendel/spark-template-engines/tree/master/spark-template-handlebars 现在在resources下面新建templates文件夹。然后在文件夹内新建 index.hbs 文件： <!doctype html> <html lang= \"en\" > <head> <meta charset= \"UTF-8\" > <title> 同学们好! </title> </head> <body> <h1> 同学们好! </h1> </body> </html> 修改Main: get ( \"/\" , ( req , res ) -> new ModelAndView ( null , \"index.hbs\" ), new HandlebarsTemplateEngine ()); ModelAndView 表示第一个参数是Model，第二个参数是View。 3.接受请求 要获取提交的数据，使用 req.queryParams 方法。 post ( \"/sign-in\" , ( req , res ) -> { Map < String , String > model = new HashMap <>(); model . put ( \"username\" , req . queryParams ( \"username\" )); return new ModelAndView ( model , \"sign-in.hbs\" ); }, new HandlebarsTemplateEngine ()); 添加 sign-in.hbs ： <!doctype html> <html lang= \"en\" > <head> <meta charset= \"UTF-8\" > <title> 登录 </title> </head> <body> <h1> 你好, {{ username }} </h1> </body> </html> 4.Cookies 写入cookie： cookie使用res设置： String username = req . queryParams ( \"username\" ); res . cookie ( \"username\" , username ); 读取cookie get ( \"/\" , ( req , res ) -> { Map < String , String > model = new HashMap <>(); model . put ( \"username\" , req . cookie ( \"username\" )); return new ModelAndView ( model , \"index.hbs\" ); }, new HandlebarsTemplateEngine ()); 5.创建Model 7.Template复用和静态资源处理 8. 添加并遍历List 9. 重定向 10. 使用Filter和请求属性 11. 存取指定项目 12. 细节 13. 消息 14. 创建flash message 15. 请求处理","tags":"Java","url":"/shi-yong-sparkjin-xing-java-webkai-fa.html"},{"title":"Gradle依赖管理","text":"1. 添加依赖 指定仓库是maven central repositories { mavenCentral() } 加入我们要使用apache commons中的csv包，首先在网页https://commons.apache.org/proper/commons-csv/ 中找到对应的maven： <dependency> <groupId> org.apache.commons </groupId> <artifactId> commons-csv </artifactId> <version> 1.3 </version> </dependency> 上面的是xml格式，我们把它转换成gradle格式： dependencies { compile group: 'org.apache.commons', name: 'commons-csv', version: '1.3' //等价于 //compile 'org.apache.commons:commons-csv:1.3' } 然后我们在gradle面板刷新项目。 也可以在Gradle面板右键选择 auto import . 也可以在命令行运行 ./gradlew 用来在电脑上安装gradle。以及 ./gradlew dependencies 是用来安装依赖的。 2. 使用依赖 新建类 io.github.liulixiang1988.Main 类 package io . github . liulixiang1988 ; import org.apache.commons.csv.CSVFormat ; import org.apache.commons.csv.CSVPrinter ; import java.io.IOException ; public class Main { public static void main ( String [] args ) { try { CSVPrinter printer = new CSVPrinter ( System . out , CSVFormat . EXCEL ); printer . printRecord ( \"Liu\" , \"Lixiang\" , 1988 ); printer . printRecord ( \"L\" , \"L\" , 1988 ); } catch ( IOException e ) { e . printStackTrace (); } } } 对于不知道具体名字的包，比如HTML解析包，我们可以到http://search.maven.org/ 去搜索 html parser ，但有时候搜索的结果不尽人意，此时我们可以使用google搜索 maven html parser ，会返回http://mvnrepository.com/ 网站对 maven 的搜索。 我们也可以使用github搜索，条件是 language:java ，然后按星排名。","tags":"Java","url":"/gradleyi-lai-guan-li.html"},{"title":"Java lambda简介","text":"1. 老的方法 //Book.java public class Book { private String mTitle; private String mAuthor; private int mPublicationDate; public Book(String title, String author, int publicationDate) { mTitle = title; mAuthor = author; mPublicationDate = publicationDate; } public String getTitle() { return mTitle; } public String getAuthor() { return mAuthor; } public int getPublicationDate() { return mPublicationDate; } @Override public String toString() { return \"Book{\" + \"mTitle='\" + mTitle + '\\'' + \", mAuthor='\" + mAuthor + '\\'' + \", mPublicationDate=\" + mPublicationDate + '}'; } } // Books . java import java.util.ArrayList ; import java.util.List ; public class Books { public static List < Book > all () { List < Book > books = new ArrayList < Book > (); books . add ( new Book ( \"Functional Programming in Java\" , \"Venkat Subramaniam\" , 2014 )); books . add ( new Book ( \"Clean Code\" , \"Robert C. Martin\" , 2008 )); books . add ( new Book ( \"Java Generics and Collections\" , \"Maurice Naftalin and Philip Wadler\" , 2008 )); books . add ( new Book ( \"Effective Java\" , \"Joshua Bloch\" , 2008 )); books . add ( new Book ( \"Pragmatic Unit Testing in Java 8 with JUnit\" , \"Jeff Langr\" , 2015 )); books . add ( new Book ( \"JavaFX Essentials\" , \"Mohamed Taman\" , 2015 )); return books ; } } public class Main { public static void usingAnonymousInlineClass(){ List<Book> books = Books.all(); Collections.sort(books, new Comparator<Book>() { @Override public int compare(Book b1, Book b2) { return b1.getTitle().compareTo(b2.getTitle()); } }); for(Book book : books) { System.out.println(book); } } public static void main(String[] args) { // write your code here usingAnonymousInlineClass(); } } 2. Java Lambdas //Lambda长形式 public static void usingLambdaInLongForm(){ List<Book> books = Books.all(); Collections.sort(books, (Book b1, Book b2) -> { return b1.getTitle().compareTo(b2.getTitle()); }); for(Book book : books) { System.out.println(book); } } //Lambda短形式 public static void usingLambdaInShortForm(){ List<Book> books = Books.all(); Collections.sort(books, (b1, b2) -> b1.getTitle().compareTo(b2.getTitle())); //forEach调用 books.forEach((book)->System.out.println(book)); } 3. 方法引用 public static void usingMethodReference () { List < Book > books = Books . all (); Collections . sort ( books , Comparator . comparing ( Book :: getTitle )); books . forEach ( System . out :: println ); }","tags":"Java","url":"/java-lambdajian-jie.html"},{"title":"Hibernate学习笔记","text":"1. Java链接数据库 import java.sql.Connection ; import java.sql.DriverManager ; import java.sql.ResultSet ; import java.sql.SQLException ; import java.sql.Statement ; import java.util.List ; import java.util.ArrayList ; public class JdbcMain { public static void main ( String [] args ) throws ClassNotFoundException { // TODO: Load the SQLite JDBC driver (JDBC class implements java.sql.Driver) Class . forName ( \"org.sqlite.JDBC\" ); // TODO: Create a DB connection try ( Connection connection = DriverManager . getConnection ( \"jdbc:sqlite:contactmgr.db\" )) { // TODO: Create a SQL statement Statement statement = connection . createStatement (); // TODO: Create a DB table statement . executeUpdate ( \"DROP TABLE IF EXISTS contacts\" ); statement . executeUpdate ( \"CREATE TABLE contacts (id INTEGER PRIMARY KEY, firstname STRING, lastname STRING, email STRING, phone INT(10))\" ); // TODO: Insert a couple contacts statement . executeUpdate ( \"INSERT INTO contacts (firstname, lastname, email, phone) VALUES('Liu', 'Lixiang', 'liulixiang1988@gmail.com', 1234567890)\" ); statement . executeUpdate ( \"INSERT INTO contacts (firstname, lastname, email, phone) VALUES('Long', 'Long', 'abc@gmail.com', 0987654321)\" ); // TODO: Fetch all the records from the contacts table ResultSet rs = statement . executeQuery ( \"SELECT * FROM contacts\" ); // TODO: Iterate over the ResultSet & display contact info while ( rs . next ()){ int id = rs . getInt ( \"id\" ); String firstName = rs . getString ( \"firstname\" ); String lastName = rs . getString ( \"lastname\" ); System . out . printf ( \"%s %s (%d)\" , firstName , lastName , id ); } } catch ( SQLException ex ) { // Display connection or query errors System . err . printf ( \"There was a database error: %s%n\" , ex . getMessage ()); } } } 编译： javac JdbcMain.java 运行： java -cp sqlite-jdbc.3.8.6.jar:. JdbcMain 2 Hibernate入门 2.1 创建一个使用Hibernate的项目 创建gradle项目 contactmgr-hibernate 项目,并修改 build.gradle : dependencies { compile 'org.hibernate:hibernate-core:5.1.0.Final' compile 'com.h2database:h2:1.4.191' } 在根目录创建 data 文件夹，用来存放h2文件数据库。 在 resources 目录下创建 hibernate.cfg.xml ，这个文件用来保存 SessionFactory 的配置： <hibernate-configuration> <session-factory> <!--数据库链接配置--> <property name= \"connection.driver_class\" > org.h2.Driver </property> <property name= \"connection.url\" > jdbc:h2:./data/contactmgr </property> <!--SQL 方言--> <property name= \"dialect\" > org.hibernate.dialect.H2Dialect </property> </session-factory> </hibernate-configuration> 2.2 使用JPA注解添加POJO 添加包 io.github.liulixiang1988.contactmgr ，并在其中创建 Application 类： package io.github.liulixiang1988.contactmgr ; public class Application { public static void main ( String [] args ) { } } 然后在 contactmgr 中创建 model 包，并创建 Contact 类： package io.github.liulixiang1988.contactmgr.model ; import javax.persistence.* ; @Entity //映射为表 public class Contact { @Id //主键 @GeneratedValue ( strategy = GenerationType . IDENTITY ) //自增长 private int id ; @Column private String firstName ; @Column private String lastName ; @Column private String email ; @Column private Long phone ; // 为JPA准备的 public Contact (){} @Override public String toString () { return \"Contact{\" + \"id=\" + id + \", firstName='\" + firstName + '\\'' + \", lastName='\" + lastName + '\\'' + \", email='\" + email + '\\'' + \", phone=\" + phone + '}' ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } public String getFirstName () { return firstName ; } public void setFirstName ( String firstName ) { this . firstName = firstName ; } public String getLastName () { return lastName ; } public void setLastName ( String lastName ) { this . lastName = lastName ; } public String getEmail () { return email ; } public void setEmail ( String email ) { this . email = email ; } public Long getPhone () { return phone ; } public void setPhone ( Long phone ) { this . phone = phone ; } } 然后我们修改 hibernate.cfg.xml 来为model做一些配置： <hibernate-configuration> <session-factory> <!--...--> <!--启动时创建数据结构--> <property name= \"hbm2ddl.auto\" > create </property> <!--为标识的实体类命名--> <mapping class= \"io.github.liulixiang1988.contactmgr.model.Contact\" /> </session-factory> </hibernate-configuration> 2.3 创建Hibernate SessionFactory public class Application { //保存一个SessionFactory(我们也只需要一个) private static final SessionFactory sessionFactory = buildSessionFactory(); private static SessionFactory buildSessionFactory() { //创建StandardServiceRegistry final ServiceRegistry registry = new StandardServiceRegistryBuilder().configure().build(); return new MetadataSources(registry).buildMetadata().buildSessionFactory(); } public static void main(String[] args) { } } 2.4 Builder模式 修改Contact.java public class Contact { //... @Override public String toString() { return \"Contact{\" + \"id=\" + id + \", firstName='\" + firstName + '\\'' + \", lastName='\" + lastName + '\\'' + \", email='\" + email + '\\'' + \", phone=\" + phone + '}'; } //... public static class ContactBuilder { private String firstName; private String lastName; private String email; private Long phone; public ContactBuilder(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public ContactBuilder withEmail(String email) { this.email = email; return this; } public ContactBuilder withPhone(Long phone) { this.phone = phone; return this; } public Contact build() { return new Contact(this); } } } 修改 Application.java : public static void main(String[] args) { Contact contact = new ContactBuilder(\"Chris\",\"Ramacciotti\") .withEmail(\"rama@teamtreehouse.com\") .withPhone(7735556666L) .build(); } 3. 使用Hibernate存取数据 要让Hibernate支持存取数据，需要添加依赖： compile 'javax.transaction:jta:1.1' 为了能看到Hibernate准备的查询，我们设置： <property name= \"show_sql\" > true </property> 3.1 添加数据 public static void main(String[] args) { Contact contact = new ContactBuilder(\"Chris\",\"Ramacciotti\") .withEmail(\"rama@teamtreehouse.com\") .withPhone(7735556666L) .build(); //打开session Session session = sessionFactory.openSession(); //begin transaction session.beginTransaction(); //使用session来保存对象 session.save(contact); //提交session session.getTransaction().commit(); //关闭session session.close(); } 3.2 查询数据 @SuppressWarnings(\"unchecked\") private static List<Contact> fetchAllContact() { Session session = sessionFactory.openSession(); //创建Criteria Criteria criteria = session.createCriteria(Contact.class); //从Criteria中获取数据 List<Contact> contacts = criteria.list(); //关闭会话 session.close(); return contacts; } 调用可以使用java8的特性，而非使用for循环： fetchAllContact () .stream () .forEach ( System .out : :println ); 可以通过修改 hibernate.cfg.xml ，让每次启动时是更新而不是创建数据库： <property name= \"hbm2ddl.auto\" > update </property> 3.3 更新与删除 private static Contact findContactById(int id) { //打开会话 Session session = sessionFactory.openSession(); //获取对象或者null Contact contact = session.get(Contact.class, id); //关闭会话 session.close(); //返回对象 return contact; } private static void update(Contact contact) { Session session = sessionFactory.openSession(); session.beginTransaction(); session.update(contact); session.getTransaction().commit(); session.close(); } private static void delete(Contact contact) { Session session = sessionFactory.openSession(); session.beginTransaction(); session.delete(contact); session.getTransaction().commit(); session.close(); }","tags":"Java","url":"/hibernatexue-xi-bi-ji.html"},{"title":"Spring学习笔记","text":"1. 环境配置 1.1 创建应用 打开idea,新建应用： 然后输入包名、应用名： 其他默认。 1.2 修改build.gradle 打开build.gradle，修改dependencies: group 'io.github.liulixiang1988' version '1.0-SNAPSHOT' buildscript { repositories { mavenCentral() } dependencies { classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.3.3.RELEASE' } } apply plugin: 'java' apply plugin: 'spring-boot' sourceCompatibility = 1.5 repositories { mavenCentral() } dependencies { compile 'org.springframework.boot:spring-boot-starter-web:1.3.3.RELEASE' } 注意，我们使用spring boot，它依赖于spring mvc的。并且，添加了 buildscript 和 apply plugin: 'spring-boot' ，用来运行spring应用。 然后在项目根目录下新建 src/main/java 文件夹。 现在通过IDEA的View->Tools View->Gradle打开Gradle面板，点击同步图标来下载安装依赖。 1.3 添加spring配置文件 在 src/main/java 中新建包 io.github.liulixiang1988 。并在这个包里新建 AppConfig.java 。它用来启动应用。 package io.github.liulixiang1988 ; import org.springframework.boot.SpringApplication ; import org.springframework.boot.autoconfigure.EnableAutoConfiguration ; @EnableAutoConfiguration //自动配置 public class AppConfig { public static void main ( String [] args ){ SpringApplication . run ( Appconfig . class , args ); } } 此时，右键选择运行gradle面板下的Tasks/application/bootRun任务。 打开浏览器http://127.0.0.1:8080/ 可以看到页面： 这就说明你成功了。 2. 创建控制器和视图 2.1 创建控制器处理HTTP请求 首先在 io.github.liulixiang1988 下创建一个包 controller 。然后在这个包里创建 GifController 类。 package io.github.liulixiang1988.controller ; import org.springframework.stereotype.Controller ; import org.springframework.web.bind.annotation.RequestMapping ; import org.springframework.web.bind.annotation.ResponseBody ; @Controller //1. 标识控制器 public class GifController { @RequestMapping ( \"/\" ) //2. 添加映射 @ResponseBody //3. 返回响应 public String listGifs () { return \"List of all gifs\" ; } } 添加过Controller之后，应用并不能自己发现Controller，因此，我们修改 AppConfig.java ，添加 @ComponentScan 。 @EnableAutoConfiguration //自动配置 @ComponentScan //扫描控制器 public class AppConfig { public static void main ( String [] args ){ SpringApplication . run ( AppConfig . class , args ); } } 现在重新运行bootRun任务，打开http://127.0.0.1:8080 可以看到如下响应。 2.2 使用Thymeleaf渲染模板 我们使用Thymeleaf来渲染模板，因此，需要先修改 build.gradle 用来添加相应的库。 dependencies { compile 'org.springframework.boot:spring-boot-starter-thymeleaf' } 然后在gradle面板中的刷新按钮安装对应的包。 Thymeleaf默认寻找src/main/resources/templates下的模板，因此，我们创建对应的文件夹。 在templates目录下面创建home.html。注意，Thymeleaf要求必须html标签必须有结束标签或者自关闭的。 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" /> < title > Giflib | Home </ title > </ head > < body > < h1 > 首页 </ h1 > < p > hello </ p > < img src = \"http://placehold.it/300x300/5fcf80/ffffff\" alt = \"logo\" /> </ body > </ html > 现在修改控制器GifController: @Controller //1. 标识控制器 public class GifController { @RequestMapping ( \"/\" ) //2. 添加映射 public String listGifs () { return \"home\" ; //3. 返回模板名称 } } 2.3 添加静态文件 在 resources 目录下新建 static 目录用来存放静态文件。我们在 static 文件夹下分别创建 css , fonts , js 文件夹。直接把bootstrap添加进来。 修改 home.html ： <!DOCTYPE html> < html lang = \"en\" xmlns:th = \"http://www.thymeleaf.org\" > < head > < meta charset = \"UTF-8\" /> < title > Giflib | Home </ title > < link rel = \"stylesheet\" th:href = \"@{/css/bootstrap.min.css}\" /> < link rel = \"stylesheet\" th:href = \"@{/css/app.css}\" /> </ head > < body > < div class = \"container\" > < div class = \"row\" > < h1 > 首页 </ h1 > < p > hello </ p > < img th:src = \"@{/gifs/compiler-bot.gif}\" alt = \"logo\" /> </ div > </ div > < script th:src = \"@{/js/bootstrap.min.js}\" ></ script > </ body > </ html > 需要说明的是： - 添加 xmlns:th - 静态文件的链接是以 static 文件夹为根目录，使用 @{} 引入。 3. 模型、数据存取 3.1 数据注入到模板 首先，创建 model 模块，并在下面创建 Gif.java : package io.github.liulixiang1988.model ; import java.time.LocalDate ; public class Gif { private String name ; private LocalDate dateUploaded ; private String username ; private boolean favorite ; public Gif ( String name , LocalDate dateUploaded , String username , boolean favorite ) { this . name = name ; this . dateUploaded = dateUploaded ; this . username = username ; this . favorite = favorite ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } public LocalDate getDateUploaded () { return dateUploaded ; } public void setDateUploaded ( LocalDate dateUploaded ) { this . dateUploaded = dateUploaded ; } public String getUsername () { return username ; } public void setUsername ( String username ) { this . username = username ; } public boolean isFavorite () { return favorite ; } public void setFavorite ( boolean favorite ) { this . favorite = favorite ; } } 修改 GifController ，注入数据： @Controller //1. 标识控制器 public class GifController { @RequestMapping ( \"/\" ) //2. 添加映射 public String listGifs () { return \"home\" ; //3. 返回模板名称 } @RequestMapping ( \"/gif\" ) public String getDetails ( ModelMap modelMap ) { Gif gif = new Gif ( \"compiler-bot\" , LocalDate . of ( 2016 , 5 , 1 ), \"刘理想\" , true ); modelMap . put ( \"gif\" , gif ); return \"gif-details\" ; } } 数据注入是使用 ModelMap 来实现的。 打开模板 gif-detail.html ，调用注入的数据方法是 ${} 方法。 <div class= \"frame row\" > <div class= \"col s12\" > <img th:src= \"@{'/gifs/'+ ${ gif . name } +'.gif'}\" alt= \"gif\" /> <a href= \"#\" class= \"mark favorite\" ></a> </div> </div> 3.2 创建数据仓库组件 创建包 data ，并在其中创建 GifRepository 类。 package io.github.liulixiang1988.data ; import java.time.LocalDate ; import java.util.Arrays ; import java.util.List ; import io.github.liulixiang1988.model.Gif ; import org.springframework.stereotype.Component ; @Component //声明组件,用于依赖注入 public class GitRepository { private static final List < Gif > ALL_GIFS = Arrays . asList ( new Gif ( \"android-explosion\" , LocalDate . of ( 2016 , 5 , 1 ), \"刘理想\" , true ), new Gif ( \"ben-and-mike\" , LocalDate . of ( 2016 , 4 , 10 ), \"刘理想\" , true ), new Gif ( \"book-dominos\" , LocalDate . of ( 2016 , 4 , 1 ), \"刘理想\" , true ), new Gif ( \"complier-bot\" , LocalDate . of ( 2016 , 4 , 12 ), \"刘理想\" , true ), new Gif ( \"cowboy-coder\" , LocalDate . of ( 2016 , 4 , 13 ), \"刘理想\" , false ), new Gif ( \"infinite-andrew\" , LocalDate . of ( 2016 , 4 , 15 ), \"刘理想\" , true ) ); public Gif findByName ( String name ) { for ( Gif gif : ALL_GIFS ) { if ( gif . getName (). equals ( name )) { return gif ; } } return null ; } } 注意，这里使用 @Component 声明了组件，为后期的依赖注入做好准备。 现在修改 GifController ，添加 GifRepository 字段。 public class GifController { @Autowired //依赖注入 private GifRepository gifRepository ; //... @RequestMapping ( \"/gif\" ) public String getDetails ( ModelMap modelMap ) { Gif gif = gifRepository . findByName ( \"ben-and-mike\" ); modelMap . put ( \"gif\" , gif ); return \"gif-details\" ; } } 3.3 使用 @PathVariable 创建动态页 @RequestMapping ( \"/gif/{name}\" ) public String getDetails ( @PathVariable String name , ModelMap modelMap ) { Gif gif = gifRepository . findByName ( name ); modelMap . put ( \"gif\" , gif ); return \"gif-details\" ; } 然后修改对应的模板： <div class= \"col s12\" > <img th:src= \"@{'/gifs/'+ ${ gif . name } +'.gif'}\" alt= \"gif\" /> <a href= \"#\" th:class= \"( ${ gif . favorite } ? 'un' : '') +'mark favorite'\" ></a> </div> 3.4 列表展示 列表数据注入： @RequestMapping ( \"/\" ) //2. 添加映射 public String listGifs ( ModelMap modelMap ) { List < Gif > allGifs = gifRepository . getAllGifs (); modelMap . put ( \"gifs\" , allGifs ); return \"home\" ; //3. 返回模板名称 } 模板展示： <div th:each= \"gif : ${ gifs } \" class= \"col s12 l4\" > <a th:href= \"@{'/gif/'+ ${ gif . name } }\" > <img th:src= \"@{'/gifs/'+ ${ gif . name } +'.gif'}\" /> <a href= \"#\" th:class= \"@{( ${ gif . favorite } ? 'un': '')+'mark favorite'}\" ></a> </a> </div> 4. MVC架构 4.1 添加Category类 package io.github.liulixiang1988.model ; public class Category { private int id ; private String name ; public Category ( int id , String name ) { this . id = id ; this . name = name ; } public int getId () { return id ; } public void setId ( int id ) { this . id = id ; } public String getName () { return name ; } public void setName ( String name ) { this . name = name ; } } 4.2 添加CategoryRepository类 package io.github.liulixiang1988.data ; import io.github.liulixiang1988.model.Category ; import org.springframework.stereotype.Component ; import java.util.Arrays ; import java.util.List ; @Component public class CategoryRepository { private static final List < Category > ALL_CATEGORIES = Arrays . asList ( new Category ( 1 , \"Technology\" ), new Category ( 2 , \"People\" ), new Category ( 3 , \"Destruction\" ) ); public List < Category > getAllCategories () { return ALL_CATEGORIES ; } public Category findById ( int id ) { for ( Category category : ALL_CATEGORIES ) { if ( category . getId () == id ){ return category ; } } return null ; } } 4.3 添加CateogryController package io.github.liulixiang1988.controller ; import io.github.liulixiang1988.data.CategoryRepository ; import io.github.liulixiang1988.data.GifRepository ; import io.github.liulixiang1988.model.Category ; import io.github.liulixiang1988.model.Gif ; import org.springframework.beans.factory.annotation.Autowired ; import org.springframework.stereotype.Controller ; import org.springframework.ui.ModelMap ; import org.springframework.web.bind.annotation.PathVariable ; import org.springframework.web.bind.annotation.RequestMapping ; import java.util.List ; @Controller public class CategoryController { @Autowired private CategoryRepository categoryRepository ; @Autowired private GifRepository gifRepository ; @RequestMapping ( \"/categories\" ) public String listCategories ( ModelMap modelMap ){ List < Category > categories = categoryRepository . getAllCategories (); modelMap . put ( \"categories\" , categories ); return \"categories\" ; } @RequestMapping ( \"/category/{id}\" ) public String category ( @PathVariable int id , ModelMap modelMap ){ Category category = categoryRepository . findById ( id ); modelMap . put ( \"category\" , category ); List < Gif > gifs = gifRepository . findByCategoryId ( id ); modelMap . put ( \"gifs\" , gifs ); return \"category\" ; } } 4.4 修改模板 <div class= \"search-bar container\" > <div class= \"row\" > <div class= \"col s12\" > <form action= \"#\" method= \"get\" > <div class= \"input-field\" > <input name= \"q\" type= \"search\" placeholder= \"Search all gifs...\" required= \"required\" autocomplete= \"off\"/ > <i class= \"material-icons\" > search </i> </div> </form> </div> </div> </div> <div class= \"categories container\" > <div class= \"row\" > <!-- Repeat the div element for each object in the 'categories' collection of the model map. Each object in the loop should be named 'category' --> <div th:each= \"category: ${ categories } \" class= \"col s12 l4\" > <div class= \"card\" > <div class= \"card-content\" > <div class= \"card-title\" > <!-- Set the href attribute of the a tag to be the URI to a specific category according to the category's id. For example, /category/1 or /category/2 Then, set the text between the a tags to be the category name, coming from the 'name' field of the 'category' object in the model map --> <a th:href= \"@{'/category/'+ ${ category . id } }\" th:text= \" ${ category . name } \" > Category Name </a> </div> </div> </div> </div> </div> </div> <div class= \"gifs container\" > <!-- In the div element, replace the 'category name' text with the value of the 'name' field of the 'category' object from the model map --> <div class= \"chip\" th:text= \" ${ category . name } \" > category name </div> <div class= \"row\" > <!-- Repeat the div element for each object in the 'gifs' collection of the model map. Each object in the loop should be named 'gif' --> <div th:each= \"gif : ${ gifs } \" class= \"col s12 l4\" > <!-- In the a tag, make the href attribute point to the GIF detail page using the 'name' field of the 'gif' object from the loop above --> <a th:href= \"@{'/gif/'+ ${ gif . name } }\" > <!-- In the img tag, make the src attribute point to the static GIF image, according to the 'name' field of the 'gif' object from the loop above --> <img th:src= \"@{'/gifs/'+ ${ gif . name } +'.gif'}\" /> <!-- In the a tag, make the class attribute have the value of 'mark favorite' or 'unmark favorite' according to the 'favorite' field of the 'gif' object from the loop above --> <a href= \"#\" th:class= \"( ${ gif . favorite } ? 'un' : '') +'mark favorite'\" ></a> </a> </div> </div> </div>","tags":"Java","url":"/springxue-xi-bi-ji.html"},{"title":"使用React Native创建一个天气应用","text":"使用React Native创建一个天气应用 来自Learning React Native 代码地址：https://github.com/liulixiang1988/react-apps/tree/master/book_demos/WeatherProject 效果如下： 1. 创建应用 react-native init WeatherProject 将index.ios/index.android.js文件中的初始组件放到单独的文件WeatherProject.js中。 此时的index.ios.js/index.adnroid.js如下： 'use strict' ; import React , { AppRegistry , } from 'react-native' ; import WeatherProject from './WeatherProject' ; AppRegistry . registerComponent ( 'WeatherProject' , () => WeatherProject ); 2. 处理用户输入 根据用户输入的城市名获取天气（天气信息来自 和风天气 ） 修改WeatherProject.js 'user strict' ; import React , { Component , StyleSheet , Text , TextInput , View } from 'react-native' ; const styles = StyleSheet . create ({ container : { flex : 1 , justifyContent : 'center' , alignItems : 'center' , backgroundColor : '#F5FCFF' , }, welcome : { fontSize : 20 , textAlign : 'center' , margin : 10 , }, input : { fontSize : 20 , borderWidth : 2 , height : 40 , }, }); export default class WeatherProject extends Component { constructor ( props ){ super ( props ); this . state = { city : '' } } _handleTextChange ( event ){ console . log ( event . nativeEvent . text ); this . setState ({ city : event . nativeEvent . text }); } render () { return ( < View style = { styles . container } > < Text style = { styles . welcome } > 城市 ： { this . state . city } < /Text> < TextInput style = { styles . input } onSubmitEditing = { this . _handleTextChange . bind ( this )} /> < /View> ); } } 3. 显示数据 修改WeatherProject.js添加虚拟数据： constructor ( props ){ super ( props ); this . state = { city : '' , forcast : { main : '阴' , description : '多云' , temp : 20 } } } 添加Forecast.js: 'user strict' ; import React , { Component , StyleSheet , Text , View } from 'react-native' ; const styles = StyleSheet . create ({ bigText : { flex : 2 , fontSize : 20 , textAlign : 'center' , margin : 10 , color : '#FFFFFF' , }, mainText : { flex : 1 , fontSize : 16 , textAlign : 'center' , color : '#FFFFFF' , } }); export default class Forecast extends Component { render () { return ( < View > < Text style = { styles . bigText } > { this . props . main } < /Text> < Text style = { styles . mainText } > 当前 ： { this . props . description } < /Text> < Text style = { styles . bigText } > { this . props . temp } 度 < /Text> < /View> ); } } 更新WeatherProject.js来应用Forecast: 'user strict' ; import React , { Component , Image , StyleSheet , Text , TextInput , View } from 'react-native' ; import Forecast from './Forecast' ; const baseFontSize = 16 ; const styles = StyleSheet . create ({ backdrop : { flex : 1 , flexDirection : 'column' , }, container : { flex : 1 , justifyContent : 'center' , alignItems : 'center' , }, row : { flex : 1 , flexDirection : 'row' , flexWrap : 'nowrap' , alignItems : 'flex-start' , padding : 30 , }, overlay : { paddingTop : 5 , backgroundColor : '#000000' , opacity : 0.5 , flexDirection : 'column' , alignItems : 'center' , }, cityContainer : { flex : 1 , borderBottomColor : '#DDDDDD' , borderBottomWidth : 1 , marginLeft : 5 , marginTop : 3 , }, cityName : { width : 50 , height : baseFontSize , }, mainText : { flex : 1 , fontSize : baseFontSize , color : '#FFFFFF' , } }); export default class WeatherProject extends Component { constructor ( props ){ super ( props ); this . state = { city : '' , forecast : { main : '阴' , description : '多云' , temp : 20 } } } _handleTextChange ( event ){ console . log ( event . nativeEvent . text ); this . setState ({ city : event . nativeEvent . text }); } render () { return ( < View style = { styles . container } > < Image source = { require ( 'image!flowers' )} resizeMode = 'cover' style = { styles . backdrop } > < View style = { styles . overlay } > < View style = { styles . row } > < View style = { styles . cityContainer } > < TextInput style = {[ styles . cityName , styles . mainText ]} returnKeyType = 'go' onSubmitEditing = { this . _handleTextChange . bind ( this )} /> < /View> < Text style = { styles . mainText } > 天气 < /Text> < /View> < Forecast main = { this . state . forecast . main } description = { this . state . forecast . description } temp = { this . state . forecast . temp } /> < /View> < /Image> < /View> ); } } 4. 请求网络数据 'user strict' ; import React , { Component , Image , StyleSheet , Text , TextInput , View } from 'react-native' ; import Forecast from './Forecast' ; const baseFontSize = 16 ; const styles = StyleSheet . create ({ backdrop : { flex : 1 , flexDirection : 'column' , }, container : { flex : 1 , justifyContent : 'center' , alignItems : 'center' , }, row : { flex : 1 , flexDirection : 'row' , flexWrap : 'nowrap' , alignItems : 'flex-start' , padding : 30 , }, overlay : { paddingTop : 5 , backgroundColor : '#000000' , opacity : 0.5 , flexDirection : 'column' , alignItems : 'center' , }, cityContainer : { flex : 1 , borderBottomColor : '#DDDDDD' , borderBottomWidth : 1 , marginLeft : 5 , marginTop : 3 , }, cityName : { width : 50 , height : baseFontSize , }, mainText : { flex : 1 , fontSize : baseFontSize , color : '#FFFFFF' , } }); export default class WeatherProject extends Component { constructor ( props ){ super ( props ); this . state = { city : '' , forecast : null } } _handleTextChange ( event ){ let city = event . nativeEvent . text ; var city_code = '' ; console . log ( city ); this . setState ({ city : city }); fetch ( 'https://api.heweather.com/x3/citylist?search=allchina&key=ef29baab02f049adaa4ce2afba6f29b9' ) . then (( response ) => response . json ()) . then (( responseJson ) => { console . log ( responseJson ); for ( var item of responseJson . city_info ){ if ( item . city == city ){ console . log ( \"city\" ); this . _getWeatherInfo ( item . id ); } } }) . catch (( error ) => { console . warn ( error ); }); } _getWeatherInfo ( city_code ){ let url = 'https://api.heweather.com/x3/weather?cityid=' + city_code + '&key=ef29baab02f049adaa4ce2afba6f29b9' ; fetch ( url ) . then (( response ) => response . json ()) . then (( responseJson ) => { let weatherInfo = responseJson [ \"HeWeather data service 3.0\" ][ 0 ]; console . log ( weatherInfo ); this . setState ({ forecast : { main : weatherInfo . daily_forecast [ 0 ]. cond . txt_n , description : weatherInfo . aqi . city . qlty , temp : weatherInfo . daily_forecast [ 0 ]. tmp . min + '~' + weatherInfo . daily_forecast [ 0 ]. tmp . max } }); }) . catch (( error ) => { console . warn ( error );}); } render () { var content = null ; if ( this . state . forecast !== null ){ content = < Forecast main = { this . state . forecast . main } description = { this . state . forecast . description } temp = { this . state . forecast . temp } /> ; } return ( < View style = { styles . container } > < Image source = { require ( 'image!flowers' )} resizeMode = 'cover' style = { styles . backdrop } > < View style = { styles . overlay } > < View style = { styles . row } > < View style = { styles . cityContainer } > < TextInput style = {[ styles . cityName , styles . mainText ]} returnKeyType = 'go' onSubmitEditing = { this . _handleTextChange . bind ( this )} /> < /View> < Text style = { styles . mainText } > 天气 < /Text> < /View> { content } < /View> < /Image> < /View> ); } }","tags":"Web","url":"/shi-yong-react-nativechuang-jian-yi-ge-tian-qi-ying-yong.html"},{"title":"Kotlin学习笔记","text":"0. Kotlin简介 0.1 简介 0.2 Kotlin安装 0.3 Hello, Kotlin fun main ( args : Array < String >) { println ( \"Hello, Kotlin!\" ) } 1. 类型和变量 1.1 变量声明(Variable Declarations) fun main ( args : Array < String >) { val_declarations () } fun val_declarations (){ //val声明的变量不能更改 val a : Int = 64 val b : Long = 123 //这种事不行的,必须每个占一行: //val c = 3, d = 4 val c : Float = 3.4f //后面跟'F'或者'f' val d : Double = 3.4 val e : Double = 12.3 e5 //不赋值的val声明 val f : Int f = 13 val g : StringBuffer = StringBuffer ( \"test\" ) g . replace ( 0 , 1 , \"T\" ) //打印 println ( \"$a $b $c $d $e $f\" ) println ( \"$g\" ) //可更改的变量 var h : Int = 123 h = 45 println ( \"$h\" ) } 1.2 类型推导(Type Deduction) 类型能够根据赋值进行推到 fun main ( args : Array < String >) { val_declarations () } fun val_declarations (){ //val声明的变量不能更改 val a = 64 val b = 123 val c = 3.4f //后面跟'F'或者'f' val d = 3.4 val e = 12.3 e5 //不赋值的val声明，变量类型不能省略 val f : Int f = 13 val g = StringBuffer ( \"test\" ) g . replace ( 0 , 1 , \"T\" ) //打印 println ( \"$a $b $c $d $e $f\" ) println ( \"$g\" ) //可更改的变量 var h = 123 h = 45 println ( \"$h\" ) } 1.3 Ranges /** * Created by liulixiang on 16/2/26. */ fun main ( args : Array < String >) { ranges () } fun ranges (){ val a : IntRange = 1. . 10 //闭区间,而不是左闭右开. 1, 2, ..., 10(含10) //遍历range,使用in语法 for ( x in a ) println ( x ) //除了上面的声明方式,还有以下声明方式: val b = 1. rangeTo ( 10 ) println ( \"=====逆序=====\" ) val c : IntProgression = b . reversed () for ( x in c ) println ( x ) println ( \"=====range求和=====\" ) println ( \"sum of ints $c = ${c.sum()}\" ) println ( \"=====递减的range=====\" ) val d = 10. downTo ( 1 ) //不能用10..1 for ( x in d ) println ( x ) println ( \"=====省略括号======\" ) val e = 10 downTo 1 for ( x in e ) println ( x ) println ( \"=====根据变量声明range======\" ) val m = 8 val n = - 3 val f = IntRange ( Math . min ( m , n ), Math . max ( m , n )) for ( x in f ) println ( x ) println ( \"=====指定步长======\" ) val g = 100 downTo 1 step 3 for ( x in g ) print ( \"$x\\t\" ) println () } 1.4 数组 1.5 Strings and String Interpolation fun main ( args : Array < String >) { characters_and_strings () } fun characters_and_strings () { //字符 println ( \"=====字符=====\" ) val a : Char = '\\ u0041 ' if ( a . toInt () == 65 ){ println ( \"match\" ) } //字符串 println ( \"=====字符=====\" ) val b : String = \"Hello\" println ( b ) println ( \"取字符串中的字符:${b[0]}\" ) println ( \"遍历字符串中的字符:\" ) for ( letter in b ) print ( \"$letter\\t\" ) println () //原始字符串 println ( \"=====原始字符串=====\" ) val raw = \"\"\"Hello \"test\" world \"\"\" println ( raw ) //字符串模板 println ( \"=====字符串模板=====\" ) val c = 123.0 val d = \"c = $c, price = ${'$'}${c/10}\" println ( d ) //range println ( \"=====range=====\" ) val e = \"${(10 downTo 1).toList().map { it.toString().toList() }.joinToString()}\" println ( e ) } 2. 控制流 2.1 Nullability 在kotlin中 var x:String = null 是不允许的，因为它要求 x 不能为空。 fun main(args: Array<String>){} 对于上面的 args 表示的是由不能为空的 String 组成的不能为空的 Array 。 如果为null该怎么办，在类型名后添加 ? 。 fun main ( args : Array < String >) { nullability () } fun nullability (){ var y : String ? = null //下面的是错误的 //println(y.length) var len : Int ? = y ?. length println ( len ) //或者这样返回-1，其中?:类似else，也就是说如果y是Null，就返回-1 var len2 : Int = y ?. length ?: - 1 println ( len2 ) //注意：1.系统库其实自动添加了null 检查，比如 System.out.println，其实是System?.out?.println //关闭null检查：y!!.length 如果此时y为null会抛出异常 } 2.2 If 语句 第一种是 ? : 形式 if语句直接返回值。 fun main ( args : Array < String >) { if_statement () } fun if_statement () { //? : val temp = 20 val feel = if ( temp < 10 ) \"cold\" else if ( temp > 20 ) \"warm\" else \"ok\" println ( \"it feels $feel outside\" ) println ( \"it is ${if(temp > 20) \" warm \" else \" ok \"} today\" ) } 2.3 根据循环自动类型转换(Flow-Based Typing) fun flow_based_typing () { var s : String ? = \"hjkh\" if ( s != null ){ //不需要s?.length println ( s . length ) } var x : Cloneable = intArrayOf ( 1 , 2 , 3 ) if ( x is IntArray ){ //不需要(x as IntArray).size println ( x . size ) } } 2.4 for遍历(for Iteration) fun for_loop (){ //普通for循环 for ( a in ( 10 downTo 1 )) print ( \"$a\\t\" ) println () //数组for循环 val ints = intArrayOf ( 4 , 3 , 2 , 1 ) for (( index , value ) in ints . withIndex ()){ println ( \"$index:\\t$value\" ) } //字典for循环 val capitals = mapOf ( \"Paris\" to \"France\" , \"London\" to \"UK\" ) for (( capital , country ) in capitals ){ println ( \"${country}'s capital is $capital\" ) } } 2.5 when表达式 3. 函数 3.1 顶层函数(Top-Level Function) 谈论顶层函数之前需要先讨论package，如果没有指定package，就会放到默认包中。 package KotlinSamples.Functions fun say_hello (){ println ( \"Hello\" ) } import KotlinSamples.Functions.* fun main ( args : Array < String >) { say_hello () } 3.2 返回类型和参数(Return Types and Arguments) fun main ( args : Array < String >) { println ( \"4*3 is ${triple(4)}\" ) println ( \"4*4 is ${sqr(4)}\" ) println ( \"pay ${calculate_wages(160)}\" ) //命名参数 println ( \"pay ${calculate_wages(hourly_rate = 20.0)}\" ) } fun triple ( x : Int ): Int { return x * 3 } fun sqr ( x : Int ) = x * x //默认参数 fun calculate_wages ( hours : Int = 160 , hourly_rate : Double = 100.0 ): Double { return hours * hourly_rate } 3.3 可变长参数函数(Variable-Argument Functions) fun main ( args : Array < String >) { println ( \"result is ${sum_up(1, 3, 5)}\" ) println ( \"result is ${sum_up2(4, 5, 6)}\" ) //解包操作 val stuff = intArrayOf ( 1 , 2 , 3 ) println ( sum_up ( 3 , 5 , * stuff , 1 , 9 )) } //可变长参数 fun sum_up ( vararg values : Int ): Int { var result = 0 for ( v in values ){ result += v } return result } //函数式的解法 fun sum_up2 ( vararg values : Int ): Int { return values . sum () } 3.4 内签函数(Local a.k.a. Nested or Inner Functions) fun main ( args : Array < String >) { //解包赋值 val ( x1 , x2 ) = solve_quadratic_equation ( 1.0 , 10.0 , 16.0 ) println ( \"x1 = $x1, x2 = $x2\" ) } fun solve_quadratic_equation ( a : Double , b : Double , c : Double ): Pair < Double , Double > { fun calculate_discriminant (): Double { return b * b - 4 * a * c } val root_disc = Math . sqrt ( calculate_discriminant ()) return Pair ((- b + root_disc )/( 2 * a ), (- b - root_disc )/( 2 * a )) } 3.5 扩展函数和扩展属性(Extension Functions and Properties) import java.util.* fun main ( args : Array < String >) { extension_functions () } //扩展函数 fun < T > ArrayList < T >. swap ( index1 : Int , index2 : Int ){ //this指向实例 val temp = this [ index1 ] this [ index1 ] = this [ index2 ] this [ index2 ] = temp } //给所有的对象添加函数，用Any? fun Any ?. print (){ if ( this == null ) println ( \"Object is null\" ) else println ( \"Object is ${this.toString()}\" ) } //扩展函数 val String ?. empty : Boolean get () = ( this == null || this . length == 0 ) fun extension_functions (){ val mylist = arrayListOf ( 1 , 2 , 3 ) //调用扩展函数 mylist . swap ( 0 , 2 ) println ( mylist ) mylist . print () val s : String ? = null s . print () //调用扩展属性 println ( s . empty ) println ( \"\" . empty ) } 3.6 中缀函数(Infix Functions) fun main ( args : Array < String >) { infix_functions () } //定义中缀函数 infix fun Double . averageWith ( other : Double ): Double { //this是左边的运算符 return ( this + other ) / 2.0 } fun infix_functions (){ val x = 'z' downTo 'a' for ( a in x ) print ( \"$a\\t\" ) println () val capitals = mapOf ( \"Paris\" to \"France\" , \"London\" to \"UK\" ) for (( key , value ) in capitals ) println ( \"$key\\t$value\" ) println () //调用中缀函数 val a = 3.0 val b = 10.0 println ( \"The average of $a and $b is ${a averageWith b}\" ) } 4 Lambda函数 4.1 Lambda函数 package KotlinSamples.Lambda fun main ( args : Array < String >) { val product = { x : Int , y : Int -> x * y } println ( \"${product(2, 3)}\" ) //可以把签名放在前面 val product2 :( Int , Int )-> Int = { x , y -> x * y } println ( \"${product2(4, 6)}\" ) //lambda作为参数 val numbers = listOf ( 1 , 2 , 3 , 4 ) val n = numbers . count { it > 2 } //等价于number.count({x->x>2}) println ( n ) //闭包,kotlin中允许在lambda中修改外界的值 var sum = 0 numbers . forEach { sum += it } println ( \"sum of $numbers is $sum\" ) } 4.2 高阶函数 高阶函数是含有函数作为参数的函数，或者是返回值是函数的函数。 fun main ( args : Array < String >) { val numbers = listOf ( 7 , 1 , 3 , 4 ) val maxvalue = max ( numbers ) { x , y -> x < y } println ( maxvalue ) } fun < T > max ( collection : Collection < T >, less :( T , T )-> Boolean ): T ?{ var max : T ? = null for ( x in collection ){ if ( max == null || less ( max , x )) max = x } return max } 4.3 带接受者的函数类型 fun main ( args : Array < String >) { //Function type with receiver //类似扩展函数,但是只能作用于局部,而且这个函数是个lambda表达式,被存储在变量中 fun_type_with_recevier () //由于increaseBy是局部变量,因此下面的代码无法执行 //var y = 2 //y.increaseBy(10) } fun fun_type_with_recevier (){ //声明形式类似扩展函数,但是返回到变量中 val increaseBy = fun Int .( value : Int ) = this + value var x = 1 println ( \"$x + 3 = ${x.increaseBy(3)}\" ) } 4.4 Functors 不知道为什么，一直报错：Error:(10, 15) Kotlin: operator modifier is required on 'invoke' in 'Average' class Average { public fun invoke ( vararg values : Double ): Double { val sum = values . sum () return sum / values . size } } fun main ( args : Array < String >) { val a = Average () //functor val avg = a ( 1.0 , 2.0 , 3.0 ) println ( avg ) // fun String.invoke():String{ // return \"(\"+this+\")\" // } // val str = \"hello\" // println(\"${str()}\") } 5 类 5.1 属性(property) class Person { lateinit var name : String //如果不初始化,需要加lateinit var age : Int = - 1 val canVote : Boolean get () = age > 16 var ssn = \"00000\" get () = field set ( value ) { println ( \"$name's ssn is changed to $value\" ) field = value } } fun main ( args : Array < String >) { var me = Person () me . name = \"lixiang\" me . age = 28 println ( \"${me.name} can ${if (!me.canVote) \" not \" else \"\"}vote\" ) me . ssn = \"123456\" } 5.2 构造函数和初始化 //注意,class的构造中需要给参数带上var或者val才是添加属性 class Human ( var name : String , val age : Int ){ //初始化 init { println ( \"$name is $age\" ) } } fun main ( args : Array < String >) { var me = Human ( \"Lixiang\" , 28 ) println ( \"My name is ${me.name}, and my age is ${me.age}\" ) } 5.3 委托属性(Delegated Properties) package KotlinSample.demo3 import kotlin.properties.Delegates import kotlin.reflect.KProperty class Delegate { operator fun getValue ( thisRef : Any ?, property : KProperty <*>): String { return \"$thisRef, thank you for delegating '${property.name}' to me!\" } operator fun setValue ( thisRef : Any ?, property : KProperty <*>, value : String ){ println ( \"$value has been assigned to '${property.name}' in $thisRef\" ) } } class Person { //委托 var name : String by Delegate () //委托的一种用法,惰性 val lazyValue : String by lazy { println ( \"lazyValue初始化\" ) \"test\" } //委托的用法,通知,其中\"John\"是初始值 var othername : String by Delegates . observable ( \"John\" ) { prop , old , new -> println ( \"${prop.name} $old -> $new\" ) } } fun main ( args : Array < String >) { var p = Person () p . name = \"Lixiang\" val s = p . name println ( s ) //只求一次值 println ( p . lazyValue ) println ( p . lazyValue ) println ( p . lazyValue ) p . othername = \"Jack\" } 5.4 数据类(Data Classes) 数据类主要用来存储数据 package KotlinSample.demo4 //data class用来保存数据,他有以下几种方法 //equals()/hashCode() //toString() //copy() 深拷贝 //destructuring 解包操作 data class User ( val name : String , val age : Int ){ //你也可以重写 override fun toString (): String { return \"My name is $name, age is $age\" } } fun main ( args : Array < String >) { val a = User ( \"Lixiang\" , 20 ) println ( a ) val b = User ( \"Lixiang\" , 20 ) println ( a == b ) println ( a === b ) val c = a . copy () println ( c == a ) println ( c === a ) //解包 val ( name , age ) = c println ( \"$name, $age\" ) } 5.5 单例(Singleton) package KotlinSample.demo5 class PointFactory { fun NewCartersianPoint ( x : Double , y : Double ): Point { return Point ( x , y ) } fun NewPolarPoint ( rho : Double , theta : Double ): Point { return Point ( rho * Math . cos ( theta ), rho * Math . sin ( theta )) } } class Point ( val x : Double , val y : Double ) fun main ( args : Array < String >) { var pf = PointFactory () var point = pf . NewPolarPoint ( 3.0 , Math . PI / 2 ) print ( \"${point.x} ${point.y}\" ) } 5.6 伴随对象(Companion Objects) Kotlin中没有静态方法，使用伴随对象来实现类似静态方法的效果 package KotlinSample.demo6 interface IFactory < T > { fun create (): T } //注意,伴随对象并不是真正的static的 class Point ( var x : Double , var y : Double ){ //伴随对象,使用companion object修饰,其中Factory可以注释掉,也就是下面的代码也是可用的: //companion object { //伴随对象还能实现接口 companion object /* Factory */ : IFactory < Point >{ override fun create (): Point { return Point ( 0.0 , 0.0 ) } fun createCarterian ( x : Double , y : Double ): Point = Point ( x , y ) fun createPolar ( x : Double , y : Double ): Point = Point ( x , y ) } } fun main ( args : Array < String >) { var simplePoint = Point ( 1.0 , 2.0 ) //var factoryPoint = Point.Factory.createCarterian(1.0, 2.0) //类似静态方法的调用 var factoryPoint2 = Point . createPolar ( 1.0 , 2.0 ) var defaultPoint = Point . create () //或者如果没有给伴随对象起名字,也可以用下面这个方法 var defaultPoint2 = Point . Companion . create () } 5.7 继承(Inheritance) //只有open的class才能被继承 open class Person ( val name : String ){ //同样只有open方法才能被overwrite open fun talk (){ println ( \"I'm $name\" ) } } //父类已经有了name,所以不能再给这里的name添加val/var //Person有构造方法,因此必须对其进行调用 class Manager ( name : String , var subordinates : List < Person >) : Person ( name ){ //重写方法 override fun talk (){ println ( \"I'm $name, I have ${subordinates.size} subordinates\" ) } } fun main ( args : Array < String >) { val lixiang = Person ( \"理想\" ) lixiang . talk () val boss = Manager ( \"龙\" , listOf ( lixiang )) boss . talk () } 5.8 接口(Interfaces) 5.9 类委托(Class Delegation) 6 其他 6.1 枚举(Enumerations) 6.2 异常(Exceptions) 6.3 操作符重载(Operator Overloads) 6.4 Type-Safe Builders","tags":"Java","url":"/kotlinxue-xi-bi-ji.html"},{"title":"MySQL常用","text":"本文将持续更新。 1. Mac上安装后需要配置的PATH export PATH= $ PATH :/usr/local/mysql/bin 2. Python使用MySQL Python中有5种常见客户端可连接MySQL. 2.1 MySQLdb 最早的，使用C语言写成，但是不支持Python3 2.2 mysql-connector-python https://pypi.python.org/pypi/mysql-connector-python/ 这个是Oracle官方支持的，是纯Python编写的，但是有点慢，而且不兼容 MySQLdb 2.3 pymysql （推荐） https://pypi.python.org/pypi/PyMySQL 它是一个纯Python的客户端，并且支持Python3.兼容 MySQLdb 2.4 CyMySQL https://github.com/nakagami/CyMySQL 它是 PyMySQL 的一个fork，使用Cython进行了加速，并且支持Python3。 2.5 mysqlclient （Django官方推荐） https://pypi.python.org/pypi/mysqlclient mysqlclient 是 MySQLdb 的一个fork，能够直接代替 MySQLdb ，并且支持Python3，是Django官方推荐的选择。 目前来讲， pymysql 使用的人最多。 3. 使用root用户 3.1 并且修改root密码 mysql -u root #进入mysql #或者已经有密码了 mysql -u root -p 密码 #修改密码 mysql>update mysql.user set password=PASSWORD('123456') where User='root' 但是，在MySQL5.6之后，这么更改用户会出错： ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement 这个时候的做法是： SET PASSWORD = PASSWORD('your new password'); ALTER USER 'root'@'localhost' PASSWORD EXPIRE NEVER; flush privileges; 参考：https://dev.mysql.com/doc/refman/5.6/en/alter-user.html 3.2 退出 exit;","tags":"Database","url":"/mysqlchang-yong.html"},{"title":"React使用笔记(4)-React状态和属性详解","text":"1. 属性的含义和用法 1.1 属性赋值 <HelloWorld name=\"?\"><HelloWorld> 中属性的值可以有以下几种形式： \"Tom\" 字符串 {123} 字符 {\"Tom\"} 等同于第一种方法 {[1, 2, 3]} 数组，属性接收的也是数组，这样就能做一些类似 checkbox 的事情了 {variable or function} 对象或者函数 还有一种写法，叫做 展开语法 ，用3个点加对象名来实现： var props = { one: \"123\", two: 321 }; <Hello {...props}/> 还有一种不常用的方法 setProps : var instance = React.render( <HelloWorld></HelloWorld> , document.body); instance.setProps({name:\"Tom\"}); 2. 状态的含义和用法 getInitialState : 初始化每个实例特有的状态。 setState : 更新组件状态 3. 属性和状态的对比 -- 属性 状态 能否从父组件获取初始值 能 否 能否由父组件修改 能 否 能否在组件内部设置默认值 能 能 能否在组件内部修改 否 能 能否设置子组件的初始值 能 否 能否修改子组件的值 能 否 记住一点：组件在运行时， 需要修改 的数据就是状态。 4. 实战：文章评论框 首先我们先写个框架： <script type= \"text/jsx\" > var Content = React.createClass({ render: function(){ return <p> content </p> ; }, }); var Comment = React.createClass({ render: function(){ return <Content></Content> }, }); React.render( <Content ></Content> , document.body); </script> 然后我们动态设置一个下拉框： var Comment = React.createClass({ getInitialState: function(){ return { name: [\"Tim\", \"Hank\", \"John\"] }; }, render: function(){ var options = []; for (var i = 0; i < this.state.name.length ; i++) { options.push(<option value= {i} > {this.state.name[i]} </option> ); }; return <div> <select> {options} </select> <Content></Content> </div> ; }, }); 为了获取被选中的值，我们添加一个 selectName 的 state ，并且在select下拉选择改变时，设置 selectName ，并且将这个值传递给 Comment ： var Content = React.createClass({ render: function(){ return <p> {this.props.selectName} </p> ; }, }); var Comment = React.createClass({ getInitialState: function(){ return { name: [\"Tim\", \"Hank\", \"John\"], selectName: '' }; }, handleSelect: function(event){ this.setState({selectName: event.target.value}); }, render: function(){ var options = []; for (var i = 0; i < this.state.name.length ; i++) { options.push(<option value= {i} > {this.state.name[i]} </option> ); }; return <div> <select onChange= {this.handleSelect} > {options} </select> <Content selectName= {this.state.selectName} ></Content> </div> ; }, }); 然后我们给 Comment 添加一个 <textarea> ，用来输入评论。 var Content = React.createClass({ getInitialState: function () { return { text: \"reply to: \"+ this.props.selectName, }; }, render: function(){ return <div> <textarea placeholder= \"please enter something\" ></textarea> </div> ; }, }); 下一步，我们监听文本框的变化，并把变化记录在 state 中。 var Content = React.createClass({ getInitialState: function () { return { inputText: \"\" }; }, handleChange: function (event) { this.setState({inputText: event.target.value}); }, handleSubmit: function (event) { console.log(\"reply to: \"+ this.props.selectName+\"\\n\"+this.state.inputText); }, render: function(){ return <div> <textarea onChange= {this.handleChange} placeholder= \"please enter something\" ></textarea> <button onClick= {this.handleSubmit} > submit </button> </div> ; }, }); 这里有一个bug，就是 getInitialState 只执行一次，当父组件给其传递值之后，这个函数不会再被调用，这是常见的一个问题，即把需要计算的属性放在 getInitialState 中，常见的做法是把需要计算的动作放在最后。 我们对代码进行修改， 我们移除状态，并直接再需要用到属性的地方直接引用。 getInitialState : function () { return { inputText : \"\" }; }, handleSubmit : function ( event ) { console . log ( \"reply to: \" + this . props . selectName + \"\\n\" + this . state . inputText ); }, 我们再说一遍，把真正需要计算的值放在需要用到的地方。","tags":"Web","url":"/reactshi-yong-bi-ji-4-reactzhuang-tai-he-shu-xing-xiang-jie.html"},{"title":"Python数据分析(3)-DataFrame","text":"1. DataFrame 简介 Series 是一维序列，而 DataFrame 是一种二维表结构，它包含一组类似于 index 的有序列，每列可以是不同的值。因此可以把 DataFrame 看作是共享同一个 index 的 Series 集合。 2. DataFrame 的创建 创建 DataFrame 的方法与 Series 类似。并且自带index,也可以指定index。 In [ 1 ]: import pandas as pd In [ 2 ]: data = { 'name' : [ 'Wangdachui' , 'Linling' , 'Niuyun' ], 'pay' :[ 4000 , 5000 , 6000 ]} In [ 3 ]: frame = pd . DataFrame ( data ) In [ 4 ]: frame Out [ 4 ]: name pay 0 Wangdachui 4000 1 Linling 5000 2 Niuyun 6000 3. DataFrame 的基本操作 In [ 5 ]: frame [ 'name' ] #列明 Out [ 5 ]: 0 Wangdachui 1 Linling 2 Niuyun Name : name , dtype : object In [ 6 ]: frame . pay #列名 Out [ 6 ]: 0 4000 1 5000 2 6000 Name : pay , dtype : int64 In [ 7 ]: frame . ix [ 2 ] #获取某一行，从0开始 Out [ 7 ]: name Niuyun pay 6000 Name : 2 , dtype : object 取 DataFrame 对象的列和行可获得 Series DataFrame 对象的修改和删除 In [ 8 ]: frame [ 'name' ] = 'admin' #修改列名 In [ 9 ]: frame Out [ 9 ]: name pay 0 admin 4000 1 admin 5000 2 admin 6000 In [ 10 ]: del frame [ 'pay' ] #删除列 In [ 11 ]: frame Out [ 11 ]: name 0 admin 1 admin 2 admin 4. DataFrame 的 name 属性 In [ 12 ]: data = { 'name' : [ 'Wangdachui' , 'Linling' , 'Niuyun' ], 'pay' :[ 4000 , 5000 , 6000 ]} In [ 13 ]: frame = pd . DataFrame ( data ) In [ 14 ]: frame Out [ 14 ]: name pay 0 Wangdachui 4000 1 Linling 5000 2 Niuyun 6000 In [ 15 ]: frame . index . name = 'No' #设置index的name属性 In [ 16 ]: frame Out [ 16 ]: name pay No 0 Wangdachui 4000 1 Linling 5000 2 Niuyun 6000 作者：liulixiang1988#gmail.com (#换成@) 参考链接：https://www.coursera.org/learn/hipython/home/welcome","tags":"Python","url":"/pythonshu-ju-fen-xi-3-dataframe.html"},{"title":"Python数据分析(2)-变长字典Series","text":"我们知道字典是一种无序的数据结构，而pandas中的 Series 的数据结构不一样，它相当于定长有序的字典，并且它的index和value之间是独立的。 1. Series 的创建 Series 的基本特征 类似一维数组的对象 由数据和索引组成 Series 的创建： In [ 1 ]: import pandas as pd In [ 2 ]: aSer = pd . Series ([ 1 , 2.0 , 'a' ]) In [ 3 ]: aSer Out [ 3 ]: 0 1 1 2 2 a dtype : object 我们可以看到 Series 自带索引，当然我们还可以指定索引： In [ 4 ]: bSer = pd . Series ([ 'apple' , 'peach' , 'lemon' ], index = [ 1 , 2 , 3 ]) In [ 5 ]: bSer Out [ 5 ]: 1 apple 2 peach 3 lemon dtype : object In [ 7 ]: bSer . index #查看index Out [ 7 ]: Int64Index ([ 1 , 2 , 3 ], dtype = 'int64' ) In [ 8 ]: bSer . values #查看values Out [ 8 ]: array ([ 'apple' , 'peach' , 'lemon' ], dtype = object ) 2. Series 的基本运算 Series 与字典类似，可以通过 index 来访问数据。 In [ 10 ]: aSer = pd . Series ([ 3 , 5 , 7 ], index = [ 'a' , 'b' , 'c' ]) In [ 11 ]: aSer [ 'b' ] Out [ 11 ]: 5 In [ 12 ]: aSer * 2 #对基本元素进行运算 Out [ 12 ]: a 6 b 10 c 14 dtype : int64 In [ 13 ]: import numpy as np In [ 14 ]: np . exp ( aSer ) #计算自然对数的n次方 Out [ 14 ]: a 20.085537 b 148.413159 c 1096.633158 dtype : float64 3. Series 的数据对齐 数据对齐是很多数据处理软件里面里都有的一个功能，比如Excel。就是有一个表，前面是索引，后面是数据，可能索引没有对应的数据，也就是那一行为空的，只有一个索引值 In [ 15 ]: data = { 'AXP' : '86.40' , 'CSCO' : '122.64' , 'BA' : '99.44' } In [ 16 ]: sindex = [ 'AXP' , 'CSCO' , 'BA' , 'AAPL' ] In [ 17 ]: aSer = pd . Series ( data , index = sindex ) #注意这里是用字典来定义的，跟前面的list定义不一样 In [ 18 ]: aSer Out [ 18 ]: AXP 86.40 CSCO 122.64 BA 99.44 AAPL NaN dtype : object In [ 19 ]: pd . isnull ( aSer ) #检测哪些值是空的 Out [ 19 ]: AXP False CSCO False BA False AAPL True dtype : bool 在算术运算中，可以自动对齐不同索引的数据，注意，只要其中一个 Series 不存在对应的 index ，对应的结果就会为 NaN ： In [ 20 ]: aSer = pd . Series ( data , index = sindex ) In [ 21 ]: aSer Out [ 21 ]: AXP 86.40 CSCO 122.64 BA 99.44 AAPL NaN dtype : object In [ 22 ]: bSer = { 'AXP' : '86.40' , 'CSCO' : '122.64' , 'CVX' : '23.78' } In [ 23 ]: cSer = pd . Series ( bSer ) In [ 24 ]: aSer + cSer Out [ 24 ]: AAPL NaN AXP 86.4086 . 40 BA NaN CSCO 122.64122 . 64 CVX NaN dtype : object 4. Series 的 name 属性 Series 对象本身及其索引均有一个 name 属性，并且 Series 的 name 属性与其他重要功能有密切关系。 In [ 27 ]: aSer = pd . Series ( data , index = sindex ) In [ 28 ]: aSer . name = 'cnames' #指定对象的name属性 In [ 29 ]: aSer . index . name = 'valume' #指定索引本身的name属性 In [ 30 ]: aSer Out [ 30 ]: valume AXP 86.40 CSCO 122.64 BA 99.44 AAPL NaN Name : cnames , dtype : object name 属性有些像Excel中的字段名称有些像，在后期有很重要的作用。 作者：liulixiang1988#gmail.com (#换成@) 参考链接：https://www.coursera.org/learn/hipython/home/welcome","tags":"Python","url":"/pythonshu-ju-fen-xi-2-bian-chang-zi-dian-series.html"},{"title":"Python数据分析(1)-NumPy中的ndarray","text":"ndarray 是NumPy中的基本数据机构，别名 array ，利于节省内存和提高CPU计算时间，提供了丰富的函数。 1. ndarray 创建函数 函数 函数 arange array empty_like empty fromfile fromfunction identity linespace logspace mgrid ogrid ones ones_like r zeros zeros_like from numpy import * aArray = array ([ 1 , 2 , 3 ]) #一维数组 aArray Out [ 9 ]: array ([ 1 , 2 , 3 ]) bArray = array ([( 1 , 2 , 3 ), ( 4 , 5 , 6 )]) #二维数组 bArray Out [ 11 ]: array ([[ 1 , 2 , 3 ], [ 4 , 5 , 6 ]]) zeros (( 2 , 2 )) #全0 Out [ 12 ]: array ([[ 0. , 0. ], [ 0. , 0. ]]) arange ( 1 , 5 , 0.5 ) #间隔0.5的数组 Out [ 13 ]: array ([ 1. , 1.5 , 2. , 2.5 , 3. , 3.5 , 4. , 4.5 ]) 2. ndarray 的基本运算符 >>> from numpy import * >>> aArray = array ([( 5 , 5 , 5 ), ( 5 , 5 , 5 )]) >>> bArray = array ([( 2 , 2 , 2 ), ( 2 , 2 , 2 )]) >>> cArray = aArray * bArray >>> cArray array ([[ 10 , 10 , 10 ], [ 10 , 10 , 10 ]]) >>> aArray += bArray >>> aArray array ([[ 7 , 7 , 7 ], [ 7 , 7 , 7 ]]) >>> aArray > 5 #每个元素是否大于5 array ([[ True , True , True ], [ True , True , True ]], dtype = bool ) 3. ndarray 内建函数和标准函数 >>> aArray = array([(1, 2, 3), (4, 5, 6)]) >>> sin(aArray) #求array中的每个sin值 array([[ 0.84147098, 0.90929743, 0.14112001], [-0.7568025 , -0.95892427, -0.2794155 ]]) >>> aArray.shape #形状 (2, 3) >>> bArray = aArray.reshape(3, 2) #更改形状 >>> bArray array([[1, 2], [3, 4], [5, 6]]) >>> aArray.sum() #求全部的和 21 >>> aArray.sum(axis=0) #纵向求和 array([5, 7, 9]) >>> aArray.sum(axis=1) #横向求和 array([ 6, 15]) >>> cArray = array([1, 3, 5]) >>> cArray[:1] #切片 array([1]) >>> dArray = array([2, 4, 6]) >>> eArray = array([7, 8, 9]) >>> where(cArray > 2, dArray, eArray) #对每个元素运行相当于if else运算 array([7, 4, 6]) 3.1 fromfunction 函数 fromfunction 第一个参数是函数名，第二个参数是数字大小，序列是从0开始。下面打印一个九九乘法表： In [9]: def fun(x, y): ...: return (x+1)*(y+1) ...: In [10]: arr = fromfunction(fun, (9, 9)) In [11]: arr Out[11]: array([[ 1., 2., 3., 4., 5., 6., 7., 8., 9.], [ 2., 4., 6., 8., 10., 12., 14., 16., 18.], [ 3., 6., 9., 12., 15., 18., 21., 24., 27.], [ 4., 8., 12., 16., 20., 24., 28., 32., 36.], [ 5., 10., 15., 20., 25., 30., 35., 40., 45.], [ 6., 12., 18., 24., 30., 36., 42., 48., 54.], [ 7., 14., 21., 28., 35., 42., 49., 56., 63.], [ 8., 16., 24., 32., 40., 48., 56., 64., 72.], [ 9., 18., 27., 36., 45., 54., 63., 72., 81.]]) 3.2 ufunc 函数 ufunc (universal function)是一种能对数组的每个元素进行操作的函数。NumPy内置的许多ufunc函数都是在C语言级别实现的，计算速度非常快。 可以通过 help(ufunc) ， help(numpy) 来查看有哪些 ufunc 函数。 In [14]: a = np.arange(1, 5) In [15]: a Out[15]: array([1, 2, 3, 4]) In [16]: help(ufunc) In [17]: b = np.arange(2, 6) In [18]: b Out[18]: array([2, 3, 4, 5]) In [19]: np.add(a, b) Out[19]: array([3, 5, 7, 9]) In [20]: np.add.accumulate([2, 3, 8]) Out[20]: array([ 2, 5, 13]) In [21]: np.multiply.accumulate([2, 3, 8]) Out[21]: array([ 2, 6, 48]) 作者：liulixiang1988#gmail.com (#换成@) 参考链接：https://www.coursera.org/learn/hipython/home/welcome","tags":"Python","url":"/pythonshu-ju-fen-xi-1-numpyzhong-de-ndarray.html"},{"title":"React使用笔记(3)-React Event Listener","text":"1. 构造基本结构 首先，我们先创建一个按钮，一个输入框。我们准备点击按钮时，后面有一个 <span> 显示和隐藏。代码如下： <div id= \"container\" ></div> <script type= \"text/jsx\" > var TestClickComponent = React.createClass({ render: function(){ return ( <div> <button> 显示|隐藏 </button> <span> 测试点击 </span> </div> ); } }); var TestInputComponent = React.createClass({ getInitialState: function(){ return { inputContent: '' } }, render: function(){ return ( <div> <input type= \"text\" /><span> {this.state.inputContent} </span> </div> ); } }); React.render( <div> <TestClickComponent /> <TestInputComponent /> </div> , document.getElementById('container')); </script> 这里有几点需要注意，在 render 里返回的时候，需要用个 <div> 包裹起来，因为每个里面有好几html标签。 2. 给 <button> 添加事件绑定 用驼峰式命名的方式来绑定事件，比如 onClick 。注意这里的 onClick 事件和原生HTML属性中的 onclick 不是一回事儿。这里，它并不是一个真事的DOM节点，它只是一个React Element，而且写法也不一样，HTML标签的属性对于大小写是不敏感的，而React Element对于大小写是敏感的。 onClick 的处理函数一般通过对象属性封装在React组件的对象实例上。 var TestClickComponent = React.createClass({ handleClick: function(event){ }, render: function(){ return ( <div> <button onClick= {this.handleClick} > 显示|隐藏 </button> <span> 测试点击 </span> </div> ); } }); handleClick 函数的参数是React封装的 event 对象。这个 event 对象是在原生的js的 event 对象的基础上封装的，因此，我们可以调用一些在原生js的 event 对象上的方法： handleClick : function ( event ){ event . stopPropagation (); event . preventDefault (); } 我们如何在 event 事件处理函数内处理 <span> 呢，我们通过给 <span> 添加一个 ref 属性，然后就能在 this.refs 中获取这个对象了。 <span ref= \"tip\" > 测试点击 </span> 注意，我们使用 this.refs.tip 引用的并不是真实的DOM节点，而是React组件。我们要操作DOM节点该怎么办呢？使用React给我们封装的方法 React.findDOMNode ，参数就是我们的React组件。 handleClick : function ( event ){ var tipE = React . findDOMNode ( this . refs . tip ) if ( tipE . style . display === 'none' ){ tipE . style . display = 'inline' ; } else { tipE . style . display = 'none' ; } event . stopPropagation (); event . preventDefault (); } 3. 给 <input> 添加事件绑定 我们给 <input> 添加 onChange 事件，这里我们使用 event.target.value 来获取 <input> 的值，然后设置 state ，对应的 <span> 的内容就会跟着改变。 changeHandler: function(event){ this.setState({ inputContent: event.target.value }); event.preventDefault(); event.stopPropagation(); }, render: function(){ return ( <div> <input type= \"text\" onChange= {this.changeHandler}/ ><span> {this.state.inputContent} </span> </div> ); } 4. 非DOM属性 非DOM属性 - dangerouslySetInnerHTML : 在JSX中直接插入HTML代码； - ref :前面已经提过，父组件引用子组件； - key :提高渲染性能。 5. 事件列表 5.1 触摸事件 只在移动端可用 onTouchCancel onTouchEnd onTOuchMove onTouchStart 5.2 键盘类事件 onKeyDown onKeyPress : onKeyDown 和 onKeyUp 的组合 onKeyUp 5.3 剪切类事件 目前支持的不是特别好，使用的不多。 onCopy onCut onPaste 5.4 表单类事件 onChange :输入框、单选框、下拉列表 onInput :文字输入 onSubmit :表单提交，通过这个事件可以禁用默认跳转 5.5 焦点事件 onFocus onBlur 5.6 UI元素事件 onScroll :UI元素的滚动事件 5.7 滚动事件 onWheel : 鼠标滚动事件，可以监听鼠标的滚动幅度，滚动方位 5.8 鼠标事件 onClick onContextMenu :右键，上下文菜单 onDoubleClick onMouseDown onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp 另外拖拽事件 onDrop onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart 6. 事件对象介绍 前面我们介绍过，事件对象是对原生事件对象的封装，下面我们来看看事件对象的一些属性。 6.1 通用属性 boolean bubbles :是否可以冒泡 boolean cancelable :是否可以取消事件 DOMEventTarget currentTarget boolean defaultPrevented :事件是否禁止了默认行为 number eventPhase : 事件所处的阶段 boolean isTrusted : 事件是否可信，用户的事件可信，JS代码触发的事件不可信 DOMEvent nativeEvent : 原生浏览器事件，没经过 void preventDefault() : 禁止默认行为 void stopPropagation() : 禁止冒泡 DOMEventTarget target : number timeStamp : 事件的时间 string type : 事件类型 6.2 特有属性 剪切事件： DOMDataTransfer clipboardData : 剪切的一些数据 键盘事件： boolean altKey : Number charCode :字符编码（ABCD) boolean ctrlKey function getModifierState(key) :辅助案件(ctrl shift等) String key Number keyCode :按键编码 String locale Number location :位置 boolean metaKey :win和cmd boolean repeat :是否重复 boolean shiftKey Number which : charCode 和 keyCode 的统一 焦点事件： DOMEventTarget relatedTarget : AB控件切换时，他们互为 relatedTarget 鼠标事件： boolean altKey Number button Number buttons Number clientX :浏览器窗框的左上角是(0,0) Number clientY boolean ctrlKey function getModifierState(key) boolean metaKey Number pageX :HTML页面的左上角(0,0) Number pageY DOMEventTarget relatedTarget Number screenX :显示器的左上角 Number screenY boolean shiftKey 触摸事件： boolean altKey boolean ctrlKey function getModifierState(key) boolean metaKey boolean shiftKey DOMTouchList changedTouches : DOMTouchList 触摸事件特有类型 DOMTouchList targetTouches : DOMTouchList touches : UI元素： Number detail :滚动的距离 DOMAbstractView view 鼠标滚动： Number deltaMode ：单位 Number deltaX ：x,y,z轴移动距离 Number deltaY Number deltaZ 7. 实例演练 7.1 使用滚动事件对象 鼠标滚轮的数值可以当做RGB值使用 <script type= \"text/jsx\" > var Hello = React.createClass({ getInitialState: function () { return { background: '#FFFFFF' }; }, handleWheel: function (event) { //this.state.background.substr(1)：忽略掉第一个\"#\" //deltaY:是+3或者-3 var newColor = (parseInt(this.state.background.substr(1), 16) + event.deltaY * 977).toString(16); newColor = '#' + newColor.substr(newColor.length-6).toUpperCase(); this.setState({background: newColor}); }, render: function(){ console.log(this.state); return <div onWheel= {this.handleWheel} style= {this.state} ><p> Hello world </p></div> ; } }); React.render( <Hello/> , document.getElementById('container')); </script> 7.2 键盘事件 var Hello = React.createClass({ getInitialState: function () { return { password: '' }; }, handleKeyPress: function (event) { this.setState({password: this.state.password+event.which}); console.log(this.state); }, handleChange: function(event){ event.target.value = ''; }, render: function(){ console.log(this.state); return <div> <input type= \"text\" onKeyPress= {this.handleKeyPress} onChange= {this.handleChange} /> <p style= {{ 'display' : this.state.password.indexOf ( '495051' ) >= '0' ? 'inline' : 'none' }} > you got it!</p > </div> ; } }); 8. 事件和状态关联 handleChange : function ( event ){ this . setState ({ inputText : event . target . value }); } 作者：liulixiang1988#gmail.com (#换成@) 参考链接：http://www.imooc.com/learn/504","tags":"Web","url":"/reactshi-yong-bi-ji-3-react-event-listener.html"},{"title":"React使用笔记(2)-React Components的生命周期","text":"1. React Components的生命周期 React Components的3种状态： Mounted:React Component被render解析，生成对应的DOM节点，并被插入浏览器的DOM结构的过程。这个过程结束了就是这个组件被 Mounted 了。 Update:一个被mounted的React Component被重新render的过程。 Unmounted:一个被mounted的React Component对应的DOM节点被从DOM结构中移除的这样一个过程。 每一个状态React都封装了对应的hook函数。 2. React Components生命周期中的hook函数 2.1 实验，来添加mount的hook函数 getDefaultProps :只调用一次，只有在组件的第一个实例被初始化时才被调用，用于实例之间 共享引用 ，它返回的是引用，而不是值。在 var Hello = React.createClass({...}) 执行时， getDefaultProps 就会被调用。 getInitialState :初始华每个实例特有的 状态 。 componentWillMount :它是渲染之前最后一次修改状态的机会。 render :只能访问 this.state 和 this.props ，只有一个顶层组件， 不允许 修改状态和DOM输出。 componentDidMount ：成功render并渲染完成真实DOM之后触发， 可以修改 DOM。 我们使用 getInitialState , componentWillMount , componentDidMount 来添加React Component在Mount阶段的hook函数，其中 getIntialState 返回一个键值对对象。 <div id= \"container\" ></div> <script type= \"text/jsx\" > var Hello = React.createClass({ getInitialState: function(){ alert(\"getInitialState\"); return { opacity: 1.0, fontSize: '20px' } }, render: function(){ return <div style= {{ color :'red' }} > Hello, {this.props.name}</div > ; }, componentWillMount: function(){ alert(\"component will mount\"); }, componentDidMount: function(){ alert(\"component did\"); } }); React.render( <Hello name= \"world\" /> , document.getElementById(\"container\")); </script> getIntialState 返回的对象如何使用呢，使用 {this.state} 就可以了: render: function(){ return <div style= {this.state} > Hello, {this.props.name} </div> ; } 这里 state 中都是合法有效的键值，如果不是的话需要这样用： render: function(){ return <div style= {{ opacity : this.state.opacity , fontSize : this.state.fontSize }} > Hello, {this.props.name}</div > ; } props 和 state 的区别是什么呢？ props 是属于调用者的，而 state 是属于当前组件的。 2.2 如何修改state呢？ 我们调用 setState ，比如我们在组件mount后一秒更改 state ，我们这样： componentDidMount : function (){ var _self = this ; window . setTimeout ( function (){ _self . setState ({ opacity : 0.5 , fontSize : '44px' }); }, 1000 ); } 这里对 var _self = this 进行说明： this 指的是调用函数的那个对象，也就是函数的所有者，而 setTimeout 中的 function 并不属于任何对象，它只是一个纯粹的函数调用，所以属于全局对象，这种情况下， this 是 global ，因此我们为了调用组件对象，需要使用 var _self = this 的这种方法。 既然说到了 this ，我们不妨多讲一些 this 的使用情况，比如： 我们把函数当做构造函数来使用，这种情况下， this 就是指构造函数生成的对象： function test(){ this.x = 1; } var o = new test(); 还有一种则是调用函数的 apply , call , bind 等方法，其作用是改变函数的调用对象，它们的第一个参数就是改变后的调用这个函数的对象，因此这种情况下， this 指的就是第一个参数所代表的对象。因此，刚才的例子可以这样写，让 function 里面的 this 指向 function 外面的 this 。 componentDidMount : function (){ window . setTimeout ( function (){ this . setState ({ opacity : 0.5 , fontSize : '44px' }); }. bind ( this ), 1000 ); } 注意， bind 是从ES5才开始有的，早期的IE不支持。 通过现象看本质，我们发现，每次组件的 state 发生变化都会导致组件进入 update 阶段，从而重新render。注意，我们并没有显式的修改组件的样式，而是 state 的值变了之后，样式就跟着改变了。 2.3 Update阶段 我们看开始的图，可以看到： componentWillReceiveProps :当一个 mounted 的组件将要接收新的 property 时，此函数会被调用，其函数参数就是新的 props 对象。我们可以在函数体内比较这个 props 参数和 this.props ，从而执行一些例如修改 state 这样的操作。 shouldComponentUpdate : 在一个 mounted 的组件已经接收到新的 state 和 props 对象之后，判断是否有必要去更新DOM结构。这个函数的参数有2个，一个就是新的 props 对象，第二个参数是新的 state 对象。我们可以分别对比其跟 this.props 和 this.state 来决定是否需要更新DOM结构。返回 true 表示更新，返回 false 表示不更新。 componentWillUpdate : 组件更新前调用， 不能 修改属性状态。 compoentDidUpdate : 组件更新后调用，可以修改DOM。 一般我们很少会更新上面的4个函数。 <script type= \"text/jsx\" > var HelloWorld = React.createClass({ componentWillReceiveProps: function(){ console.log(\"1\"); }, shouldComponentUpdate: function(){ console.log(\"2\"); return true }, componentWillUpdate: function(){ console.log(\"3\"); }, render: function(){ console.log(\"4\"); return <div> Hello, {this.props.name || \"world\"} </div> ; }, componentDidUpdate: function(){ console.log(\"5\"); } }); var HelloUniverse = React.createClass({ getInitialState: function(){ return {name: ''}; }, handleChange: function(event){ this.setState({name: event.target.value}); }, render: function(){ return <div> <HelloWorld name= {this.state.name} ></HelloWorld> <br/> <input type= \"text\" onChange= {this.handleChange} /> </div> ; } }); React.render( <HelloUniverse ></HelloUniverse> , document.getElementById('container')); </script> 2.4 Unmounting阶段 当我们要把一个组件销毁掉的时候，则是 unmounting 阶段了，它只有一个调用函数： componentWillUnmount :我们在这个函数内执行一些clean up的操作，比如释放内存、图片等。得益于浏览器的垃圾回收机制，我们基本不需要使用这个函数。 第一种Unmount的方法，是直接通过 render 的返回值来删除。 <script type= \"text/jsx\" > var HelloWorld = React.createClass({ render: function(){ console.log(\"4\"); return <div> Hello, {this.props.name || \"world\"} </div> ; }, componentWillUnmount: function(){ console.log(\"component will unmount!\"); } }); var HelloUniverse = React.createClass({ getInitialState: function(){ return {name: ''}; }, handleChange: function(event){ this.setState({name: event.target.value}); }, render: function(){ if (this.state.name === '123') { return <div> {this.state.name} </div> ; }; return <div> <HelloWorld name= {this.state.name} ></HelloWorld> <br/> <input type= \"text\" onChange= {this.handleChange} /> </div> ; } }); React.render( <HelloUniverse ></HelloUniverse> , document.getElementById('container')); </script> 第二种方法是使用React提供的 React.unmountComponentAtNode 方法来删除： <script type= \"text/jsx\" > var HelloWorld = React.createClass({ render: function(){ console.log(\"4\"); return <div> Hello, {this.props.name || \"world\"} </div> ; }, componentWillUnmount: function(){ console.log(\"component will unmount!\"); } }); var HelloUniverse = React.createClass({ getInitialState: function(){ return {name: ''}; }, handleChange: function(event){ if (event.target.value == '123') { React.unmountComponentAtNode(document.getElementsByTagName(\"body\")[0]); return; } this.setState({name: event.target.value}); }, render: function(){ return <div> <HelloWorld name= {this.state.name} ></HelloWorld> <br/> <input type= \"text\" onChange= {this.handleChange} /> </div> ; } }); React.render( <HelloUniverse ></HelloUniverse> , document.getElementById('container')); </script>","tags":"Web","url":"/reactshi-yong-bi-ji-2-react-componentsde-sheng-ming-zhou-qi.html"},{"title":"React使用笔记-React的JSX和Style","text":"1. 文件基本结构 <!DOCTYPE html> < html > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < title ></ title > < link rel = \"stylesheet\" href = \"\" > <!--react.js--> < script src = \"js/react.js\" ></ script > <!--解析JSX--> < script src = \"js/JSXTransformer.js\" ></ script > </ head > < body > < div id = \"container\" ></ div > <!--JSX的声明需要是type=\"text/jsx\"--> < script type = \"text/jsx\" > var Hello = React . createClass ({ render : function (){ return < div > Hello , { this . props . name } < /div>; } }); React . render ( < Hello name = \"world\" /> , document . getElementById ( 'container' )); </ script > </ body > </ html > 注意：JSX的type是 text/jsx . 2. 添加样式 2.1 使用外部CSS样式 注意，在JSX中不能直接给components添加 class ，因为 class 在ES6中是关键字，并且在ES6之前也是保留字，使用 className 来代替。 <script type= \"text/jsx\" > var Hello = React.createClass({ render: function(){ return <div className= \"alert-text\" > Hello, {this.props.name} </div> ; } }); React.render( <Hello name= \"world\" /> , document.getElementById('container')); </script> 2.2 使用内联CSS样式 JSX中内联样式需要使用字典来表示，并且使用驼峰命名法代替原有的 font-size 等格式的样式，比如 fontSize 来代替 font-size 等。 注意 ，如果样式出现错误，可以通过控制台来查看错误。 <script type= \"text/jsx\" > var Hello = React.createClass({ render: function(){ return <div style= {{ color :'red' }} > Hello, {this.props.name}</div > ; } }); React.render( <Hello name= \"world\" /> , document.getElementById('container')); </script> style={{color:'red'}} 中有两个括号，可能会让人看着发晕，其实它与下面是等价的 var styleObj = { color : 'red' } ; style = { styleObj } 3. 条件判断的4种写法 现在假设我们要写一个页面，如果属性中有 name ，就输出 Hello, name ，如果 name 为空，就输出 Hello, world 。 3.1 三元表达式 类似C语言的三元表达式。 <script type= \"text/jsx\" > var Hello = React.createClass({ render: function(){ return <div> Hello, {this.props.name ? this.props.name: \"world\"} </div> ; } }); React.render( <Hello name= \"liulx\" /> , document.getElementById('container')); </script> 3.2 使用变量 <script type= \"text/jsx\" > var Hello = React.createClass({ getName: function(){ if (this.props.name) { return this.props.name; } else{ return \"world\" }; }, render: function(){ var name = this.getName(); return <div> Hello, {name} </div> ; } }); React.render( <Hello name= \"liulx\" /> , document.getElementById('container')); </script> 3.3 直接调用函数 这个跟第二种方法类似，就是把大括号去掉。 <script type= \"text/jsx\" > var Hello = React.createClass({ getName: function(){ if (this.props.name) { return this.props.name; } else{ return \"world\" }; }, render: function(){ return <div> Hello, {this.getName()} </div> ; } }); React.render( <Hello name= \"liulx\" /> , document.getElementById('container')); </script> 3.4 使用比较运算符 <script type= \"text/jsx\" > var Hello = React.createClass({ render: function(){ return <div> Hello, {this.props.name || \"World\"} </div> ; } }); React.render( <Hello name= \"liulx\" /> , document.getElementById('container')); </script> 4. 函数表达式 <script type= \"text/jsx\" > var Hello = React.createClass({ render: function(){ return <div> Hello, { (function(obj){ if (obj.props.name) { return obj.props.name; } else { return \"world\"; } })(this) } </div> ; } }); React.render( <Hello name= \"liulx\" /> , document.getElementById('container')); </script>","tags":"Web","url":"/reactshi-yong-bi-ji-reactde-jsxhe-style.html"},{"title":"使用wfastcgi在IIS上部署Python Flask应用","text":"本文介绍了如何在Windows上部署Python Flask应用，相关环境如下： - 操作系统：windows 7 - Python：3.4 - WFastCGI: 2.2 应用所用到的包版本如下： Flask==0.10.1 Flask-SQLAlchemy==2.1 itsdangerous==0.24 Jinja2==2.8 MarkupSafe==0.23 pyodbc==3.0.10 SQLAlchemy==1.0.9 Werkzeug==0.11.2 wheel==0.24.0 1. WFastCGI wfastcgi.py使用WSGI和FastCGI提供了IIS和Python之间的桥接，类似于Apache HTTP服务器上的mod_python. 它能够用于任何支持WSGI的Python web应用或者框架，而且提供了IIS处理请求和进程池的高效方法。 2. 安装 2.1 下载安装包 通过PyPI安装： pip install wfastcgi 2.2 IIS安装FastCGI和URL重写 IIS需要安装FastCGI和URL重写，这个可以通过 Microsoft Web Platform Installer 来安装。下载过 Microsoft Web Platform Installer 点击运行，会出现如下的界面。 在搜索栏分别输入cgi和url重写，点击添加按钮： 注 ：windows10上的IIS 10现在不支持url重写。 3. 启用wfastcgi 一旦 wfastcgi 和IIS安装完毕，用管理员的身份运行 wfastcgi-enable 来在IIS上启用 wfastcgi 配置。这个能配置一个 路由处理器 的CGI应用。 wfastcgi-enable 要在卸载之前禁用 wfastcgi ，运行 wfastcgi-disable ： wfastcgi-disable pip uninstall wfastcgi 注意 : 卸载 wfastcgi 不会自动的取消注册CGI应用。 如果传递给 wfastcgi-enable 或者 wfastcgi-disable 的第一个参数是一个有效的文件，整个命令行就用来注册或取消注册这个CGI处理器。 例如，下面的命令就是在IIS Express上启用wfastcgi，而且指定主机配置。 wfastcgi-enable \"C:\\Program Files (x86)\\IIS Express\\appcmd.exe\" /apphostconfig:C:\\Path\\To\\applicationhost.config 你也可以使用 wfastcgi-disable 来禁用相同配置的wfastcgi: wfastcgi-disable \"C:\\Program Files (x86)\\IIS Express\\appcmd.exe\" /apphostconfig:C:\\Path\\To\\applicationhost.config 4. 使用PTVS创建Python Web项目 PTVS 是Visual Studio的一个插件，能够让VS支持Python开发，下载并安装后，就可以使用它来开发Python项目了。 使用PTVS创建一个Flask项目（Django项目类似）： PTVS会自动根据模板创建一个项目，点击运行，就会在项目根目录下创建一个web.config文件。我在下面对文件进行了一些修改说明。 ?xml version=\"1.0\"?> <configuration> <system.diagnostics> <!--如果不用此节点可以移除--> </system.diagnostics> <appSettings> <add key= \"WSGI_ALT_VIRTUALENV_HANDLER\" value= \"TgwlDataCenter.app\" /> <!--value指定Flask实例，PTVS会自动生成，也可以自己定义--> <add key= \"WSGI_ALT_VIRTUALENV_ACTIVATE_THIS\" value= \"%ROOTDIR%\\env\\Scripts\\activate_this.py\" /> <!--value指定激活虚拟路环境用到的内容--> <add key= \"WSGI_HANDLER\" value= \"ptvs_virtualenv_proxy.get_virtualenv_handler()\" /> <!--也是虚拟路径的WSGI_HANDLER，不用修改--> <add key= \"PYTHONPATH\" value= \"%ROOTDIR%\" /> <!--项目根目录--> </appSettings> <system.web> <compilation debug= \"true\" targetFramework= \"4.0\" /> </system.web> <system.webServer> <modules runAllManagedModulesForAllRequests= \"true\" /> <handlers> <add name= \"Python FastCGI\" path= \"handler.fcgi\" verb= \"*\" modules= \"FastCgiModule\" scriptProcessor= \"%INTERPRETERPATH%|%WFASTCGIPATH%\" resourceType= \"Unspecified\" requireAccess= \"Script\" /> <!--scriptProcessor的值就是你在运行wfastcgi-enbale时输出的值--> </handlers> <rewrite> <rules> <rule name= \"Static Files\" stopProcessing= \"true\" > <match url= \"&#94;/static/.*\" ignoreCase= \"true\" /> <!--静态文件不用CGI处理，直接使用IIS返回静态文件--> <action type= \"Rewrite\" url= \"&#94;/TgwlDataCenter/static/.*\" appendQueryString= \"true\" /> </rule> <rule name= \"Configure Python\" stopProcessing= \"true\" > <match url= \"(.*)\" ignoreCase= \"false\" /> <conditions> </conditions> <action type= \"Rewrite\" url= \"handler.fcgi/{R:1}\" appendQueryString= \"true\" /> </rule> </rules> </rewrite> </system.webServer> </configuration> scriptProcessor 的值是 wfastcgi-enable 命令执行时输出的，不同机器值也不一样。 path 和 verb 的值也可以进一步自定义来限制request的类型。 name 值可以在子文件夹的 web.config 文件中使用，来屏蔽handler的作用。比如，在 /static 子文件夹中添加一个 web.config 文件，包含 <remove name=\"Python FastCGI\"/> 来阻止IIS通过Python应用来解析静态文件。 app setting被转换为环境变量，并且能够在Python应用中通过 os.getenv 来获取。下面这些变量由 wfastcgi 使用。 注意 ：部署时需要将 %ROOTDIR% 全部替换为项目根目录， %INTERPRETERPATH%|%WFASTCGIPATH% 替换为 wfastcgi-enable 命令执行时输出，我的是 C:\\Python34\\python.exe|C:\\Python34\\lib\\site-packages\\wfastcgi.py 此时，将项目部署到IIS上就可以了，创建方法同普通的ASP.NET网站创建方法相同。 作者：liulixiang1988#gmail.com (#换成@)","tags":"Python","url":"/shi-yong-wfastcgizai-iisshang-bu-shu-python-flaskying-yong.html"},{"title":"Python扩展库","text":"Anaconda和Python(x,y)都自带了下面的这些库。 1. NumPy 强大的ndarray和ufunc函数。 import numpy as np xArray = np . ones (( 3 , 4 )) xArray Out [ 3 ]: array ([[ 1. , 1. , 1. , 1. ], [ 1. , 1. , 1. , 1. ], [ 1. , 1. , 1. , 1. ]]) 2. SciPy 科学计算（插值、积分、优化和图像处理） from scipy import linalg arr = np . array ([[ 1 , 2 ], [ 3 , 4 ]]) linalg . det ( arr ) #计算行列式 Out [ 6 ]: - 2.0 3. Matplotlib 基于NumPy，二维绘图库，简单快速地生成曲线图、直方图和散点图等形式的图。 常用的pyplot是一个简单提供类似Matlab接口的模块。 4. Pandas 基于SciPy和NumPy，拥有高效的Series和DataFrame数据结构，数据操作和分析能力非常强，拥有能够高效处理大数据集的切片等功能，提供优化库功能读写多种文件格式，如CSV, HDF5等 df.head(3) #头3行 df.tail(4) #最后4行 df.sort(columns='score') #按照score列排序 作者：liulixiang1988#gmail.com (#换成@) 参考链接：https://www.coursera.org/learn/hipython/home/welcome","tags":"Python","url":"/pythonkuo-zhan-ku.html"},{"title":"Python读取网络图片","text":"1. 使用urllib读取 try : from cStringIO import StringIO #python 2 except ImportError : from io import StringIO #python 3 import urllib file = StringIO ( urllib . urlopen ( URL ) . read ()) img = Image . open ( file ) 2. 使用requests读取 from PIL import Image import requests try : from StringIO import StringIO #python 2 except ImportError : from io import StringIO #python 3 response = requests . get ( url ) img = Image . open ( StringIO ( response . content )) 关于 StringIO 和 cStringIO ，这些只是在python2中存在，在python3中导入 io ，使用 io.StringIO 或者 io.BytesIO 来使用文本或者数据","tags":"Python","url":"/pythondu-qu-wang-luo-tu-pian.html"},{"title":"JavaScript模块化","text":"1. 模块化解读 AMD是RequireJS在推广过程中对模块定义的规范化产出。 异步加载模块，依赖前置，提前执行 Define定义模块 define(['require', 'foo'], function(){return;}); Require加载模块（依赖前置） require(['foo', 'bar'], function(foo, bar){}); CMD是SeaJS在推广过程中对模块定义的规范化产出。 Define定义exports导出 define(function(require, exports, module){}); module上存储了当前模块的一些对象。 require(./a)直接引。 Require.async 异步引入. 同步加载，依赖就近，延迟执行。 类似的还有CommonJS Module/2.0规范。 2. SeaJS的应用 目录结构： examples/ |-- sea-modules 存放 seajs、jquery 等文件，这也是模块的部署目录 |-- static 存放各个项目的 js、css 文件 | |-- hello | |-- lucky | `-- todo `-- app 存放 html 等文件 |-- hello.html |-- lucky.html `-- todo.html 我们从 hello.html 入手，来瞧瞧使用 Sea.js 如何组织代码。 2.1 在页面中加载模块 在 hello.html 页尾，通过 script 引入 sea.js 后，有一段配置代码： // seajs 的简单配置 seajs.config({ base: \"../sea-modules/\", alias: { \"jquery\": \"jquery/jquery/1.10.1/jquery.js\" } }) // 加载入口模块 seajs.use(\"../static/hello/src/main\") sea.js 在下载完成后，会自动加载入口模块。页面中的代码就这么简单。 2.2 模块代码 这个小游戏有两个模块 spinning.js 和 main.js ，遵循统一的写法： // 所有模块都通过 define 来定义 define(function(require, exports, module) { // 通过 require 引入依赖 var $ = require('jquery'); var Spinning = require('./spinning'); // 通过 exports 对外提供接口 exports.doSomething = ... // 或者通过 module.exports 提供整个接口 module.exports = ... }); 上面就是 Sea.js 推荐的 CMD 模块书写格式。如果你有使用过 Node.js，一切都很自然。","tags":"Web","url":"/javascriptmo-kuai-hua.html"},{"title":"React使用笔记(7)-React调优","text":"首先使用 react-with-addons.js 代替 react.js 。 在浏览器控制台使用 React.addons.Perf.start() 来记录操作用时，然后用 React.addons.Perf.stop() 。 查看结果： React.addons.Perf.printInclusive() . <script type= \"text/jsx\" > var NumberDiv = React.createClass({ getInitialState: function () { return { number: this.props.number, } }, shouldComponentUpdate: function (nextProps) { return nextProps.render }, render: function () { var style = { height: \"100px\", width: \"100px\", float: \"left\", margin: \"10px\", backgroundColor: \"gray\", } var chosedStyle = { height: \"100px\", width: \"100px\", float: \"left\", margin: \"10px\", backgroundColor: \"red\", } return <div style= {this.props.chosedNumber === this.state.number ? chosedStyle : style} > {this.state.number} </div> } }) var ChooseNumber = React.createClass({ getInitialState: function () { return { inputNumber: -1, lastNumber: -1 } }, handleChange: function (e) { if (parseInt(e.target.value) !== this.state.inputNumber) { this.setState({ inputNumber: parseInt(e.target.value), lastNumber: this.state.inputNumber }) } }, render: function () { var inputStyle = { display: \"block\", clear: \"both\", width: \"200px\", marginBottom: \"10px\", } var children = [] for (var i = 0; i < 5000 ; i++) { children.push(<NumberDiv key= {i} render= {i == this.state.inputNumber || i = = this.state.lastNumber} chosedNumber= {this.state.inputNumber} number= {i} ></NumberDiv> ) } return <div> <input type= \"text\" style= {inputStyle} placeholder= \"请输入一个数字\" onChange= {this.handleChange} /> {children} </div> ; } }); React.render( <ChooseNumber></ChooseNumber> , document.body); </script>","tags":"Web","url":"/reactshi-yong-bi-ji-7-reactdiao-you.html"},{"title":"React使用笔记(6)-React动画","text":"1. CSS3动画 <head> <meta charset= \"UTF-8\" > <title> React动画 </title> <style> .example-enter { opacity: 0.01; transition: opacity .5s ease-in; } .example-enter.example-enter-active { opacity: 1; } .example-leave { opacity: 1; transition: opacity .5s ease-in; } .example-leave.example-leave-active { opacity: 0.01; } </style> </head> <body> <script src= \"./react-0.13.2/react-0.13.2/build/react-with-addons.js\" ></script> <script src= \"./react-0.13.2/react-0.13.2/build/JSXTransformer.js\" ></script> <script type= \"text/jsx\" > var ReactCSSTransitionGroup = React.addons.CSSTransitionGroup; var TodoList = React.createClass({ getInitialState: function() { return {items: ['hello', 'world', 'click', 'me']}; }, handleAdd: function() { var newItems = this.state.items.concat([prompt('Enter some text')]); this.setState({items: newItems}); }, handleRemove: function(i) { var newItems = this.state.items; newItems.splice(i, 1); this.setState({items: newItems}); }, render: function() { var items = this.state.items.map(function(item, i) { return ( <div key= {item} onClick= {this.handleRemove.bind(this, i)} > {item} </div> ); }.bind(this)); //这里需要注意transitionName必须和样式名字头一致 return ( <div> <button onClick= {this.handleAdd} > Add Item </button> <ReactCSSTransitionGroup transitionName= \"example\" > {items} </ReactCSSTransitionGroup> </div> ); } }); React.render( <TodoList></TodoList> , document.body); </script> </body> 2. JS动画 <script src= \"./react-0.13.2/react-0.13.2/build/react.js\" ></script> <script src= \"./react-0.13.2/react-0.13.2/build/JSXTransformer.js\" ></script> <script type= \"text/jsx\" > var Positioner = React.createClass({ getInitialState: function() { return { position: 0 }; }, resolveSetTimeout: function() { if (this.state.position < this.props.position ) { this.setState({ position: this.state.position + 1 }); } }, componentDidUpdate: function() { if (this.props.position) { setTimeout(this.resolveSetTimeout, this.props.timeoutMs); } }, render: function() { var divStyle = { marginLeft: this.state.position }; return <div style= {divStyle} > This will animate! </div> } }) React.render( <Positioner></Positioner> , document.body); //由于此时界面中已经有了组件，所以React会修改现有组件，就会触发componentDidUpdate React.render( <Positioner position= {100} timeoutMs= {10} ></Positioner> , document.body); </script> 3. rAF动画 <script type= \"text/jsx\" > var Positioner = React.createClass({ getInitialState: function() { return { position: 0 }; }, resolveSetTimeout: function() { if (this.state.position < this.props.position ) { this.setState({ position: this.state.position + 1 }); } }, componentDidUpdate: function() { if (this.props.position) { requestAnimationFrame(this.resolveSetTimeout); } }, render: function() { var divStyle = { marginLeft: this.state.position }; return <div style= {divStyle} > This will animate! </div> } }) React.render( <Positioner></Positioner> , document.body); React.render( <Positioner position= {100} ></Positioner> , document.body); </script>","tags":"Web","url":"/reactshi-yong-bi-ji-6-reactdong-hua.html"},{"title":"React使用笔记(5)-React组件的协同使用","text":"1. 组件协同使用介绍 组件的协同就是对组件的一种 组件、管理的方式 。 目的： 逻辑清晰 代码模块化 封装细节 代码可复用 组织方式： 组件嵌套：实现封装 Mixin:直接嵌入代码，实现复用 2. 组件嵌套 组件嵌套的本质是 父子关系 。 父组件和子组件是如何通信的呢？ 父组件给子组件通信是用属性。 子组件对父组件通信是：父组件把事件处理函数作为属性传递给子组件，子组件再进行调用。 <script type= \"text/jsx\" > var Radio = React.createClass({ getInitialState: function () { return { value: this.props.defaultValue }; }, handleChange: function (event) { if (this.props.onChange) { this.props.onChange(event); } this.setState({ value: event.target.value }); }, render: function () { var children = {}; var value = this.props.value || this.state.value; React.Children.forEach(this.props.children, function (child, i) { var label = <label> <input type= \"radio\" name= {this.props.name} value= {child.props.value} checked= {child.props.value == value} onChange= {this.handleChange} /> {child.props.children} <br/> </label> ; children['label' + i] = label; }.bind(this)); return <span> {children} </span> ; } }); var MyForm = React.createClass({ getInitialState: function () { return {my_radio: \"B\"}; }, handleChange: function (event) { this.setState({ my_radio: event.target.value }); }, submitHandler: function (event) { event.preventDefault(); alert(this.state.my_radio); }, render: function () { return <form onSubmit= {this.submitHandler} > <Radio name= \"my_radio\" value= {this.state.my_radio} onChange= {this.handleChange} > <option value= \"A\" > First Option </option> <option value= \"B\" > Second Option </option> <option value= \"C\" > Third Option </option> </Radio> <button type= \"submit\" > Speak </button> </form> ; } }); React.render( <MyForm></MyForm> , document.body); </script>","tags":"Web","url":"/reactshi-yong-bi-ji-5-reactzu-jian-de-xie-tong-shi-yong.html"},{"title":"侧边栏工具条开发","text":"1. 案例实现方式 主要有以下几种方式： 1. 使用背景图片的方式 2. 使用图标字体的方式 3. 利用before和after伪类的方式","tags":"Web","url":"/ce-bian-lan-gong-ju-tiao-kai-fa.html"},{"title":"RequireJS使用笔记","text":"RequireJS的项目地址在：http://requirejs.org/ RequireJS常用的方法： 1. requirejs.config 给模块指定别名 2. requirejs 引入模块 3. define 编写模块 入口文件 <script src= \"js/require.js\" type= \"text/javascript\" data-main= \"js/main\" ></script> requirejs加载完之后，立即引入的文件由 data-main 来定义。这里文件为 js/main.js 我们创建的main.js如下： //定义别名 requirejs.config({ paths:{ jquery: 'jquery-1.11.3.min' } }) //引用模块 requirejs(['jquery', 'validate'], function($, validate){ console.log(validate.isEqual(1, 2)); }); 其中 validate 在 validate.js 中定义: define(['jquery'], function($){ return { isEmpty: function(){}, checkLength: function(){}, isEqual: function(str1, str2){ return str1 === str2; } } });","tags":"Web","url":"/requirejsshi-yong-bi-ji.html"},{"title":"CSS3扁平化风格博客","text":"1. 页面整体分析 做一个网页或者网站，第一步就是先定义网页与网站的结构，这是所有任务的前提。 2 准备工作 在这个案例中，我们将使用Gulp, SASS和Compass来创建。 2.1 安装Gulp Gulp是为了后期进行自动化工作而做的。 如果电脑没有安装node，那么第一步就是下载node，并且安装。 安装http-server来查看网页: npm install -g http-server 全局安装gulp: sudo npm install -g gulp 初始化项目： npm init 安装gulp及常用库 npm install gulp --save-dev npm install gulp-concat --save-dev npm install gulp-uglify --save-dev npm install gulp-rename --save-dev npm install gulp-minify-css --save-dev npm install gulp-sass --save-dev npm install gulp-compass --save-dev npm install gulp-sourcemaps npm install del --save-dev 2.2 安装SASS与Compass 如果没有安装ruby，请先安装ruby 配置ruby gem的source: $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install rails #安装 $ gem update #更新 $ gem install sass --version = 3.3 $gem uninstall sass 安装SASS $ gem install sass $ gem install sass --version=3.3 $ sass -v 安装Compass gem isntall compass 接下来我们来配置项目 2.3 使用Compass配置SASS compass create 一般来说，我们使用 compass create [项目名] 来创建项目，但是我们在之前已经使用 node init 初始化过了，所以此处我们略去项目名。 2.4 配置bower 创建 .bowerrc 文件，然后添加： { \"directory\": \"lib\" } 这里是指定bower安装的第三方库都在lib目录下。 2.4 创建gulp任务 在根目录下创建gulpfile.js 'use strict'; var gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), rename = require('gulp-rename'), compass = require('gulp-compass'), minifyCss = require('gulp-minify-css'), maps = require('gulp-sourcemaps'), del = require('del'); //编译JavaScript gulp.task('concatScripts', function() { return gulp.src([ 'js/jquery.js', 'js/main.js' ]) .pipe(maps.init()) .pipe(concat(\"app.js\")) .pipe(maps.write('./')) .pipe(gulp.dest('js')); }); //压缩JavaScript gulp.task('minifyScripts', ['concatScripts'], function() { return gulp.src(\"js/app.js\") .pipe(uglify()) .pipe(rename('app.min.js')) .pipe(gulp.dest('js')); }); //编译SASS gulp.task('compileSass', function() { return gulp.src('./scss/*.scss') .pipe(compass({ config_file: './config.rb', css: 'css', sass: 'scss', sourcemap: true })) .pipe(gulp.dest('css')); }); //压缩CSS gulp.task('minifyCss', ['compileSass'], function(){ return gulp.src(\"css/application.css\") .pipe(minifyCss({compatibility: 'ie8'})) .pipe(rename('application.min.css')) .pipe(gulp.dest('css')); }); //监视 gulp.task('watchFiles', function() { gulp.watch(['scss/**/*.scss', 'scss/*.scss'], ['compileSass']); gulp.watch('js/main.js', ['concatScripts']); }); //清理 gulp.task('clean', function() { del(['dist', 'css/application*.css*', 'js/app*.js*']); }); //构建 gulp.task('build', [\"minifyScripts\", \"minifyCss\"], function() { gulp.src([\"css/application.min.css\", \"js/app.min.js\", \"index.html\", \"img/**\", \"fonts/**\" ], { base: './' }) .pipe(gulp.dest('dist')) }); //服务 gulp.task('serve', ['watchFiles']); //默认任务 gulp.task('default', ['clean'], function() { gulp.start('build'); }); 目前为止我们的目录如下： ├── config.rb ├── css ├── fonts ├── gulpfile.js ├── img │ ├── banner.jpg │ ├── pic01.jpg │ ├── pic02.jpg │ └── pic03.jpg ├── index.html ├── js │ ├── jquery.js │ └── main.js ├── lib ├── node_modules │ ├── del │ ├── gulp │ ├── gulp-compass │ ├── gulp-concat │ ├── gulp-rename │ ├── gulp-sass │ ├── gulp-sourcemaps │ └── gulp-uglify ├── package.json └── scss ├── application.scss └── base └── _normalize.scss 经过一番配置，后面我们只需要运行: gulp serve 就可以监视文件的变化，并且自动进行编译了。 3. 模块分析与细节实现 3.1 重置样式与文件结构 我们使用normalize来对样式进行重置，normailze的SCSS版本在这里：https://github.com/JohnAlbin/normalize-scss 下载到 scss/base/_normalize.scss 。 然后打开 application.scss ，引入: @import \"base/normalize\" ; 就完成对页面的重置了。 如果此时定义一个页面如下： <!DOCTYPE html> < html > < head > < link href = \"css/application.css\" media = \"screen, projection\" rel = \"stylesheet\" type = \"text/css\" /> </ head > < body > < div id = \"div1\" > < h1 > 标题1 </ h1 > < h2 > 标题2 </ h2 > < ul > < li > item 01 </ li > < li > item 02 </ li > < li > item 03 </ li > < li > item 04 </ li > < li > item 05 </ li > </ ul > </ div > </ body > </ html > 此时运行 http-server 可以再浏览器的 localhost:8080 中进行查看。 3.2 页头、Banner、正文、页脚的宏观布局 布局一直都是从大到小，因此刚开始不必对细节过分关注。 <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < title > 理想的博客 </ title > < link href = \"css/application.css\" media = \"screen, projection\" rel = \"stylesheet\" type = \"text/css\" /> </ head > < body > <!-- 页头 --> < header id = \"header\" class = \"\" > < nav > </ nav > < div id = \"banner\" ></ div > </ header > <!-- /页头 --> <!-- /内容 --> < div class = \"content\" > </ div > <!-- /内容 --> <!-- 页脚 --> < footer > </ footer > <!-- /页脚 --> </ body > </ html > 3.3 页头结构分析及布局 <header id= \"header\" class= \"\" > <nav> <div class= \"logo\" ><a href= \"#\" > 理想 </a></div> <ul> <li class= \"active\" ><a href= \"#\" > 首页 </a></li> <li><a href= \"#\" > 链接2 </a></li> <li><a href= \"#\" > 链接3 </a></li> <li><a href= \"#\" > 链接4 </a></li> </ul> </nav> <div id= \"banner\" > <div class= \"inner\" > <h1> 刘理想 </h1> <p class= \"sub-heading\" > Lorem ipsum dolor sit amet, consectetur adipisicing elit. Qui cupiditate quia modi dignissimos . </p> <button> 了解我 </button> <div class= \"more\" > 更多 </div> </div> </div> </header> 定义 _header.scss nav { background : $ navbar - bgColor ; height : $ navbar - height ; } nav { ul { list-style : none ; margin : 0 ; float : $ navbar - menu - float ; li { display : inline ; line-height : $ navbar - height ; margin-right : $ navbar - menu - mright ; a { line-height : $ navbar - height ; display : inline - block ; height : inherit ; text-decoration : none ; color : $ navbar - menu - color ; } } } } 定义 _logo.scss : .logo { font-size : $ logo - fontSize ; font-weight : $ logo - fontWeight ; letter-spacing : $ logo - letterSpacing ; display : inline - block ; line-height : $ logo - lineHeight ; float : $ logo - float ; padding : $ logo - padding ; a { color : $ logo - color ; text-decoration : none ; } } 定义 _banner.scss : #banner{ background : $banner-bgColor; height : $banner-height; .inner { max-width : $banner-inner-mxwidth; text-align : center; margin : 0 auto; position : relative; top : $banner-inner-top; h1{ margin : 0; } .sub-heading{ line-height : $banner-inner-subheading-lineHeight; margin : $banner-inner-subheading-margin; } button{ padding : $banner-button-padding; } .more { margin-top : $banner-inner-more-mgTop; } } } 定义 _buttons.scss button { border : $ button - border ; background-color : $ button - bgColor ; color : $ button - color ; padding : $ button - padding ; } 其中变量定义再 _variables.scss : $ navbar-height : 50px ; $ navbar-bgColor : #ccc ; $ navbar-menu-float : right ; $ navbar-logo-float : left ; // 菜单项右侧外边距 $ navbar-menu-mright : 20px ; // 菜单项的颜色 $ navbar-menu-color : #fff ; /*banner*/ $ banner-height : 700px ; $ banner-bgColor : #777 ; // inner最大宽度 $ banner-inner-mxwidth : 300px ; $ banner-inner-top : 160px ; $ banner-inner-more-mgTop : 220px ; $ banner-inner-subheading-lineHeight : 30px ; $ banner-inner-subheading-margin : 30px ; $ banner-button-padding : 14px 60px ; /*components*/ // button $ button-border : none ; $ button-bgColor : #333 ; $ button-color : #eee ; $ button-padding : 20px ; // logo $ logo-fontSize : 20px ; $ logo-fontWeight : 700 ; $ logo-letterSpacing : 1px ; $ logo-float : left ; $ logo-color : #fff ; $ logo-lineHeight : $ navbar-height ; $ logo-padding : 0 0 0 10px ; 3.3 正文部分结构分析及布局 使用normalize之后，h1~6可能会造成margin collapse，解释在： http://stackoverflow.com/questions/7374657/normalize-css-top-header-gap When an element with a margin is inside an element without border or padding, the margin collapses with the margin of the parent element. It's the margin of the h1 element that you see at the top. As none of the parents have border or padding, the margin collapses all the way out to the outermost container. h1, h2, h3, h4, h5, h6{margin:0;padding:0} solve the problem, for the moment. Adding overflow:auto on the parent also keeps the margins from collapsing.","tags":"Web","url":"/css3bian-ping-hua-feng-ge-bo-ke.html"},{"title":"Gulp笔记","text":"1. 准备工作 安装nodejs 安装http-server: npm install -g http-server 初始化项目： npm init 安装gulp: npm install gulp --save-dev 安装到依赖中 2. 第一个Gulp Task 创建一个gulpfile.js，gulp会自动发现这个文件。 'use strict'; //使用严格的编译方法 var gulp = require('gulp'); //定义task，第一个参数是任务名 gulp.task(\"hello\", function(){ console.log(\"Hello\"); }) 运行任务： $ gulp hello [ 09:40:32 ] Using gulpfile G: \\g it \\W ebDesign \\g ulp_learn \\g ulp_basics \\g ulpfile.js [ 09:40:32 ] Starting 'hello' ... Hello [ 09:40:32 ] Finished 'hello' after 354 μs 定义默认的task： //默认task，第二个参数是依赖任务，依赖任务会在当前任务之前执行 gulp.task(\"default\", [\"hello\"], function(){ console.log(\"This is the default task!\"); }); 运行任务，运行默认的任务不需要任务名： $ gulp [ 09:43:23 ] Using gulpfile G: \\g it \\W ebDesign \\g ulp_learn \\g ulp_basics \\g ulpfile.js [ 09:43:23 ] Starting 'hello' ... Hello [ 09:43:23 ] Finished 'hello' after 299 μs [ 09:43:23 ] Starting 'default' ... This is the default task! [ 09:43:23 ] Finished 'default' after 554 μs 3. 使用Gulp管理Javascript 工作流 3.1 使用Gulp第三方库 gulp社区提供了很多gulp的第三方库，来完成各种工作(比如编译sass, 压缩文件等)。 这里我们使用gulp-concat库，来分别压缩css和js文件到一个文件中。 安装gulp-concat npm install gulp-concat --save-dev 假设我们页面里有很多js文件，当项目变得越来越大时，管理多个文件就很困难，所以我们可以使用gulp来将这些文件合并成一个文件。 var gulp = require('gulp'), concat = require('gulp-concat'); //定义task，第一个参数是任务名 gulp.task(\"concatScripts\", function(){ //gulp.src可以接受数组和单独的字符串，注意js文件的顺序 //pipe类似unix中管道的概念，前面的输出作为后面的输入，这里gulp.src的输出作为concat()的输入 //concat()接受的字符串参数是合并后的文件名 //gulp.dest()指定文件夹 gulp.src([ 'js/jquery.js', 'js/sticky/jquery.sticky.js', 'js/main.js']) .pipe(concat(\"app.js\")) .pipe(gulp.dest('js')); }); 3.2 压缩JavaScript文件 安装gulp-uglify npm install gulp-uglify --save-dev 利用前面concatScripts已经创建好的app.js，进行压缩： gulp.task(\"minifyScripts\", function(){ gulp.src(\"js/app.js\") .pipe(uglify()) .pipe(gulp.dest('js')); }); 上面有一个问题，就是原有的app.js被压缩了，看不到原有未压缩前的js了。那我们可以使用gulp-rename来将压缩后的文件重命名。 安装gulp-rename: npm install gulp-rename --save-dev gulp.task(\"minifyScripts\", function(){ gulp.src(\"js/app.js\") .pipe(uglify()) .pipe(rename('app.min.js')) .pipe(gulp.dest('js')); }); 4. 使用Gulp编译Sass 4.1 Gulp自动编译Sass 要让Gulp能够编译Sass，第一步就是安装gulp-sass npm install gulp-sass --save-dev 然后创建任务： gulp.task(\"compileSass\", function(){ gulp.src('scss/application.scss') .pipe(sass()) .pipe(gulp.dest('css')); }); 4.2 给Sass添加Source Map Source Map用来显示Sass和CSS之间的映射，当Sass文件较多时特别有用。 安装gulp-sourcemaps npm install gulp-sourcemaps 定义source map有点不同： var maps = require('gulp-sourcemaps'); gulp.task(\"compileSass\", function(){ gulp.src('scss/application.scss') .pipe(maps.init()) //初始化maps .pipe(sass()) .pipe(maps.write('./')) //输出source maps文件路径是相对于输出的css文件路径的，这里让source maps也在css文件夹内 .pipe(gulp.dest('css')); }); 这个时候在谷歌浏览器的开发工具里查看class，就会显示对应的sass文件了。 4.3 JavaScript的Source Map gulp-sourcemaps不仅能映射sass和css，还能给js做映射，方法同Sass映射： gulp.task(\"concatScripts\", function(){ //gulp.src可以接受数组和单独的字符串，注意js文件的顺序 //pipe类似unix中管道的概念，前面的输出作为后面的输入，这里gulp.src的输出作为concat()的输入 //concat()接受的字符串参数是合并后的文件名 //gulp.dest()指定文件夹 gulp.src([ 'js/jquery.js', 'js/sticky/jquery.sticky.js', 'js/main.js']) .pipe(maps.init()) .pipe(concat(\"app.js\")) .pipe(maps.write('./')) .pipe(gulp.dest('js')); }); 5. 进一步提高Gulp任务管道 5.1 多个任务放在一起 gulp.task(\"build\", [\"concatScripts\", \"minifyScripts\", \"compileSass\"]); 但这样做会有一个问题，3个任务是一起执行的，而minifyScripts需要在concatScripts之前执行。要解决这个问题，我们对gulpfile.js进行改造： 'use strict'; var gulp = require('gulp'), concat = require('gulp-concat'), uglify = require('gulp-uglify'), rename = require('gulp-rename'), sass = require('gulp-sass'), maps = require('gulp-sourcemaps'); gulp.task(\"concatScripts\", function(){ return gulp.src([ 'js/jquery.js', 'js/sticky/jquery.sticky.js', 'js/main.js']) .pipe(maps.init()) .pipe(concat(\"app.js\")) .pipe(maps.write('./')) .pipe(gulp.dest('js')); }); gulp.task(\"minifyScripts\", [\"concatScripts\"], function(){ return gulp.src(\"js/app.js\") .pipe(uglify()) .pipe(rename('app.min.js')) .pipe(gulp.dest('js')); }); gulp.task(\"compileSass\", function(){ return gulp.src('scss/application.scss') .pipe(maps.init()) .pipe(sass()) .pipe(maps.write('./')) .pipe(gulp.dest('css')); }); gulp.task(\"build\", [\"minifyScripts\", \"compileSass\"]); gulp.task(\"default\", [\"build\"]); 首先所有的任务都用 return 进行返回，这样gulp能够在运行需要依赖的任务时，知道依赖任务什么时候结束。 然后将concatScripts作为minifyScripts的依赖，并从build任务中删除concatScripts，从而实现concatScripts在minifyScripts前运行。 5.2 使用watch方法自动运行任务 gulp的watch方法能够自动检测到文件的改变，并且自动执行任务。 gulp.task(\"watchSass\", function(){ gulp.watch(['scss/**/*.scss'], ['compileSass']); }); 运行： gulp watchSass 5.3 构建和开发的pipeline 如果需要部署，则将文件拷贝到dist，但是要提供 {base: './'} ，否则只拷贝文件不拷贝目录。 gulp.task(\"build\", [\"minifyScripts\", \"compileSass\"], function(){ return gulp.src([\"css/application.css\", \"js/app.min.js\", \"index.html\", \"img/**\", \"fonts/**\"], {base: './'}) .pipe(gulp.dest('dist')); }); 安装del，删除多余的文件 npm install del --save-dev 创建清除 gulp.task(\"clean\", function(){ del(['dist', 'css/application.css*', 'js/app*.js*']); }); 最后，整个流程是清除原先生成的文件，然后再运行build任务。 gulpfile.js中启动任务是 gulp.start('任务名') gulp.task(\"clean\", function(){ del(['dist', 'css/application.css*', 'js/app*.js*']); }); gulp.task(\"build\", [\"minifyScripts\", \"compileSass\"], function(){ return gulp.src([\"css/application.css\", \"js/app.min.js\", \"index.html\", \"img/**\", \"fonts/**\"], {base: './'}) .pipe(gulp.dest('dist')); }); gulp.task(\"default\", [\"clean\"], function(){ gulp.start('build'); }); 5.4 深入development pipeline 如果要监视Sass和JS的变化，利用前面创建的watchSass，改为: gulp.task(\"watchFiles\", function(){ gulp.watch(['scss/**/*.scss'], ['compileSass']); gulp.watch('js/main.js', ['concatScripts']); }); 也可以把两个watch合并为一个： gulp.watch(['scss/**/*.scss', 'js/main.js'], ['compileSass', 'concatScripts']); 这样，无论是sass还是js文件发生改变，都会引起compileSass和concatScripts任务重新执行，这并不是一个特别好的方法，因为js并不需要compileSass，同样，sass也并不需要concatScripts.","tags":"Web","url":"/gulpbi-ji.html"},{"title":"Android-常见问题汇总","text":"使用Android兼容库时ToolBar不显示 这种情况是因为使用错了兼容库的版本，请使用v7版本的兼容库： import android.support.v7.app.AppCompatActivity ; 层级导航（Up导航） 层级导航(Up导航)是在app内导航到上一级别，始终是在同一个app内，是逐级向上的应用内导航。 后退键导航(Back导航)则是根据用户的历史记录进行导航，只能返回到上一次的用户界面，比如导航到桌面或者其他应用中。 给一个应用添加逐级导航的方法是在 AndroidManifest.xml 中的Activity中添加 android:parentActivityName 属性: <activity android:name= \".CrimePagerActivity\" android:label= \"@string/app_name\" android:parentActivityName= \".CrimeListActivity\" > </activity> 效果如图：","tags":"Android","url":"/android-chang-jian-wen-ti-hui-zong.html"},{"title":"Android Studio使用总结","text":"","tags":"Android","url":"/android-studioshi-yong-zong-jie.html"},{"title":"JS笔记-变量与对象","text":"1. 变量声明 var a = a || 7; //如果a有值（严格来说是某个可以被转换为true的值），就直接使用，否则把7赋值给a 对比，下面的代码在变量b声明的情况下是对的，如果没有声明，就会引起ReferenceError异常。 var a = b || 7; //可能引起ReferenceError异常的危险代码 2. 对象是否存在检验 //第一种方法 var a = a || 7; //第二种方法 var a; var b = a || 7; //第三种方法（根据第二种改进） var a; var b = a !== undefined ? a : 7; //第四种方法 if(typeof a !== 'undefined'){ var b = a; } else { var b = 7; } //从这里开始使用变量b //第五种方法，如果变量在最外层作用域，可以像下面这样 if ('a' in this){ var b = a; } else { var b = 7; } 第四种方法利用了 JavaScript(ECMAScript)中没有块级作用域的特性 3. 属性是否存在检验 //第一种方法，避免出现TypeError异常 obj.x && obj.x.y //第二种方法，检测是否存在某一属性，使用in运算符 if ('a' in this){}","tags":"Web","url":"/jsbi-ji-bian-liang-yu-dui-xiang.html"},{"title":"Windows下使用Apache+mod_wsgi部署Django","text":"这个总结是在 原来笔记 里修改而来。 1、环境 django 1.8.2 python 3.4 32位 apache 2.4.12 32位 一个可以使用的django project( https://github.com/liulixiang1988/python_study_case/tree/master/django) 2、安装apache 32位 可以在这里下载（http://www.apachelounge.com/download/） 注意，我们必须在这个网站上下载apache才能运行后面的mod_wsgi 这时，需要注意我们还必须下载对应的分发环境，如果下载的是apache 2.4 vc14 windows binaries，则必须下载VC14 vcredist_x64/86.exe 更改基本配置: 打开apache/conf/http.conf文件 - 首先找到 Listen 8080 , 更改为需要的端口 - 找到ServerName，配置域名或者IP: ServerName 172.16.222.45:8008 - 找到ServerRoot，更改为apache目录 ServerRoot \"d:/Apache24\" - 找到DocumentRoot，更改为apache对应目录： DocumentRoot \"d:/Apache24/htdocs\"<Directory \"d:/Apache24/htdocs\"> 3、安装mod_wsgi 注意，因为apache是32位的，所以mod_wsgi也应该选择32位的。mod_wsgi的官网在 这里 。但是因为没有windows编译版本（自己编译几乎都是以失败告终），所幸在 github 上可以下载到编译版本，我们选择 mod_wsgi-windows-4.4.12.tar.gz 进行下载。 下载过mod_wsgi之后，解压之后的文件为\"mod_wsgi.so\"文件。我们拷贝它到apache安装目录下面的modules文件夹。 光拷贝mod_wsgi.so文件是不行的，我们还需要修改apache的配置文件，让apache知道mod_wsgi的存在。apache的配置文件在apache安装目录下的conf文件夹中的httpd.conf文件。使用记事本或者任何你喜欢的文本编辑器打开它，在文件的最后添加下面的内容并保存就可以了： LoadModule wsgi_module modules/mod_wsgi/mod_wsgi.so 4、配置django project 第一步，你要有个django project，如果你这是想尝试一下如何部署而没有项目的话，可以在到我的github上下载一个https://github.com/liulixiang1988/python_study_case 第二步 修改wsgi.py文件 这是原来笔记中记录的，在这次的部署中，我发现不需 要这一步 原以为wsgi.py不需要修改的，可是发现如果不将目录所在的文件夹添加到系统路径中，apache还是会报错，因此在wsgi.py添加下面2行 import sys sys . path . append ( 'E:/git/python_dev/python_study_case/django/mydjangosite' ) 其中append的参数就是你的project下的目录 第三步 配置apache/conf/httpd.conf文件 打开httpd.conf文件，在后面添加下面内容 #添加映射，其中WSGIScriptAlias /是映射到根目录，如果你需要映射到其他地址，可以改为WSGIScriptAlias /myproject （假设myproject是你想要的地址，那么你可以通过访问localhost/myproject来访问你的网站） WSGIScriptAlias / E:/git/python_dev/python_study_case/django/mydjangosite/mydjangosite/wsgi.py #指明应用路径，如果你是使用virtualenv，那么还需要添加virtualenv的site-packages路径，中间用\":\"分隔 WSGIPythonPath E:/git/python_dev/python_study_case/django/mydjangosite:E:/git/python_dev/envs/django/Lib/site-packages #添加wsgi的读取权限 <Directory E:/git/python_dev/python_study_case/django/mydjangosite/mydjangosite > <Files wsgi.py > Order deny,allow Require all granted </Files> </Directory> #这里声明静态文静的映射，这个/static是给django admin的静态文件使用的 Alias /static \"C:/Python33/Lib/site-packages/django/contrib/admin/static\" #这里是添加文件夹的读取权限，注意apache2.3以上的读写设置与2.3以下版本有所不同 <Directory \"C:/Python33/Lib/site-packages/django/contrib/admin/static/\" > <IfVersion < 2.3 > Order allow,deny Allow from all </IfVersion> <IfVersion > = 2.3> Require all granted </IfVersion> </Directory> #媒体文件 Alias /media \"F:/git/python/app-host/media\" <Directory \"F:/git/python/app-host/media\" > Require all granted </Directory> 5、启动apache 打开cmd，定位到apache安装目录下面的bin目录，输入httpd就可以启动服务器了，此时你就可以在你的浏览器中访问localhost了 6、需要改进的地方 因为工作中使用的是asp.net，对apache不熟，所以对虚拟主机的配置以及mod_wsgi的运行模式的理解还不是特别透彻，也是下一步需要学习的方向。 7、致谢与参考 首先感谢那些为提供这些优秀开源工程的程序员们；其次在学习如何部署的过程中，下面两篇文章对我的帮助很大，在这里再次说声谢谢! https://docs.djangoproject.com/en/dev/howto/deployment/wsgi/modwsgi/ http://agong.org/2013/windows64-python3-apache-wsgi-django.html 8、最后 如果你觉得这篇文章对你比较有帮助，或者有什么问题，欢迎给我留言或者email:550488300@qq.com","tags":"Python","url":"/windowsxia-shi-yong-apachemod_wsgibu-shu-django.html"},{"title":"CSS3笔记03-变形transform","text":"1. 缩放scale transform : scale ( 1.2 ); transform-origin :缩放开始位置 transform-origin : bottom left ; 2. box-shadow 阴影 用法同text-shadow 3. 旋转rotate transform : scale ( 1.2 ) rotate (- 10 deg ) 4. 倾斜skew transform : scale ( 1.2 ) skew (- 5 deg , 30 deg ); skew的参数分别是x坐标角度和y坐标角度，也可以给相同的角度 skew(30deg) 5. 平移translate transform : scale ( 1.2 ) translate ( 20 px , 40 px ); 默认是向右和向下，如果是负数，方向相反","tags":"Web","url":"/css3bi-ji-03-bian-xing-transform.html"},{"title":"CSS3笔记02-悬停效果","text":"1. 首先需要了解几个伪类： :hover 选择器：当鼠标悬停在所指定的元素上时所使用的样式； :active 选择器：当所指定的元素处于激活状态（鼠标在元素上按下还没有松开）时所使用的样式； :focus 选择器：当元素获得光标焦点时使用的样式，主要用在文本框输入文字时使用. 2. rgba color : #eee ; color : rgba ( 255 , 255 , 255 , 0 .7 ); rgba增加了透明度，在上面例子中多添加一个 color:#eee; 是为了使不支持rgba的浏览器仍然有color可用。 3. 文本阴影(text-shadow) a { text-shadow : 0 1px 1px rgba ( 0 , 0 , 0 , 0 . 5 ); } text-shadow的属性如下： text-shadow : h-shadow v-shadow blur color ; h-shadow: 必需。水平阴影的位置。允许负值。 v-shadow: 必需。垂直阴影的位置。允许负值。 blur: 可选。模糊的距离。 color: 可选。阴影的颜色。参阅 CSS 颜色值。 scss: @import \"compass/css3/text-shadow\" ; single - text - shadow ( $hoff , $voff , $blur , $spread , $color ); 4. 悬停与聚焦的样式： scss： a { padding : 5px 15px ; font-weight : bold ; color : #eee ; color : rgba ( 255 , 255 , 255 , 0 . 7 ); @ include single - text-shadow ( 0 , 1px , 1px , rgba ( 255 , 0 , 0 , 0 . 3 )); &: hover ,&: focus { color : #fff ; background : rgba ( 255 , 255 , 255 , 0 . 15 ); } } css： #nav li a { padding : 5px 15px ; font-weight : bold ; color : #eee ; color : rgba ( 255 , 255 , 255 , 0 . 7 ); text-shadow : 0 1px 1px #aaaaaa ; text-shadow : 0 1px 1px rgba ( 255 , 0 , 0 , 0 . 3 ) #aaaaaa ; } #nav li a :hover , #nav li a :focus { color : #fff ; background : rgba ( 255 , 255 , 255 , 0 . 15 ); } 5. 使用border-radius圆角化悬停 scss: @import \"compass/css3/border-radius\" ; border - radius ( $radius , $vertical - radius ) css3: -moz-border-radius : 14px ; -webkit-border-radius : 14px ; border-radius : 14px ; 6. 添加过渡 scss: @include single-transition(all, 0.3s, ease-in-out); css3: -moz-transition : all 0 .3s ease-in-out ; -o-transition : all 0 .3s ease-in-out ; -webkit-transition : all 0 .3s ease-in-out ; transition : all 0 .3s ease-in-out ; 7. 透明度opacity opacity : 0.25 ; - ms - fiter : \"progid:DXImageTransform.Microsoft.Alpha(Opacity=25)\" ; /*IE8 hack*/ filter : alpha ( opacity = 25 ); /*IE5-7 hack*/","tags":"Web","url":"/css3bi-ji-02-xuan-ting-xiao-guo.html"},{"title":"CSS3笔记01-过渡transition","text":"使用compass: @import \"compass/css3/transition\" ; div . foo { width : 50 px ; padding : 5 px 10 px ; background : #9f3; @ include transition - property ( background , width ); @ include transition - duration ( 0.5 s ); @ include transition - timing - function ( ease - in ); } div . foo : hover { background : #690; width : 100 px ; } 对应的css3: div .foo { width : 50px ; padding : 5px 10px ; background : #9f3 ; - moz - transition - property : background , width ; - o - transition - property : background , width ; - webkit - transition - property : background , width ; transition - property : background , width ; - moz - transition - duration : 0.5s ; - o - transition - duration : 0.5s ; - webkit - transition - duration : 0.5s ; transition - duration : 0.5s ; - moz - transition - timing - function : ease - in ; - o - transition - timing - function : ease - in ; - webkit - transition - timing - function : ease - in ; transition - timing - function : ease - in ; } /* line 13, ../sass/transition.scss */ div .foo :hover { background : #690 ; width : 100px ; } transition-property :代表过渡的属性，可以使 background , opactiy , font-size 和 width 等,也可以使用 all 代表全部属性； transition-duration ：代表过渡的持续时间，注意结尾要有单位，比如 3s 等； transition-timing-function : 过渡的时间函数，有六种 [ ease | linear | ease-in | ease-out | ease-in-out | cubic-bezier(x1, y1, x2, y2)] 平滑、线性、由慢到快、由快到慢、由慢到快再到慢，以及三次贝赛尔曲线类型； transition-delay : 延迟过渡，注意要有单位。 也可以使用 transition 一次写完： compass: single-transition($property, $duration, $function, $delay) scss: transition:background 0.3s ease 0.3s","tags":"Web","url":"/css3bi-ji-01-guo-du-transition.html"},{"title":"Ionic使用教程-条码扫描","text":"ionic中与硬件交互部分是使用 ngcordova 和cordova来实现。 1.下载ngcordova并且加入到文件中 到ngcordova的页面下载，然后添加到页面，注意要添加到 cordova.js 之前： <script src= \"lib/ngCordova/dist/ng-cordova.min.js\" ></script> <script src= \"cordova.js\" ></script> 2. 安装条码插件 这个插件支持常见的二维码和条码扫描，非常的强大，下面我们来看看如何安装插件。 ngcordova官方给出的安装方法： cordova plugin add https://github.com/wildabeast/BarcodeScanner.git 但是我们跳转到对应的github页面：https://github.com/wildabeast/BarcodeScanner/ 发现说官方的地址是：https://github.com/phonegap/phonegap-plugin-barcodescanner 里面给出的安装方法是： phonegap plugin add phonegap-plugin-barcodescanner 因为我们用的是ionic和cordova，所以可以使用： cordova plugin add phonegap-plugin-barcodescanner 3. 编写js代码 controller ( 'BarcodeCtrl' , function ($ scope , $ cordovaBarcodeScanner ) { $ scope . barcode = \"\" ; $ scope . scanBarcode = function () { $ cordovaBarcodeScanner . scan () . then ( function ( imageData ) { $ scope . barcode = imageData . text ; console . log ( \"****barcode format:\" + imageData . format ); } , function ( error ) { console . log ( \"*****an error occured:\" + error ); } ); } ; } ) 代码很简单，使用这个可以完成扫描成功进行赋值，扫描失败则就在控制台打印的功能。 对应的前端页面如下： <div class= \"list\" ng-controller= \"BarcodeCtrl\" > <div class= \"item item-input-inset\" > <label class= \"item-input-wrapper\" > <input type= \"text\" placeholder= \"条码\" ng-model= \"barcode\" > </label> <button class= \"button button-small\" ng-click= \"scanBarcode()\" > 扫描 </button> </div> </div> 至此，你就完成了条码扫描功能。","tags":"ionic","url":"/ionicshi-yong-jiao-cheng-tiao-ma-sao-miao.html"},{"title":"JS补遗-数据处理篇","text":"String转JSON var arr_from_json = JSON.parse( json_string ); 也可以使用 json2.js 值转JSON字符串 JSON.stringify() 把值转化为JSON字符串 详细说明：https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify","tags":"Web","url":"/jsbu-yi-shu-ju-chu-li-pian.html"},{"title":"AngularJS学习笔记-踩坑笔记","text":"digest already in progress","tags":"Web","url":"/angularjsxue-xi-bi-ji-cai-keng-bi-ji.html"},{"title":"Exmobi笔记-文件相关","text":"文件下载 文件下载与打开 $( \"a\" ) .click ( function () { if ( $ ( this ) . attr ( 'href' ) . match ( / doc $ | docx $ | pdf $ / )) { alert ( \"matched\" ); } ClientUtil .download ($( this ) .attr ( 'href' ), \"res:\" +$( this ) .text (), null , null , false ); NativeUtil .open ( \"res:\" +$( this ) .text ()); } );","tags":"移动开发","url":"/exmobibi-ji-wen-jian-xiang-guan.html"},{"title":"JS补遗-jQuery篇","text":"文件相关 jQuery获取当前input file里的值 ： $(\"#fileinput\").val(); jQuery获取input file里的多个值 var files = $('#basicUploadFile').prop(\"files\"); //files是FileList对象 var names = $.map(files, function(val) { return val.name; }); //names是字符串数组 jQuery文件上传 文件跨域提交","tags":"Web","url":"/jsbu-yi-jquerypian.html"},{"title":"Ionic使用教程","text":"Ionic项目主页：http://ionicframework.com/ 它是用来构建混合应用的一款前端框架，使用Cordova和AngularJS，目前中文资料尚且较少。这篇文章主要是在学习中做的一个记录，也希望能为后面的学习者提供一些参考。 1. 要求 安装Node/NPM 安装Ruby和SASS 了解AngularJS 安装Gulp(可选) 安装Android SDK和XCode（可选） 2. ionic开发步骤 2.1 全局安装cordova和ionic npm install -g cordova ionic 2.2 从模板中创建应用 ionic start frontendAwesome sidemenu cd frontendAwesome 其中 frontendAwesome是项目名，sidemenu是模板名 有3个默认模板：sidemenu(侧边菜单), tabs(底部标签), blank(空白) 第一个命令结束后，会自动输出一大堆英文： Creating Ionic app in folder F: \\ git \\ WebDesign \\ ionic \\ fontendAwesome based on side menu project Downloading: https: // github . com / driftyco / ionic-app-base / archive / master . zip [=============================] 100 % 0.0 s Downloading: https: // github . com / driftyco / ionic-starter-sidemenu / archive / master . z ip [=============================] 100 % 0.0 s Update config . xml Initializing cordova project Updated the hooks directory to have execute permissions running cordova plugin add org . apache . cordova . device WARNING: org . apache . cordova . device has been renamed to cordova-plugin-device . Yo u may not be getting the latest version ! We suggest you ` cordova plugin rm org . a pache . cordova . device ` and ` cordova plugin add cordova-plugin-device `. Fetching plugin \"org.apache.cordova.device\" via cordova plugins registry npm http GET http: // registry . cordova . io / org . apache . cordova . device npm http 304 http: // registry . cordova . io / org . apache . cordova . device Saving plugin to package . json file Adding since there was no existingPlugin Updated the hooks directory to have execute permissions running cordova plugin add org . apache . cordova . console WARNING: org . apache . cordova . console has been renamed to cordova-plugin-console . You may not be getting the latest version ! We suggest you ` cordova plugin rm org . apache . cordova . console ` and ` cordova plugin add cordova-plugin-console `. Fetching plugin \"org.apache.cordova.console\" via cordova plugins registry npm http GET http: // registry . cordova . io / org . apache . cordova . console npm http 304 http: // registry . cordova . io / org . apache . cordova . console Saving plugin to package . json file Adding since there was no existingPlugin Updated the hooks directory to have execute permissions running cordova plugin add com . ionic . keyboard Fetching plugin \"com.ionic.keyboard\" via cordova plugins registry npm http GET http: // registry . cordova . io / com . ionic . keyboard npm http 304 http: // registry . cordova . io / com . ionic . keyboard Saving plugin to package . json file Adding since there was no existingPlugin Your Ionic project is ready to go ! Some quick tips: * cd into your project: $ cd fontendAwesome * Setup this project to use Sass: ionic setup sass * Develop in the browser with live reload: ionic serve * Add a platform ( ios or Android ): ionic platform add ios [ android ] Note: iOS development requires OS X currently See the Android Platform Guide for full Android installation instructions: https: // cordova . apache . org / docs / en / edge / guide_platforms_android_index . md . html * Build your app: ionic build <PLATFORM> * Simulate your app: ionic emulate <PLATFORM> * Run your app on a device: ionic run <PLATFORM> * Package an app using Ionic package service: ionic package <MODE> <PLATFORM> For more help use ionic -- help or visit the Ionic docs: http: // ionicframework . co m/docs +---------------------------------------------------------+ + New Ionic Updates for May 2015 + + The View App just landed. Preview your apps on any device + http:/ / view . ionic . io + + Invite anyone to preview and test your app + ionic share EMAIL + + Generate splash screens and icons with ionic resource + http: // ionicframework . com / blog / automating-icons-and-splash-screens / + +---------------------------------------------------------+ 上面介绍了一些基本用法和注意事项，第一次使用的时候应该读一读。 2.3 build(编译)和emulate(仿真) ionic build ios ionic emulate ios ionic serve #adb安装 adb install -r platforms/android/build/outputs/apk/android-debug.apk adb lolcat 2.4 自定义ionic样式 文件：scss/ionic.app.scss 2.5 自定义内容 Angular templating Directives {{markup}} Angular Directives(ng-repeat ng-model) Ionic Directives(ion-view, ion-content) Filter({{ data|filter }}) www/js/app.js www/js/controller.js www/templates/posts.html www/templates/post.html 2.6 Ionic CSS组件 http://ionicframework.com/docs/components/ http://ionicons.com/ 2.7 分发","tags":"ionic","url":"/ionicshi-yong-jiao-cheng.html"},{"title":"AngularJS学习笔记05-指令","text":"AngularJS四大核心特性 MVC 模块化和依赖注入 双向数据绑定 指令 解析最简单的指令hello","tags":"Web","url":"/angularjsxue-xi-bi-ji-05-zhi-ling.html"},{"title":"AngularJS学习笔记04 路由","text":"Ajax的不足 Ajax请求不会留下History记录 用户无法直接通过URL进入应用中的指定页面（保存书签、链接分享给朋友） Ajax对SEO是个灾难 以上是为什么需要前端路由的原因 路由 需要自己导入angular-route模块。 <script src= \"framework/angular1.3.15/angular.min.js\" ></script> <script src= \"framework/angular1.3.15/angular-route.min.js\" ></script> <script> var bookStoreApp = angular.module('bookStoreApp', ['ngRoute', 'bookStoreCtrls']); bookStoreApp.config(['$routeProvider', function($routeProvider) { $routeProvider.when('/hello',{ templateUrl:'tpls/hello.html', controller: 'HelloCtrl' }).when('/list', { templateUrl:'tpls/bookList.html', controller: 'BookListCtrl' }).otherwise({ redirectTo:'/hello' }); }]); </script> 本节重点在于ui-router的使用，与ngRoute的区别是： 1、可实现路由分开控制多模块页面的各个模块 2、index.html中的视图部分为 <div ui-view></div> 3、需要依赖ui.router，函数需要引入 \\(stateProvider及\\) urlRouterProvider 4、语法类似ngRouter if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Web","url":"/angularjsxue-xi-bi-ji-04-lu-you.html"},{"title":"AngularJS学习笔记03 双向数据绑定","text":"内容简介： 简单的例子 取值表达式和ng-bind指令 双向绑定的典型场景-表单 动态切换标签样式 ng-show, ng-hide ng-class ngAnimate 双向数据绑定 <!DOCTYPE html> < html ng-app = \"UserInfoModule\" > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < title > 数据绑定 </ title > < link rel = \"stylesheet\" href = \"stylesheets/bootstrap.min.css\" > </ head > < body ng-app > < div class = \"panel panel-primary\" > < div class = \"panel-heading\" > 双向数据绑定 </ div > < div class = \"panel-body\" > < div class = \"row\" > < div class = \"col-md-12\" > < form class = \"form-horizontal\" ng-controller = \"UserInfoCtrl\" > < div class = \"form-group\" > < label class = \"col-sm-2 control-label\" > Email </ label > < div class = \"col-sm-10\" > < input type = \"text\" class = \"form-control\" placeholder = \"邮箱\" ng-model = \"userInfo.email\" > </ div > </ div > < div class = \"form-group\" > < label class = \"col-sm-2 control-label\" > 密码 </ label > < div class = \"col-sm-10\" > < input type = \"password\" class = \"form-control\" placeholder = \"请输入密码\" ng-model = \"userInfo.password\" > </ div > </ div > < div class = \"form-group\" > < div class = \"col-md-offset-2 col-md-10\" > < div class = \"checkbox\" > < label > < input type = \"checkbox\" ng-model = \"userInfo.autoLogin\" > 自动登录 </ label > </ div > </ div > </ div > < div class = \"form-group\" > < div class = \"col-md-offset-2 col-md-10\" > < label > < button ng-click = \"getFormData()\" class = \"btn btn-default\" > 获取FormData </ button > < button ng-click = \"setFormData()\" class = \"btn btn-default\" > 设置FormData </ button > < button ng-click = \"resetFormData()\" class = \"btn btn-default\" > 重置FormData </ button > </ label > </ div > </ div > </ form > </ div > </ div > </ div > </ div > < script src = \"js/angular.min.js\" ></ script > < script > var userInfoModule = angular . module ( 'UserInfoModule' , []); userInfoModule . controller ( 'UserInfoCtrl' , [ '$scope' , function ( $scope ) { $scope . userInfo = { email : \"550488300@qq.com\" , password : \"550488300\" , autoLogin : true }; $scope . getFormData = function (){ console . log ( \"email:\" + $scope . userInfo . email + \";\" + \"password:\" + $scope . userInfo . password ); }; $scope . setFormData = function (){ $scope . userInfo . email = \"liulixiang1988@gmail.com\" ; $scope . userInfo . password = \"liulixiang1988\" ; $scope . userInfo . autoLogin = false ; console . log ( \"email:\" + $scope . userInfo . email + \";\" + \"password:\" + $scope . userInfo . password ); }; $scope . resetFormData = function (){ $scope . userInfo . email = \"550488300@qq.com\" ; $scope . userInfo . password = \"550488300\" ; $scope . userInfo . autoLogin = true ; console . log ( \"email:\" + $scope . userInfo . email + \";\" + \"password:\" + $scope . userInfo . password ); }; }]) </ script > </ body > </ html > ng-class div ng-class='{error: isError, warning:isWarning}'> 当isError为ture时，使用.error, 当isWaring为ture时，使用.waring ng-show， ng-hide <div ng-show='menuState.show'> 当 menuState.show 为true时显示，为false时隐藏; ng-hide与ng-show相反，为true时隐藏，为false时显示。","tags":"Web","url":"/angularjsxue-xi-bi-ji-03-shuang-xiang-shu-ju-bang-ding.html"},{"title":"AngularJS学习笔记02-路由、模块和依赖注入","text":"内容简介： AngularJS的模块化实现 一个完整项目结构 使用ngRoute进行视图之间的路由 一切都是从模块开始的 ng官方推荐的模块切分方式是什么？ 模块之间的依赖该怎么做？--依赖注入 1. 模块 模块就是功能的集合 2. 目录结构 BookStore |-app |-css |-img |-js |-app.js |-controllers.js |-directives.js |-filters.js |-services.js |-framework |-tpls//模板 |-index.html |-node_modules |-package.json 3. ngRoute进行视图之间的路由 var bookStoreApp = angular.module('bookStoreApp', ['ngRoute', 'ngAnimate', 'bookStoreCtrls', 'BookStoreFilters', 'bookStoreServices', 'bookStoreDirectives']); bookStoreApp.config(function( $ routeProvider ) { $ routeProvider . when ( '/hello' ,{ templateUrl : 'tpls/hello.html' , controller : 'HelloCtrl' }). when ( '/list' , { templateUrl : 'tpls/bookList.html' , controller : 'BookListCtrl' }). otherwise ({ redirectTo : '/hello' }) ; })","tags":"Web","url":"/angularjsxue-xi-bi-ji-02-lu-you-mo-kuai-he-yi-lai-zhu-ru.html"},{"title":"AngularJS学习笔记01-MVC","text":"0. 第一个AngularJs应用 <!DOCTYPE html> < html ng-app > < head > < meta charset = \"utf-8\" > < meta http-equiv = \"X-UA-Compatible\" content = \"IE=edge\" > < title > AngularJs Demo </ title > < script src = \"bower_components/angularjs/angular.min.js\" ></ script > </ head > < body > < input type = \"text\" ng-model = \"name\" >< br > < p > hello, {{ name }} </ p > </ body > </ html > 1. 为什么需要MVC? MVC只是手段，终极目标是模块化与复用。 2. 控制器(ng-controller) <body ng-app= \"helloAngularApp\" > <div ng-controller= \"HelloCtrl\" > <p> {{ greeting.text }} ,world! </p> <button ng-click= \"test()\" > test </button> </div> <script src= \"js/angular.min.js\" ></script> <script> var helloAngularApp = angular.module('helloAngularApp', []); helloAngularApp.controller('HelloCtrl', function ($scope) { $scope.greeting = { text:\"Hello\" }; $scope.test = function(){ alert(\"test\"); }; }) </script> </body> 2.1 注意点 不要视图去复用Controller，一个控制器只负责一小块视图； 不要在Controller中操作DOM，这不是控制器的职责 不要在Controller里做数据格式化，ng有很好用的表单格式 不要在Controller里做数据过滤，ng有$filter服务 一般来说，Controlle是不会相互调用的，控制器之间的交互会通过事件进行。 3. 模型Model(ng-model) <body ng-app > <div> <input type= \"text\" ng-model= \"greeting.text\" > <p> {{ greeting.text }} ,world! </p> </div> <script src= \"js/angular.min.js\" ></script> </body> 4. 视图View 通过指令实现 <body ng-app= \"helloAngularApp\" > <div> <hello></hello> </div> <script src= \"js/angular.min.js\" ></script> <script> var helloAngularApp = angular.module('helloAngularApp', []); helloAngularApp.directive('hello', function () { return { restrict: 'E', template:' <div> 大家好! </div> ', replace: true }; }) </script> </body> 5. $scope 注意：AngularJS的MVC是借助于$scope实现的!!! <body ng-app= \"helloAngularApp\" > <div ng-controller= \"GreetCtrl\" > Hello, {{ name }} ! </div> <div ng-controller= \"ListCtrl\" > <ol> <li ng-repeat= \"name in names\" > 姓名： {{ name }} 部门： {{ department }} </li> </ol> </div> <script src= \"js/angular.min.js\" ></script> <script> var helloAngularApp = angular.module('helloAngularApp', []); helloAngularApp.controller('GreetCtrl', function ($scope, $rootScope) { $scope.name = \"world\"; $rootScope.department = \"Angular\"; }); helloAngularApp.controller('ListCtrl', ['$scope', function ($scope) { $scope.names = [\"刘理想\", \"福宝\"]; }]); </script> </body> 5.1 事件在scope上的传播 <body ng-app= \"helloAngularApp\" > <div ng-controller= \"HelloCtrl\" > Root Scope <tt> My Event: </tt> count: {{ count }} <ul> <li ng-repeat= \"i in [1]\" ng-controller= \"HelloCtrl\" > <button ng-click= \"$emit('MyEvent')\" > $emit(\"MyEvent\") </button> <button ng-click= \"$broadcast('MyEvent')\" > $broadcast(\"MyEvent\") </button> <br> Middle scope: <tt> My Event: </tt> count: {{ count }} <ul> <li ng-repeat= \"i in [1, 2]\" ng-controller= \"HelloCtrl\" > Leaf scope: <tt> My Event: </tt> count: {{ count }} </li> </ul> </li> </ul> </div> <script src= \"js/angular.min.js\" ></script> <script> var helloAngularApp = angular.module('helloAngularApp', []); helloAngularApp.controller('HelloCtrl', function ($scope) { $scope.count = 0; $scope.$on('MyEvent', function(){ $scope.count++; }); }) </script> </body> $scope是什么： $scope是一个POJO(Plan Old JavaScript Object) \\(scope 提供了一些工具方法\\) watch()/$apply() $scope是表达式的执行环境(或称为作用域) $scope是一个树形结构，与DOM标签平行 子 \\(scope对象会继承父\\) scope上的属性和方法 每一个Angular应用都有一个根$scope对象，一般位于ng-app上 $scope可以传播事件，可以向上传播，也可以向下传播 $scope不仅是MVC的基础，也是后面实现双向数据绑定的基础 可以使用angular.element($0).scope()进行调试 6. $scope生命周期 创建 注册监控 检测模型变化 发出事件 销毁 if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) { var align = \"center\", indent = \"0em\", linebreak = \"false\"; if (false) { align = (screen.width < 768) ? \"left\" : align; indent = (screen.width < 768) ? \"0em\" : indent; linebreak = (screen.width < 768) ? 'true' : linebreak; } var mathjaxscript = document.createElement('script'); var location_protocol = (false) ? 'https' : document.location.protocol; if (location_protocol !== 'http' && location_protocol !== 'https') location_protocol = 'https:'; mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#'; mathjaxscript.type = 'text/javascript'; mathjaxscript.src = location_protocol + '//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; mathjaxscript[(window.opera ? \"innerHTML\" : \"text\")] = \"MathJax.Hub.Config({\" + \" config: ['MMLorHTML.js'],\" + \" TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },\" + \" jax: ['input/TeX','input/MathML','output/HTML-CSS'],\" + \" extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js'],\" + \" displayAlign: '\"+ align +\"',\" + \" displayIndent: '\"+ indent +\"',\" + \" showMathMenu: true,\" + \" messageStyle: 'normal',\" + \" tex2jax: { \" + \" inlineMath: [ ['\\\\\\\\(','\\\\\\\\)'] ], \" + \" displayMath: [ ['$$','$$'] ],\" + \" processEscapes: true,\" + \" preview: 'TeX',\" + \" }, \" + \" 'HTML-CSS': { \" + \" styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} },\" + \" linebreaks: { automatic: \"+ linebreak +\", width: '90% container' },\" + \" }, \" + \"}); \" + \"if ('default' !== 'default') {\" + \"MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {\" + \"var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;\" + \"VARIANT['normal'].fonts.unshift('MathJax_default');\" + \"VARIANT['bold'].fonts.unshift('MathJax_default-bold');\" + \"VARIANT['italic'].fonts.unshift('MathJax_default-italic');\" + \"VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');\" + \"});\" + \"}\"; (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript); }","tags":"Web","url":"/angularjsxue-xi-bi-ji-01-mvc.html"},{"title":"Java Web开发技术应用-过滤器","text":"1. Java过滤机制-声明周期 2. 第一个过滤器 1、创建一个过滤器类 ，继承自servlet下的Filter 2、重写三个方法init() doFilter() destroy()方法 （1）init()初始化：这个方法可以读取web.xml文件中的过滤器初始化参数。通过参数FilterConfig arg0可以获取更多参数 （2）doFIlter()核心：完成实际的过滤操作。当用户请求访问与过滤器【关联的URL】时，Web容器将先调用过滤器的doFilter方法，FilterChain arg2参数可以调用chain.doFilter方法，将请求传给下一个过滤器（或目标资源），或利用转发，重定向将请求转发给其他资源。 (3)web容器在消耗过滤器前调用该方法，用于释放过滤器占用的资源。（大多数情况用不到） 2.1 定义Filter package liulx . FilterDemo ; import javax.servlet. * ; import java.io.IOException ; public class FirstFilter implements Filter { public void destroy () { System . out . println ( \"Filter Destroy\" ); } public void doFilter ( ServletRequest req , ServletResponse resp , FilterChain chain ) throws ServletException , IOException { System . out . println ( \"Do filter before request\" ); chain . doFilter ( req , resp ); System . out . println ( \"Do filter after request\" ); } public void init ( FilterConfig config ) throws ServletException { System . out . println ( \"Init First Filter\" ); } } 2.2 Web.xml配置 过滤器能够改变用户请求的Web资源，也就是能够改变用户请求的路径。 过滤器不能直接返回数据，不能直接处理用户请求。 <filter> <filter-name> FirstFilter </filter-name> <filter-class> liulx.FilterDemo.FirstFilter </filter-class> </filter> <filter-mapping> <filter-name> FirstFilter </filter-name> <url-pattern> /index.jsp </url-pattern> </filter-mapping> 3. 过滤器链 3.1 多个过滤器 多个过滤器url-pattern一样时，服务器会按照web.xml中过滤器定义的先后顺序组装成一条链。 4. 过滤器的分类 Servlet2.5中包含4种过滤器 REQUEST 用户直接访问时,调用过滤器 INCLUDE 目标资源通过RequestDispatcher的include访问时，调用过滤器 FORWARD 目标资源通过RequestDispatcher的forward访问时，调用过滤器 ERROR 目标资源是通过声明式异常处理机制调用时，调用过滤器 <filter> <filter-name> FirstFilter </filter-name> <filter-class> liulx.FilterDemo.FirstFilter </filter-class> </filter> <filter> <filter-name> SecondFilter </filter-name> <filter-class> liulx.FilterDemo.SecondFilter </filter-class> </filter> <filter-mapping> <filter-name> FirstFilter </filter-name> <url-pattern> /index.jsp </url-pattern> <dispatcher> REQUEST </dispatcher> </filter-mapping> <filter-mapping> <filter-name> SecondFilter </filter-name> <url-pattern> /index.jsp </url-pattern> </filter-mapping> <error-page> <error-code> 404 </error-code> <location> /404.jsp </location> </error-page> <filter-mapping> <filter-name> ErrorFilter </filter-name> <url-pattern> /error.jsp </url-pattern> <dispatcher> ERROR </dispatcher> </filter-mapping> Servlet 3.0 ASYNC标记：异步处理 5 Servlet 3.0 @WebFilter注解 @WebFilter(servletNames={\"SimpleServlet\"}, filterName=\"SimpleFilter\") public class LessThanSixFilter implements Filter{ ... }","tags":"Java","url":"/java-webkai-fa-ji-zhu-ying-yong-guo-lu-qi.html"},{"title":"Sass和Compass必备技能之Compass篇-02 模块简介","text":"1. Layout简介 http://compass-style.org/reference/compass/layout/ @import \"compass/layout\" @import \"compass/layout/grid-background\" @import \"compass/layout/sticky-footer\" @import \"compass/layout/stretching\" 2. CSS3模块 使用率最高的模块，提高跨浏览器的CSS3效果 http://compass-style.org/reference/compass/css3/ @import \"compass/css3\" ; . webdemo - sec { @ include box - shadow ( 1 px 1 px 3 px 2 px #cfcecf); } 3. Browser模块 有时，compass希望只支持特定的browser，使用browser即可。 @import \"compass/support\" ; $supported - browsers : chrome ; //最低版本 $browser - minimum - versions : ( \"ie\" : \"8\" ); 4. Typography模块 http://compass-style.org/reference/compass/typography/ @import \"compass/typography\"","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-compasspian-02-mo-kuai-jian-jie.html"},{"title":"Sass和Compass必备技能之Compass篇-01 Compass核心模块概述及Reset模块","text":"1. Compass核心模块 Reset( @import \"compass/reset\"; )和Layout( @import \"compass/layout\"; )并没有包含在compass的核心模块中，需要单独引用。 @import \"compass\"; 包含了CSS3/Helpers/Typography/Utilities模块： - CSS3模块 2. 使用normalize.css替换reset 《grunt beginer》 http://necolas.github.io/normalize.css/ 可以使用compass插件： 2.1 安装 gem install compass-normalize 2.2 在config.rb中引入 require 'compass-normalize' 注意：config.rb中的require 'compass/import-once/activate'是防止多次引入，如果需要多次引入，使用@import 'compass/reset!',即后面加上叹号 如果输出格式是压缩的，在注释的最前面加一个感叹号 /*!注释*/ . 有时，你并不想全部使用normalize所有的模块，那么可以分别引入normalize的模块，normalize有以下8个模块： 引入方式：先引入 @import \"normalize-version\"; 然后引入要使用的模块 @import \"normalize/base\"; //@import \"normalize\"; //or @import \"normalize-version\" ; //base @import \"normalize/base\" ; /*link*/ @import \"normalize/links\" ; 2.3 在sass页面中使用 reset的mixin和normalize里相对应 使用方法： @import \"compass/reset/utilities\" ; . test - reset - box - model { @ include reset - box - model ; } 文档：http://compass-style.org/","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-compasspian-01-compasshe-xin-mo-kuai-gai-shu-ji-resetmo-kuai.html"},{"title":"Android学习笔记-08 ImageView控件","text":"","tags":"Android","url":"/androidxue-xi-bi-ji-08-imageviewkong-jian.html"},{"title":"Android学习笔记-07 Android 目录结构","text":"src存放源代码 gen存放系统自动生成的配置文件 Android4.2下含android.jar包文件，所需的SDK assets存放资源文件，不会自动生成id且不会自动占用空间，没有应用时不会占空间 bin存放被编译生成的可执行文件.apk libs里放一些jar包 res存放所有资源。如图片等，res有多大，生成的APK就有多大 drawable存放不同密度的图片资源，不同分辨率的设备，不同分辨率的图片 layout存放布局文件。xml文件 values存放字符串，主题，颜色，样式等资源，对应3.0版本，v11对应3.0和v14对应4.0 menu菜单布局文件 androidmanifest.xml清单文件，先执行的清单文件，配置一些与应用有关的重要信息，包含包名，权限，程序组件等等","tags":"Android","url":"/androidxue-xi-bi-ji-07-android-mu-lu-jie-gou.html"},{"title":"Sass和Compass必备技能之Sass篇-04 Sass语法介绍(高级篇)","text":"1. @media sass中的@media跟CSS区别： sass中的media query可以内嵌在css规则中，在生成CSS的时候， media query 才会被提到样式的最高级 好处：避免了重复书写选择器或者打乱样式表的流程。 @mixin col ($ width ) { @media ( min-width : 768px ) { width : $ width ; float : left ; } } 2. @at-root 指定嵌套的内容生成CSS时，在最底层 .main-sec { font-family: $main-sec-ff ; @ at-root { .main-sec-headline { font: { family: $main-sec-ff ; size: 16 px ; } } .main-sec-detail { font-size: 12 px ; } } } 3. 逻辑 @mixin col ($ width ) { @if type-of ($ width ) != number { @error \"$width必须是数值类型，你输入的width是#{$width}\" ; } @if not unitless ($ width ) { @if unit ($ width ) != \"%\" { @error \"$width应该是一个百分值，你输入的是#{$width}\" ; } } @else { @warn \"$width应该是一个百分之，你输入的是#{$width}\" ; $ width : percentage ($ width )/ 100 ; } } @each @for @while 4. 输出格式 打开config.rb output_style = :expanded or :nested or :compact or :compressed","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-sasspian-04-sassyu-fa-jie-shao-gao-ji-pian.html"},{"title":"Sass和Compass必备技能之Sass篇-03 Sass语法介绍(进阶篇)","text":"1. 变量操作 变量操作有两种方式，第一种是直接操作，第二种是通过函数。 通过函数： - 跟代码块无关的函数，多是自己内置函数，称functions - 可重用的代码块，称mixin: @include和 @extand的方式来应用， 运算符： >= <= > < == != () CSS3增加了HSL的颜色，SASS会自动转换HSL为RGB,完美解决兼容。 sass支持@function来声明函数。 2. 混合器mixin和include @mixin 来定义混合器 @include 来使用混合器 // 声明 @mixin col-6 { width : 50 %; float : left ; } // 调用 .webdemo-sec { @ include col -6 (); // 括号可以省略 &: hover { background-color : #F5F5F5 ; } } 2.1 何时使用混合器 如果你能找到一个很好的短名字来描述属性样式，比如 rounded-corners ， fancy-font 或者 no-bullets ，那么往往能够构造一个合适的混合器。 混合器和类名的区别是，类名往往是语义化的，而混合器是展示性的描述。 CSS中class最好使用语义化的命名。IE6不支持多个class。 2.2 给混合器传参 带参数以及默认参数： @mixin col ($ width :50 %) { width : $ width ; float : left ; } .webdemo-sec { @ include col ( 30% ); &: hover { background-color : #F5F5F5 ; } } 默认参数也可以这样： @mixin link-color ($ normal , $ hover : $ normal , $ visited : $ hover ) { color : $ normal ; & :hover { color : $ hover ;} & :visited { color : $ visited ;} } 调用可以这样： @include link-color(red) ， $hover 和 $visited 也会被自动赋值为 red 3. 使用选择器继承来精简CSS 选择器继承是说一个选择器可以继承了另一个选择器定义的所有样式，通过 @extend 来实现。 .error { color: #f00; } .serious-error { @ extend .error ; border: 1 px solid #f00; } 任何跟 .error 有关的组合选择器也会被 .serious-error 以组合选择器的形式继承。 .error a { //应用到 .serious-error a color: red ; font-weight: bold ; } h1.error { //应用到 h1.serious-error font-size: 1 .3em ; } 3.1 何时使用继承 当一个元素拥有的类似另一个类的细化，这时候使用继承比较合适。 extend两个知识点： 1. extend不可以继承选择器序列 2. %仅用来被继承，如 %error ，则不会输出到css中。","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-sasspian-03-sassyu-fa-jie-shao-jin-jie-pian.html"},{"title":"Sass和Compass必备技能之Sass篇-02 Sass语法介绍(基础篇)","text":"1. sass和scss形式的相互转换 $ sass -convert main.sass main.scss 或者 $ sass -convert main.scss main.sass 2. 创建应用 $ compass create learn-sass-syntax $ cd learn-sass-syntax $ compass watch 3. 语法 SASS CSS默认都是UTF-8，所以写不写 @charset \"UTF-8\" 编码问题，如果出现中文编译失败，打开 rubygems\\gems\\sass\\lib\\sass\\engine.rb 文件，在require后面添加 Encoding.default_external=Encoding.find('utf-8') 。 3.1 引用@import 使用下划线命名的文件比如_variables.scss，sass称为 局部文件 ，是用到其它文件中的。如果在其他文件中引用，请使用: @import \"variables\" ; 这个不是css中的import，css中的import指令有两大弊端，一，必需放在文件行首； 二，只有执行到对应行中才加载（这导致页面加载特别慢） sass中的import是引入文件到宿主文件,也就是说在生成CSS的时候就把相关文件导入进来。可以使用配置选项配置路径。 @import \"compass/reset\"; 使用normalize来统一，比较好。 使用CSS原声@import的既定规则： - @import后跟.css结尾的时候 - @import后跟http://开头的字符串 - @import 跟url() - @import 后带有media queries 注意sass的@import既定规则： 1. 没有文件后缀名的时候，sass会添加.scss或者.sass的后缀 2. 统一目录下，局部文件和非局部文件不能重名 3. 可以同时import多个文件: @import \"variables\", \"compass/reset\"; 3.1.1 使用Sass局部文件 Sass局部文件的文件名以下划线开头。Sass不会将局部文件编译成单独的文件，而只把这个文件用于导入。导入局部文件不用输入下划线，比如有一个局部文件 themes/_night-sky.scss ，导入这个文件只需要 @import \"themes/night-sky\"; 3.1.2 默认变量值 使用 !default 来声明默认变量，作用是：如果这个变量被声明赋值了，就用它声明的值，否则就用这个默认值。 $ fancybox-width : 400px ! default ; .fancybox { width : $ fancybox - width ; } 如果用户在导入你的Sass局部文件之前声明了 $fancybox-width 变量，那么你的局部文件中对 $fancybox-width 赋值400px就无效。如果用户没有做这样的声明，则 $fancybox-width 将默认为400px. 3.1.3 嵌套导入 比如有一个 _blue-theme.scss 的文件，内容如下： aside { background : blue ; color : white ; } 然后导入到一个CSS规则内： . blue - theme { @import \"blue-hteme\" ;} 被翻译成： .blue-theme { aside { background: blue ; color: #fff; } } 3.2 变量声明 $ headline-ff : Braggadocio , Arial , Verdana , Helvetica , sans-serif ; $ main-sec-ff : Arial , Verdana , Helvetica , sans-serif ; 变量声明中用中划线和下划线的变量是相同的，比如 $link-color 和 $link_color 是同一个变量。除了变量，后面介绍的混合器也使这样。 3.3 注释 /*会被引用到编译后的css文件中*/ // 不会被引用到对应的 css文件中 3.4 嵌套CSS规则 类似LESS .main-sec { font-family: $main-sec-ff ; .headline { font-family: $main-sec-ff ; } } 3.4.1 父类选择器& 同LESS的& 3.4.2 群组选择器的嵌套 .container { h1 , h2 , h3 { margin-bottom : .8em ;} } 被翻译成： .container h1 , .container h2 , .container h3 { margin-bottom : .8em ;} 同样的， nav, aside { a {color: blue} } 被翻译成： nav a , aside a { color : blue ;} 3.4.3 子组合选择器和同层组合选择器 : >, + 和 ~ > 是直接子元素选择： article > section . + 同层相邻组合选择器 ~ 同层全体组合选择器 article { ~ article { border-top : 1px dashed #ccc ;} > section { background : #eee ;} dl > { dt { color : #333 ;} dd { color : #555 ;} } nav + & { margin-top : 0 ;} } 3.4.2 属性嵌套 LESS中没有这个， 注意要用冒号 。 nav { border : { style : solid ; width : 1px ; color : #ccc ; } } 被翻译成： nav { border-style : solid ; border-width : 1px ; border-color : #ccc ; } 甚至可以这样： nav { border : 1px solid #ccc { left : 0px ; right : 0px ; } } 翻译为： nav { border : 1px solid #ccc ; border-left : 0px ; border-right : 0px ; }","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-sasspian-02-sassyu-fa-jie-shao-ji-chu-pian.html"},{"title":"Sass和Compass必备技能之Sass篇-01 安装","text":"1. ruby安装 RVM: Ruby Version Manager（Ruby多版本管理器） 安装RVM mac下安装homebrew cakebrew $ gem sources --remove https://rubygems.org/ $ gem sources -a https://ruby.taobao.org/ $ gem sources -l *** CURRENT SOURCES *** https://ruby.taobao.org # 请确保只有 ruby.taobao.org $ gem install rails #安装 $ gem update #更新 $ gem install sass --version = 3.3 $gem uninstall sass 2. 安装sass $ gem install sass $ gem install sass --version=3.3 $ sass -v 3. 创建sass mkdir learn-sass-cli cd learn-sas-cli 创建main.scss * { margin : 0 ; padding : 0 ; } 编译 sass main.scss main.css 多了一个main.css.map文件用来存放映射 .sass-cache是用来存放编译临时文件，不用管它。 4. 安装和使用compass gem isntall compass compass create learn-compass-init #编译的两种方法 compass compile [path/to/project] compass watch [path/to/project]","tags":"Web","url":"/sasshe-compassbi-bei-ji-neng-zhi-sasspian-01-an-zhuang.html"},{"title":"Java Web之Servlet-02 应用MVC架构实现项目","text":"1. 获取初始化参数 <servlet> <init-param> <param-name> username </param-name> <param-value> admin </param-value> </init-param> <init-param> <param-name> password </param-name> <param-value> 123456 </param-value> </init-param> </servlet> 在servlet的init()方法中获取初始化的值： this.getInitParameter(\"username\"); this.getInitParameter(\"password\");","tags":"Java","url":"/java-webzhi-servlet-02-ying-yong-mvcjia-gou-shi-xian-xiang-mu.html"},{"title":"Java Web之Servlet-01 Servlet基础","text":"1. Servlet概述 jsp前身就是servlet，Servelet是在服务器上运行的小程序。 一个Servlet就是一个Java类，并且可以通过\"请求－响应\"编程模型来访问的这个驻留在服务器内存里的Servlet程序。 2. Tomcat容器等级 Tomcat在大多数情况下充当servlet的容器，也就是说：在写完JSP代码后进行第一次执行时，tomcat（servlet容器）先将JSP代码翻译成servlet类（java代码），然后实例化该类，再调用该类的init,service,destory等进行生命周期服务。当客户端再进行第二次访问请求时，此时就没有servlet容器的翻译这一步了，因为之前翻译的java代码会一直保存，以便于后面的访问不再进行翻译，可大大提高访问效率。所以，JSP页面在第一次被访问时，其所花费的时间是最长的。 最主要的方法就是init,service和destroy，它们是servlet对象的生存周期，当一个页面被编译成servlet类，再进行实例化后，这个页面就开始了真正的生命周期，servlet容器会先加载init方法进行初始化，初始化后才可进行接收和相应客户端的消息，之后容器会再加载service，这部分就是真正相应客户端请求的实现逻辑，它实现客户端的请求响应，然后动态生成HTML页面显示到客户端；而destory方法则是在servlet生命周期即将结束时进行的清理工作。 3. 手工编写第一个Servlet 继承HttpServlet 重写doGet()或者doPost()：右键->source->重写 在web.xml中注册servlet 问题解析： 1、向页面输出html语言 response.setContentType(\"text/html;charset=utf-8\"); 2、在配置web.xml中 <servlet> <servlet-name> HelloServlet </servlet-name> <servlet-class> servlet.helloServlet </servlet-class> </servlet> <servlet-mapping> <servlet-name> HelloServlet </servlet-name> <url-pattern> /servlet/HelloServlet </url-pattern> //根目录下的路径信息 </servlet-mapping> web.xml中Servlet的配置说明： 1、 <servlet> 标签中 <servlet-name> 指定servlet名称， <servlet-class> 指定servlet类，需要使用完整类名 2、 <servlet-mapping> 标签中 <servlet-name> 指定servlet名称，需要与 <servlet> 标签中的相应servlet名称对应； <url-pattern> 指定servlet地址，在Jsp页面中使用的URL需要与相应servlet的地址对应 4. Servlet生命周期 初始化阶段，调用init()方法。 响应客户端请求，调用service()方法，有service方法根据提交方式，决定使用doGet()还是doPost()方法。 终止阶段，看服务器是否关闭，如果要关闭，那么就要调用destroy()方法。 HttpServlet的两个Service()方法区别 在HttpServlet类中有两个service()方法，如下： void service(ServletRequest req, ServletResponse res) protected void service(HttpServletRequest req, HttpServletResponse resp) 其中只有void service(ServletRequest req，ServletResponse response)方法是由tomcat自动调用，它将接收的客户端请求转交给HttpServlet中的另一个protected void service(HttpServletRequest req，HttpServletResponse res)方法，此保护类型的service方法再把将请求分发给doPost()、doGet()方法进行下一步处理。所以我们完全可以重写受保护的service()方法来代替doPost()和doGet()方法。 5. tomcat装在servlet的三种情况 servlet容器启动时自动装在某些servlet，实现它只需要在web.xml文件中的 <servlet></servlet> 之间添加如下代码： <load-on-startup>1<load-on-startup> ，其中数字越大表示优先级别越高。 在servlet容器启动后，客户首次向servlet发送请求。 servlet类被更新后，重新装在servlet。 注意 ，在整个生命周期类，init()方法只被调用一次。如果用粗暴的方法关闭服务器就不会调用destroy()方法。 6. Servlet与jsp内置对象的关系 out 是jspwriter 对象； resp.getWriter是 PrintWriter对象 7. Servlet获取表单数据 获取一个值的时候用request.getParameter(\"name名\"); 获取一个复选框里面的多个值时用request.getParameterValues(\"name名\"); Servlet跳转类似jsp 对于boolean类型的值，不要使用is，否则java bean中生成的不是get开头的属性。 8. Servlet的路径跳转 8.1 JSP跳转到Servlet 1、相对路径,如 href=\"servlet/TestServlet\" ***注意：如果写成 /servlet/TestServlet 会报错，因为第一个'/'表示的是【服务器根目录： http://localhost:8080/ 】 2、绝对路径，通过内置成员变量path实现，如 href=\"<%=path%>/servlet/TestServlet\" 。 注意：这里的path得到的是项目根目录，如【 http://localhost:8080/Servlet002_GetFormDemo 】 8.2 Servlet跳转JSP 1、请求重定向： response.sendRedirect(request.getContextPath()+\"/xxx.jsp\"); 这里通过 request.getContextPath() 方法获得项目根目录，或者通过 ../xxx.jsp 取得上层路径得到 2、服务器内部转发： request.getRequestDispatcher(\"../xxx.jsp\").forward(req,resp); 小结：都可以通过../xxx.jsp得到","tags":"Java","url":"/java-webzhi-servlet-01-servletji-chu.html"},{"title":"Java Web之JSP-07 综合案例","text":"1. JDBC DBHelper package util ; import java.sql.Connection ; import java.sql.DriverManager ; public class DBHelper { private static final String driver = \"com.mysql.jdbc.Driver\" ; // 数据库驱动 // 连接数据库的 URL地址 private static final String url = \"jdbc:mysql://localhost:3306/shopping?useUnicode=true&characterEncoding=UTF-8\" ; private static final String username = \"root\" ; // 数据库的用户名 private static final String password = \"\" ; // 数据库的密码 private static Connection conn = null ; // 静态代码块负责加载驱动 static { try { Class . forName ( driver ); } catch ( Exception ex ) { ex . printStackTrace (); } } // 单例模式返回数据库连接对象 public static Connection getConnection () throws Exception { if ( conn == null ) { conn = DriverManager . getConnection ( url , username , password ); return conn ; } return conn ; } public static void main ( String [] args ) { try { Connection conn = DBHelper . getConnection (); if ( conn != null ) { System . out . println ( \"数据库连接正常！\" ); } else { System . out . println ( \"数据库连接异常！\" ); } } catch ( Exception ex ) { ex . printStackTrace (); } } } 2. 实体类 package entity; //商品类 public class Items { private int id; // 商品编号 private String name; // 商品名称 private String city; // 产地 private int price; // 价格 private int number; // 库存 private String picture; // 商品图片 public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getCity() { return city; } public void setCity(String city) { this.city = city; } public int getPrice() { return price; } public void setPrice(int price) { this.price = price; } public int getNumber() { return number; } public void setNumber(int number) { this.number = number; } public String getPicture() { return picture; } public void setPicture(String picture) { this.picture = picture; } } 3. DAO package dao ; import java.sql.Connection ; import java.sql.PreparedStatement ; import java.sql.ResultSet ; import java.util.ArrayList ; import util.DBHelper ; import entity.Items ; // 商品的业务逻辑类 public class ItemsDAO { // 获得所有的商品信息 public ArrayList < Items > getAllItems () { Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; ArrayList < Items > list = new ArrayList < Items > (); // 商品集合 try { conn = DBHelper . getConnection (); String sql = \"select * from items;\" ; // SQL语句 stmt = conn . prepareStatement ( sql ); rs = stmt . executeQuery (); while ( rs . next ()) { Items item = new Items (); item . setId ( rs . getInt ( \"id\" )); item . setName ( rs . getString ( \"name\" )); item . setCity ( rs . getString ( \"city\" )); item . setNumber ( rs . getInt ( \"number\" )); item . setPrice ( rs . getInt ( \"price\" )); item . setPicture ( rs . getString ( \"picture\" )); list . add ( item ); // 把一个商品加入集合 } return list ; // 返回集合。 } catch ( Exception ex ) { ex . printStackTrace (); return null ; } finally { // 释放数据集对象 if ( rs != null ) { try { rs . close (); rs = null ; } catch ( Exception ex ) { ex . printStackTrace (); } } // 释放语句对象 if ( stmt != null ) { try { stmt . close (); stmt = null ; } catch ( Exception ex ) { ex . printStackTrace (); } } } } // 根据商品编号获得商品资料 public Items getItemsById ( int id ) { Connection conn = null ; PreparedStatement stmt = null ; ResultSet rs = null ; try { conn = DBHelper . getConnection (); String sql = \"select * from items where id=?;\" ; // SQL语句 stmt = conn . prepareStatement ( sql ); stmt . setInt ( 1 , id ); rs = stmt . executeQuery (); if ( rs . next ()) { Items item = new Items (); item . setId ( rs . getInt ( \"id\" )); item . setName ( rs . getString ( \"name\" )); item . setCity ( rs . getString ( \"city\" )); item . setNumber ( rs . getInt ( \"number\" )); item . setPrice ( rs . getInt ( \"price\" )); item . setPicture ( rs . getString ( \"picture\" )); return item ; } else { return null ; } } catch ( Exception ex ) { ex . printStackTrace (); return null ; } finally { // 释放数据集对象 if ( rs != null ) { try { rs . close (); rs = null ; } catch ( Exception ex ) { ex . printStackTrace (); } } // 释放语句对象 if ( stmt != null ) { try { stmt . close (); stmt = null ; } catch ( Exception ex ) { ex . printStackTrace (); } } } } // 获取最近浏览的前五条商品信息 public ArrayList < Items > getViewList ( String list ) { System . out . println ( \"list:\" + list ); ArrayList < Items > itemlist = new ArrayList < Items > (); int iCount = 5 ; // 每次返回前五条记录 if ( list != null && list . length () > 0 ) { String [] arr = list . split ( \",\" ); System . out . println ( \"arr.length=\" + arr . length ); // 如果商品记录大于等于 5 条 if ( arr . length >= 5 ) { for ( int i = arr . length - 1 ; i >= arr . length - iCount ; i -- ) { itemlist . add ( getItemsById ( Integer . parseInt ( arr [ i ]))); } } else { for ( int i = arr . length - 1 ; i >= 0 ; i -- ) { itemlist . add ( getItemsById ( Integer . parseInt ( arr [ i ]))); } } return itemlist ; } else { return null ; } } } 4. index.jsp <% @ page language = \"java\" import = \"java.util.*\" contentType = \"text/html; charset=utf-8\" %> <% @ page import = \"entity.Items\" %> <% @ page import = \"dao.ItemsDAO\" %> <% String path = request . getContextPath (); String basePath = request . getScheme () + \"://\" + request . getServerName () + \":\" + request . getServerPort () + path + \"/\" ; %> <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"> <html> <head> <base href= \" <%= basePath %> \" > <title> My JSP 'index.jsp' starting page </title> <meta http-equiv= \"pragma\" content= \"no-cache\" > <meta http-equiv= \"cache-control\" content= \"no-cache\" > <meta http-equiv= \"expires\" content= \"0\" > <meta http-equiv= \"keywords\" content= \"keyword1,keyword2,keyword3\" > <meta http-equiv= \"description\" content= \"This is my page\" > <!-- <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"> --> <style type= \"text/css\" > div{ float:left; margin: 10px; } div dd{ margin:0px; font-size:10pt; } div dd.dd_name { color:blue; } div dd.dd_city { color:#000; } </style> </head> <body> <h1> 商品展示 </h1> <hr> <center> <table width= \"750\" height= \"60\" cellpadding= \"0\" cellspacing= \"0\" border= \"0\" > <tr> <td> <!-- 商品循环开始 --> <% ItemsDAO itemsDao = new ItemsDAO (); ArrayList < Items > list = itemsDao . getAllItems (); if ( list! = null && list . size () > 0 ) { for ( int i = 0 ; i < list . size (); i ++ ) { Items item = list . get ( i ); %> <div> <dl> <dt> <a href= \"details.jsp?id= <%= item . getId () %> \" ><img src= \"images/ <%= item . getPicture () %> \" width= \"120\" height= \"90\" border= \"1\" /></a> </dt> <dd class= \"dd_name\" > <%= item . getName () %> </dd> <dd class= \"dd_city\" > 产地: <%= item . getCity () %> &nbsp;&nbsp; 价格:￥ <%= item . getPrice () %> </dd> </dl> </div> <!-- 商品循环结束 --> <% } } %> </td> </tr> </table> </center> </body> </html> 5. detail.jsp <% @ page language = \"java\" import = \"java.util.*\" contentType = \"text/html; charset=utf-8\" %> <% @ page import = \"entity.Items\" %> <% @ page import = \"dao.ItemsDAO\" %> <% String path = request . getContextPath (); String basePath = request . getScheme () + \"://\" + request . getServerName () + \":\" + request . getServerPort () + path + \"/\" ; %> <!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\"> <html> <head> <base href= \" <%= basePath %> \" > <title> My JSP 'details.jsp' starting page </title> <meta http-equiv= \"pragma\" content= \"no-cache\" > <meta http-equiv= \"cache-control\" content= \"no-cache\" > <meta http-equiv= \"expires\" content= \"0\" > <meta http-equiv= \"keywords\" content= \"keyword1,keyword2,keyword3\" > <meta http-equiv= \"description\" content= \"This is my page\" > <!-- <link rel=\"stylesheet\" type=\"text/css\" href=\"styles.css\"> --> <style type= \"text/css\" > div{ float:left; margin-left: 30px; margin-right:30px; margin-top: 5px; margin-bottom: 5px; } div dd{ margin:0px; font-size:10pt; } div dd.dd_name { color:blue; } div dd.dd_city { color:#000; } </style> </head> <body> <h1> 商品详情 </h1> <hr> <center> <table width= \"750\" height= \"60\" cellpadding= \"0\" cellspacing= \"0\" border= \"0\" > <tr> <!-- 商品详情 --> <% ItemsDAO itemDao = new ItemsDAO (); Items item = itemDao . getItemsById ( Integer . parseInt ( request . getParameter ( \"id\" ))); if ( item! = null ) { %> <td width= \"70%\" valign= \"top\" > <table> <tr> <td rowspan= \"4\" ><img src= \"images/ <%= item . getPicture () %> \" width= \"200\" height= \"160\" /></td> </tr> <tr> <td><B> <%= item . getName () %> </B></td> </tr> <tr> <td> 产地： <%= item . getCity () %> </td> </tr> <tr> <td> 价格： <%= item . getPrice () %> ￥ </td> </tr> </table> </td> <% } %> <% String list = \"\" ; // 从客户端获得 Cookies集合 Cookie [] cookies = request . getCookies (); // 遍历这个 Cookies集合 if ( cookies! = null && cookies . length > 0 ) { for ( Cookie c : cookies ) { if ( c . getName () . equals ( \"ListViewCookie\" )) { list = c . getValue (); } } } list += request . getParameter ( \"id\" ) + \",\" ; // 如果浏览记录超过 1000 条，清零 . String [] arr = list . split ( \",\" ); if ( arr! = null && arr . length > 0 ) { if ( arr . length >= 1000 ) { list = \"\" ; } } Cookie cookie = new Cookie ( \"ListViewCookie\" , list ); response . addCookie ( cookie ); %> <!-- 浏览过的商品 --> <td width= \"30%\" bgcolor= \"#EEE\" align= \"center\" > <br> <b> 您浏览过的商品 </b><br> <!-- 循环开始 --> <% ArrayList < Items > itemlist = itemDao . getViewList ( list ); if ( itemlist! = null && itemlist . size () > 0 ) { System . out . println ( \"itemlist.size=\" + itemlist . size ()); for ( Items i : itemlist ) { %> <div> <dl> <dt> <a href= \"details.jsp?id= <%= i . getId () %> \" ><img src= \"images/ <%= i . getPicture () %> \" width= \"120\" height= \"90\" border= \"1\" /></a> </dt> <dd class= \"dd_name\" > <%= i . getName () %> </dd> <dd class= \"dd_city\" > 产地: <%= i . getCity () %> &nbsp;&nbsp; 价格: <%= i . getPrice () %> ￥ </dd> </dl> </div> <% } } %> <!-- 循环结束 --> </td> </tr> </table> </center> </body> </html>","tags":"Java","url":"/java-webzhi-jsp-07-zong-he-an-li.html"},{"title":"JDBC使用笔记","text":"1. JDBC编程步骤 加载驱动程序： Class.forName(driverClass) //加载MySql驱动 Class.forName(\"com.mysql.jdbc.Driver\") //加载Oracle驱动 Class.forName(\"oracle.jdbc.driver.OracleDriver\") 获得数据库连接： DriverManager .getConnection ( \"jdbc:mysql://127.0.0.1:3306/imooc\" , \"root\" , \"root\" ); 创建Statement\\PreparedStatement对象： conn.createStatement(); conn.prepareStatement(sql); 例子： import java.sql.Connection ; import java.sql.DriverManager ; import java.sql.ResultSet ; import java.sql.Statement ; public class DbUtil { public static final String URL = \"jdbc:mysql://localhost:3306/imooc\" ; public static final String USER = \"liulx\" ; public static final String PASSWORD = \"123456\" ; public static void main ( String [] args ) throws Exception { // 1. 加载驱动程序 Class . forName ( \"com.mysql.jdbc.Driver\" ); // 2. 获得数据库连接 Connection conn = DriverManager . getConnection ( URL , USER , PASSWORD ); // 3. 操作数据库，实现增删改查 Statement stmt = conn . createStatement (); ResultSet rs = stmt . executeQuery ( \"SELECT user_name, age FROM imooc_goddess\" ); // 如果有数据， rs . next () 返回 true while ( rs . next ()){ System . out . println ( rs . getString ( \"user_name\" ) + \" 年龄：\" + rs . getInt ( \"age\" )); } } } 2. 增删改查 public class DbUtil { public static final String URL = \"jdbc:mysql://localhost:3306/imooc\" ; public static final String USER = \"liulx\" ; public static final String PASSWORD = \"123456\" ; private static Connection conn = null ; static { try { // 1. 加载驱动程序 Class . forName ( \"com.mysql.jdbc.Driver\" ); // 2. 获得数据库连接 conn = DriverManager . getConnection ( URL , USER , PASSWORD ); } catch ( ClassNotFoundException e ) { e . printStackTrace (); } catch ( SQLException e ) { e . printStackTrace (); } } public static Connection getConnection (){ return conn ; } } // 模型 package liulx . model ; import java.util.Date ; public class Goddess { private Integer id ; private String user_name ; private Integer sex ; private Integer age ; private Date birthday ; // 注意用的是 java . util . Date private String email ; private String mobile ; private String create_user ; private String update_user ; private Date create_date ; private Date update_date ; private Integer isDel ; // getter setter方法 。。。 } //--------- dao层 -------------- package liulx . dao ; import liulx.db.DbUtil ; import liulx.model.Goddess ; import java.sql.Connection ; import java.sql.ResultSet ; import java.sql.SQLException ; import java.sql.Statement ; import java.util.ArrayList ; import java.util.List ; public class GoddessDao { // 增加 public void addGoddess ( Goddess g ) throws SQLException { // 获取连接 Connection conn = DbUtil . getConnection (); // sql String sql = \"INSERT INTO imooc_goddess(user_name, sex, age, birthday, email, mobile,\" + \"create_user, create_date, update_user, update_date, isdel)\" + \"values(\" + \"?,?,?,?,?,?,?,CURRENT_DATE(),?,CURRENT_DATE(),?)\" ; // 预编译 PreparedStatement ptmt = conn . prepareStatement ( sql ); // 预编译 SQL ，减少 sql执行 // 传参 ptmt . setString ( 1 , g . getUser_name ()); ptmt . setInt ( 2 , g . getSex ()); ptmt . setInt ( 3 , g . getAge ()); ptmt . setDate ( 4 , new Date ( g . getBirthday () . getTime ())); ptmt . setString ( 5 , g . getEmail ()); ptmt . setString ( 6 , g . getMobile ()); ptmt . setString ( 7 , g . getCreate_user ()); ptmt . setString ( 8 , g . getUpdate_user ()); ptmt . setInt ( 9 , g . getIsDel ()); // 执行 ptmt . execute (); } public void updateGoddess (){ // 获取连接 Connection conn = DbUtil . getConnection (); // sql , 每行加空格 String sql = \"UPDATE imooc_goddess\" + \" set user_name=?, sex=?, age=?, birthday=?, email=?, mobile=?,\" + \" update_user=?, update_date=CURRENT_DATE(), isdel=? \" + \" where id=?\" ; // 预编译 PreparedStatement ptmt = conn . prepareStatement ( sql ); // 预编译 SQL ，减少 sql执行 // 传参 ptmt . setString ( 1 , g . getUser_name ()); ptmt . setInt ( 2 , g . getSex ()); ptmt . setInt ( 3 , g . getAge ()); ptmt . setDate ( 4 , new Date ( g . getBirthday () . getTime ())); ptmt . setString ( 5 , g . getEmail ()); ptmt . setString ( 6 , g . getMobile ()); ptmt . setString ( 7 , g . getUpdate_user ()); ptmt . setInt ( 8 , g . getIsDel ()); ptmt . setInt ( 9 , g . getId ()); // 执行 ptmt . execute (); } public void delGoddess (){ // 获取连接 Connection conn = DbUtil . getConnection (); // sql , 每行加空格 String sql = \"delete from imooc_goddess where id=?\" ; // 预编译 SQL ，减少 sql执行 PreparedStatement ptmt = conn . prepareStatement ( sql ); // 传参 ptmt . setInt ( 1 , id ); // 执行 ptmt . execute (); } public List < Goddess > query () throws SQLException { Connection conn = DbUtil . getConnection (); Statement stmt = conn . createStatement (); ResultSet rs = stmt . executeQuery ( \"SELECT user_name, age FROM imooc_goddess\" ); List < Goddess > gs = new ArrayList < Goddess > (); Goddess g = null ; while ( rs . next ()){ g = new Goddess (); g . setUser_name ( rs . getString ( \"user_name\" )); g . setAge ( rs . getInt ( \"age\" )); gs . add ( g ); } return gs ; } public Goddess get (){ Goddess g = null ; // 获取连接 Connection conn = DbUtil . getConnection (); // sql , 每行加空格 String sql = \"select * from imooc_goddess where id=?\" ; // 预编译 SQL ，减少 sql执行 PreparedStatement ptmt = conn . prepareStatement ( sql ); // 传参 ptmt . setInt ( 1 , id ); // 执行 ResultSet rs = ptmt . executeQuery (); while ( rs . next ()){ g = new Goddess (); g . setId ( rs . getInt ( \"id\" )); g . setUser_name ( rs . getString ( \"user_name\" )); g . setAge ( rs . getInt ( \"age\" )); g . setSex ( rs . getInt ( \"sex\" )); g . setBirthday ( rs . getDate ( \"birthday\" )); g . setEmail ( rs . getString ( \"email\" )); g . setMobile ( rs . getString ( \"mobile\" )); g . setCreate_date ( rs . getDate ( \"create_date\" )); g . setCreate_user ( rs . getString ( \"create_user\" )); g . setUpdate_date ( rs . getDate ( \"update_date\" )); g . setUpdate_user ( rs . getString ( \"update_user\" )); g . setIsDel ( rs . getInt ( \"isdel\" )); } return g ; } }","tags":"Java","url":"/jdbcshi-yong-bi-ji.html"},{"title":"Java Web之JSP-06 JSP指令与动作元素","text":"1. include指令 常用的有page、include、taglib指令这三种指令； page：位于页面顶端，一个页面可以包含多个page指令 include：将一个外部文件嵌入jsp中，同时解析这个页面中的jsp语句。 taglib：使用标签库，自定义新的标签，在jsp中启动定制行为。 语法 <% include file=\"地址\"%> 。 案例：显示当前时间的页面。 （1）写一个只输出时间的方法的date.jsp。 （2）用于显示的页面,包含 <% include file=\"date.jsp\"%> 2. include动作 是一个动作标签 <jsp:xxx> 语法： <jsp:include page=\"URL\" flush=\"true|false\"> page属性：要包含的页面 flush属性：被包含的页面是否从缓冲区里读取 3. include指令和动作的区别 包含内容： 指令包含的是【源代码】，动作包含的是页面输出的【结果】 生成的servlet：指令会生成一个整体的Servlet；而动作会分别生成两个，即在一个Servlet中调用另一个Servlet 其他区别如图： 使用场合】：页面内容不经常变化使用include指令，页面内容经常变化使用 <jsp:include> 动作 4. forward指令 forward动作 1、语法： <jsp:forward page=\"URL\"/> 2、等于服务器内部转发指令 request.getRequestDispacher(\"URL\").forward(req,res); 相当于是服务器内部跳转，URL地址不会发生变化。 四种跳转. <% response.sendRedirect(\"login_seccess.jsp\"); %> //告诉浏览器此路不通,你再问问另一页面能解决你的问题不? <jsp:forward page=\"login_fail.jsp\"/> //服务器将请求转发到另一页面,浏览器不知情. <% pageContext.forward(\"login_fail.jsp\");%> //服务器将请求转发到另一页面,浏览器不知情. <% request.getRequestDispatcher(\"login_fail.jsp\").forward(request,response);%> //服务器将请求转发到另一页面,浏览器不知情. 5. param动作 语法： <jsp:param name=\"参数名\" value=\"参数值\"> 【常常与 <jsp:forward></jsp:forward> 一起使用】，并作为其【子标签】。 用于传递新参数或者【修改原有参数值】，修改参数时使用form表单里的参数名称即可。同样用request.getParameter(\"参数名\")获取 必须与forward、include及plugin动作配合使用。通常与forward动作一起使用，作为它的子标签，它的作用是指定某个参数值，可以用于传递参数. <jsp:forward page= \"url\" > <jsp:param value= \"123@qq.com\" name= \"email\" /> </jsp:forward>","tags":"Java","url":"/java-webzhi-jsp-06-jspzhi-ling-yu-dong-zuo-yuan-su.html"},{"title":"Java Web之JSP-05 JSP状态管理","text":"1. http协议的无状态性 无状态是指，当浏览器发送请求给服务器的时候，服务器会响应。但当同一个浏览器再次发送请求时，服务器不会知道是刚才那个浏览器。 简单说，服务器【不会保存用户状态】，不会记得客户端是否访问过，所以这就是无状态协议。 2. Cookie概述 保存用户的状态的两大机制：session ，cookie cookie作用: 对特定对象的追踪 保存用户网页浏览记录与习惯 简化登录 安全风险：容易泄露用户信息 典型应用一：判断注册用户是否已经登录网站 典型应用二：\"购物车\"的处理 3. JSP页面中创建和使用Cookie 创建Cookie对象： Cookie cookie = new Cookie(String key , Object value); 写入Cookie对象： response.addCookie(cookie); 读取Cookie对象： Cookie[] cookies = request.getCookies(); Cookie常用方法： void setMaxAge(int expiry) 设置cookie的有效期，以秒为单位 void setValue(String value) 在cookie创建后，对cookie进行赋值 String getValue() 获取cookie的值 int getMaxAge() 获取cookie的有效时间，以秒为单位 4. 案例：Cookie在登录中的应用 java.net包中的URLEncoder和URLDecoder可以用来编码和解码，避免出现中文乱码问题 String username = URLEncoder.encode(request.getParameter(\"username\"),\"utf-8\");//编码，防止中文乱码 login.jsp <% @ page import = \"java.net.URLDecoder\" %> <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title> cookie登录 </title> </head> <body> <% request . setCharacterEncoding ( \"utf-8\" ); String username = \"\" ; String password = \"\" ; Cookie [] cookies = request . getCookies (); if ( cookies != null && cookies . length > 0 ){ for ( Cookie c : cookies ){ if ( c . getName () . equals ( \"username\" )){ username = URLDecoder . decode ( c . getValue (), \"utf-8\" ) ; } if ( c . getName () . equals ( \"password\" )){ password = URLDecoder . decode ( c . getValue (), \"utf-8\" ) ; } } } %> <form action= \"dologin.jsp\" method= \"post\" > <input type= \"text\" name= \"username\" placeholder= \"用户名\" value= \" <%= username %> \" /><br/> <input type= \"password\" name= \"password\" placeholder= \"密码\" value= \" <%= password %> \" /><br/> <input type= \"checkbox\" name= \"isUseCookie\" checked= \"checked\" /> 记住我 <input type= \"submit\" value= \"登录\" /> </form> </body> </html> dologin.jsp <% @ page import = \"java.net.URLEncoder\" %> <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title> 登录 </title> </head> <body> <h1> 登录成功 </h1> <hr/> <% request . setCharacterEncoding ( \"utf-8\" ); String [] isUseCookies = request . getParameterValues ( \"isUseCookie\" ); if ( isUseCookies != null && isUseCookies . length > 0 ){ // 保存 cookie String username = URLEncoder . encode ( request . getParameter ( \"username\" ), \"utf-8\" ) ; String password = URLEncoder . encode ( request . getParameter ( \"password\" ), \"utf-8\" ); Cookie usernameCookie = new Cookie ( \"username\" , username ); Cookie passwordCookie = new Cookie ( \"password\" , password ); usernameCookie . setMaxAge ( 864000 ); // 10 天过期 passwordCookie . setMaxAge ( 864000 ); response . addCookie ( usernameCookie ); response . addCookie ( passwordCookie ); } else { // 清楚 cookie Cookie [] cookies = request . getCookies (); if ( cookies != null && cookies . length > 0 ){ for ( Cookie c : cookies ){ if ( c . getName () . equals ( \"username\" ) || c . getName () . equals ( \"password\" )){ c . setMaxAge ( 0 ); response . addCookie ( c ); // 设置好 cookie后还要添加进去 } } } } %> <a href= \"user.jsp\" > 查看用户 </a> </body> </html> user.jsp <% @ page import = \"java.net.URLDecoder\" %> <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title> 用户信息 </title> </head> <body> <% request . setCharacterEncoding ( \"utf-8\" ); String username = \"\" ; String password = \"\" ; Cookie [] cookies = request . getCookies (); if ( cookies != null && cookies . length > 0 ){ for ( Cookie c : cookies ){ if ( c . getName () . equals ( \"username\" )){ username = URLDecoder . decode ( c . getValue (), \"utf-8\" ) ; } if ( c . getName () . equals ( \"password\" )){ password = URLDecoder . decode ( c . getValue (), \"utf-8\" ) ; } } } %> <input type= \"text\" name= \"username\" placeholder= \"用户名\" value= \" <%= username %> \" /><br/> <input type= \"password\" name= \"password\" placeholder= \"密码\" value= \" <%= password %> \" /><br/> </body> </html>","tags":"Java","url":"/java-webzhi-jsp-05-jspzhuang-tai-guan-li.html"},{"title":"Java Web之JSP-03 JSP内置对象","text":"1. jsp内置对象简介 1、JSP内置对象是Web容器创建的一组对象，【不使用new关键字】就可以使用的内置对象。 2、九大内置对象: out,request,response,session,application（五大常用对象） Page,pageContext,exception.config（四个不太常用对象） 2. out对象 缓冲区Buffer：就是内存的一块区域涌来保存临时数据。 out是JspWriter 的实例,是向客户端输出内容的常用对象. 常用方法: void println() 向客户端打印字符串. void clear() 清除缓冲区,在flush之后调用会抛出异常. void clearBuffer() 清除缓冲区,在flush之后调用不会抛出异常. void flush() 将缓冲区内容输出到客户端. int getBufferSize() int getRemaining() boolean isAutoFlush() 返回缓冲区满时，是自动清空还是抛出异常 void close() 关闭输出流 3. Get和Post提交方式的区别 表单有两种提交方式：get与post。定义在 <form action=\"dologin.jsp\" name=\"loginForm\" method=\"提交方式***\"></form> 动作／名称等顺序无所谓。 1.get：以【明文】方式，通过URL提交数据，数据在URL中【可以看到】。提交数据最多不超过【2KB】。安全性较低，但效率比post方式高。适合提交数据量不大，且安全要求不高的数据：比如：搜索、查询等功能。 2.post：将用户提交的信息封装在HTML HEADER内。适合提交数据量大，安全性高的用户信息。如：注册、修改、上传等功能。 4. request对象 客户端的请求信息被封装在request对象中，它是HttpServletRequest类的实例。request对象具有请求域，即完成客户端的请求之前，该对象一直有效。常用方法如下： String getParameter(String name) 返回name制定的参数值 String[] getParameterValues(String name) 返回包含参数name的所有值的数组（如复选框的值）。 void setAttribute(String, Object) 存储此请求中的属性 object getAttribute(String name) 返回制定属性的属性值 String getContentType() 得到请求体的mime类型 String getProtocol() 返回请求用的协议类型及版本号 String getServerName() 返回接受请求的服务器主机名 int getServerPort();//返回服务器接受此请求所用的端口号 String getCharacterEncoding();//返回字符编码方式 void setCharacterEncodinng();//设置请求的字符编码方式 int getContentLength();//返回请求体的长途(以字节数) String getRemoteAddr();//返回发送此请求的客户端IP地址,IP地址为IPv6本地环回地址。 String getRealPath(String path);//返回虚拟路径的真实路径 String request.getContextPath();//返回上下文路径 使用关键： 1. 单个参数的获取使用getParameter(String name), 多个参数的获取getParameterValues(String name)。在使用这两个方法是，需传递对应的参数name，这个name应是在表格中声明的对象。 2. 不存在参数值的方法，直接使用表达式即可获取，例如： <%=request.getContentType()%> 3. 传递中文参数时，可能会出现乱码情况，需声明： request.setCharacterEncoding(\"utf-8\"); 但此方法不能解决使用url传递中文时出现的乱码，若想解决这个，需要在server.xml的connector的末尾加上: URIEncoding=\"utf-8\" 5. response对象 response对象包含了响应客户请求的有关信息，但在JSP中很少直接用到它，它是HttpServletResponse类的实例，response对象具有页面作用域，即访问一个页面时，该页面内的response对象只能对这次访问有效，其它页面的response对象对当前页面无效。 常用方法： String getCharacterEncoding();//返回响应的是何种字符编码 void setContentType(String type);//设置响应MIME类型 PrintWriter getWriter();//返回可以想客户端输出字符的一个对象PrintWriter sendRedirect(java.lang.String location);//重新定向客户端请求 PrintWriter比out对象先打印。调用out.flush()可以解决 5.1 JSP内置对象——请求转发与请求重定向的区别 请求重定向：服务端responce.sendRedirect(\"xx.jsp\")重定向。【客户端行为】：即客户端会访问两次，第一次访问后会立即跳转到第二个重定向页面上，【从本质上讲等于两次请求】，而前一次的请求封装的request对象不会保存，地址栏的URL地址会改变。 请求转发：服务端request.getRequestDispatcher(\"xx.jsp\").forward(request,response)请求转发。forward(request,response)用于保存内置对象request和response。【服务器行为】：服务器会代替客户端去访问转发页面，【从本质是一次请求】，转发后请求对象会保存，地址栏的URL地址不会改变。 6. session对象 6.1 什么是session session表示客户端与服务器的一次会话 Web中的session指：用户在浏览某个网站时，从进入网站到浏览器关闭所经过的这段时间，也就是用户浏览网站所花费的时间。 从上述定义中可以看到，session实际是一个【特定的时间概念】 服务器的内存中，保存着不同用户的不同的session。 6.2 session对象常用方法 long getCreationTime() 返回session创建时间 public String getId() 返回创建时jsp引擎为它设的唯一id号 public Ojbect setAttribute(String name, Object value) 使用指定名称将对象绑定到此对话 public Object getAttribute(String name) 返回此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null String[] getValueNames() 返回一个包含此session中所有可用属性的数组 int getMaxInactiveInterval() 返回两次请求间隔多长时间此session被取消（单位秒） setMaxInactiveInterval(int)可以设置session存活的最长时间，在时间过了之后，服务器会创建全新的一个session。前一个session的内容无法被传递到新的session。 6.3 session的生命周期 1、创建阶段：当客户端第一次访问某个jsp或者servlet时候，服务器会为当前会话创建一个SessionId，每次客户端向服务端发送请求时，都会将此SessionId携带过去，服务端会对此SessionId进行校验。 2、活动阶段 - 某次会话当中通过超链接打开的新页面属于同一次会话。 - 只要当前会话没有全部关闭，重新打开新的浏览器窗口访问统一项目资源时属于同一次会话。 - 除非本次会话的所有页面【都关闭后】，再重新访问某个Jsp或者Servlet将创建新的会话 注意：原有会话在超时前会一直存在，只是再没有客户端携带原SessionId交予服务端校验了！ 3、销毁阶段：Session的销毁只有三种方式 - 调用了session.invalidate()方法 - Session过期（超时） - 服务器重启 4、设置session对象超时时间：默认为30分钟 - session.setMaxInactiveInterval() - 在web.xml文档配置中,单位是分钟. <session-config> <session-timeout> 2 </session-timeout> // 设置为2分钟过期 </session-config> 7. application对象 7.1 application介绍 实现了用户间数据的共享，可存放全局变量。（类似静态对象） 开始于服务器启动，终止于服务器的关闭（生命周期） 在用户的前后连接或不同用户之间的连接中，可以对application对象的同一属性进行操作 在任何地方对application对象属性进行操作，都将影响到其他用户对此的访问 application对象是ServletContext类的实例 7.2 常用方法如下 application对象常用方法： 1. pblic void setAttribute(String name,Object value);//使用指定名称将对象绑定到此会话 2. public Object getAttribute(String name);//返回与此会话中的指定名称绑定在一起的对象，如果没有对象绑定在该名称下，则返回null. 3. Enumeration getAttributeNames();//返回所有可用属性那个名的枚举 4. String getServerInfo();//返回JSP（SERVER）引擎及版本号 8. page对象 page对象就是指向当前JSP页面本身，有点像类中的this指针，它是java.lang.Object类的实例。常用方法如下： class getClass(); //返回此Object类 int hashCode(); //返回此Object的hash码 boolean equals(Object obj); //判断此Object是否与指定的Object对象相等 void copy(Object obj); //把此Object复制到指定的Object对象中 Object clone(); //克隆此Object对象 String toString(); //把此Object对象转换为String类的对象 void notify(); //唤醒一个等待的线程 void notyfyAll(); //唤醒所有等待的线程 void wait(int timeout); //使一个线程处于等待直到timeout结束或被唤醒 void wait(); //使一个线程处于等待直到被唤醒 9. pageContext对象和config对象 9.1 pageContext对象 pageContext对象提供了对JSP页面内所有的对象及名字空间的访问 pageContext对象可以访问到本页所在的session，也可以本页所在的application的某一属性值 pageContext对象相当于页面中所有功能的集大成者 pageContext对象的本类名也叫pageContext 常用方法如下： JspWriter getOut(); //返回当前客户端响应被使用的JspWriter流(out) HttpSession getSession(); //返回当前页面中HttpSession对象(session) Object getPage(); //返回当前页面的Object对象(Object) ServeletRequest getRequest(); //返回当前页面的ServletRequest对象(request) ServeletResponse getResponse(); //返回当前页面的ServletResponse对象(response) void setAttribute(String name,Object attribute); //设置属性及属性值 void getAttribute(String name,int scope); //在指定范围内取属性的值 int getAttributeScope(String name); //返回某属性的作用范围 void forward(String relativeUrlPath); //使当前页面重导到另一页面，页面URL不会变 void include(String relativeUrlPath); //在当前位置包含另一文件 9.2 Config对象： config对象是在一个servlet初始化时，JSP引擎向它传递信息用的，此信息包括Servlet初始化时所要用到的参数(通过属性名和属性值构成)以及服务器的有关信息（通过传递一个ServletContext对象） 常用方法： 1. ServletContext getServletContext();//返回含有服务器相关信息的ServletContext对象 2. String getInitParameter(String name);//返回初始化参数的值 3. Enumeration getInitParameterNames();//返回Servlet初始化所需所有参数的枚举 10. exception对象 exception对象是一个异常对象，当一个页面在运行过程中规发生了异常，就会产生这个对象。如果一个JSP页面要应用此对象，就必须把 isErrorPage 设为true,否则无法编译。他实际上是java.lang.Throwable的对象。 10.1 exception对象常用方法 String getMessage();//返回描述异常的消息 String toString();//返回关于异常的简短描述消息 void printStackTrace();//显示异常及其栈轨迹 Throwable FillInStackTrace();//重写异常的执行栈轨迹 10.2 exception对象使用方法： 在可能会抛出异常的页面page指令里，设置errorPage=\"xxx.jsp\"，表示出现异常将抛给xxx页面去处理 在xxx页面里，要使用Exception对象，需要把page指令里的isErrorPage属性设置为true。 11. 阶段案例-实现用户登录 用户登录页login.jsp <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title> login </title> </head> <body> <form action= \"dologin.jsp\" method= \"post\" > <label for= \"username\" > user name </label> <input type= \"text\" name= \"username\" placeholder= \"用户名\" /> <label for= \"password\" > password </label> <input type= \"password\" name= \"password\" /> <input type= \"submit\" value= \"login\" /> </form> </body> </html> 处理用户登录页dologin.jsp <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <% String username = \"\" ; String password = \"\" ; request . setCharacterEncoding ( \"utf-8\" ); username = request . getParameter ( \"username\" ); password = request . getParameter ( \"password\" ); if ( \"admin\" . equals ( username ) && \"admin\" . equals ( password )){ session . setAttribute ( \"loginUser\" , username ); request . getRequestDispatcher ( \"login_success.jsp\" ) . forward ( request , response ); } else { response . sendRedirect ( \"login_failure.jsp\" ); } %> 登录成功页login_success.jsp <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title></title> </head> <body> <h1> login success! </h1> <% String loginUser = \"\" ; if ( session . getAttribute ( \"loginUser\" ) != null ){ loginUser = session . getAttribute ( \"loginUser\" ) . toString (); } %> <p> 欢迎， <%= loginUser %> </p> </body> </html> 登录失败页 <% @ page contentType = \"text/html;charset=UTF-8\" language = \"java\" %> <html> <head> <title></title> </head> <body> <h1> login failure. </h1> <hr/> <a href= \"login.jsp\" > 返回登录页 </a> </body> </html>","tags":"Java","url":"/java-webzhi-jsp-03-jspnei-zhi-dui-xiang.html"},{"title":"Java Web之JSP-04 Java Beans","text":"1. JavaBean简介 javaBeans就是符合某种特定的规范的java类。使用JavaBeans的好处是解决代码重复编写，减少代码冗余，功能区分明确，提高了代码的可维护性。 JavaBean的设计原则： 公有类 属性私有 无参的公有构造方法 getter和setter方法 2. JSP动作元素 2.1 什么是JSP动作元素 JSP动作元素（action element），动作元素为请求处理阶段提供信息。动作元素遵循XML语法，有一个包含元素名的开始标签，可以有属性，可选的内容、与开始标签匹配的结束标签。 2.2 JSP动作元素的五大类 第一类是与存取JavaBean有关的，包括： <jsp:useBean> <jsp:setProperty> <jsp:getProperty> 第二类是JSP1.2就开始有的基本元素，包括6个动作元素： <jsp:include> <jsp:forward> <jsp:param> <jsp:plugin> <jsp:params> <jsp:fallback> 第三类是JSP2.0新增的元素，主要与JSP Document有关，包括6个元素： <jsp:root> <jsp:declaration> <jsp:scriptlet> <jsp:expression> <jsp:text> <jsp:output> 第四类是JSP2.0新增的动作元素，主要是用来动态生成XML元素标签的值，包括三个动作： <jsp:attribute> <jsp:body> <jsp:element> 第五类是JSP2.0新增的动作元素，主要是用在Tag File中，有2个元素： <jsp:invoke> <jsp:dobody> 3. 如何在JSP中使用Java Beans 3.1 像使用普通java类一样 创建在src文件下，（可以创建包）创建一个类，满足设计原则即可 使用前通过import导入，通过使用new创建Javabean实例.在顶端添加 <%@ page import=\"com.po.Users\" %> ，导入javabean包 3.2 useBean元素 在JSP页面中通常使用JSP动作标签使用javabean(useBeans动作、setProperty动作、getProperty动作) <jsp:useBeans> 作用：在jsp页面中实例化或者在指定范围内使用javabean: <jsp:useBean id=\"标识符\" class=\"Java类名\" scope=\"作用范围\"/> 3.3 使用setProperty <jsp:setProperty> 动作：给【已经实例化的Javabean对象的属性赋值】，一共有四种形式。 根据表单自动匹配所有的属性 <jsp:setProperty name=\"myUsers\" property=\"*\"/> 根据表单自动匹配相应的属性（部分匹配） <jsp:setProperty name=\"myUsers\" property=\"username\"/> 与表单无关，通过手工赋值给属性 <jsp:setProperty name=\"myUsers\" property=\"username\" value=\"Lisa\"/> 通过url传参数给属性赋值 <jsp:setProperty name=\"myUsers\" property=\"username\"/> <jsp:setProperty name=\"myUsers\" property=\"password\" param=\"mypass\"/> 案例： 表单部分： <form action= \"dologin.jsp\" method= \"post\" > <table> <tr> <td> 用户名 </td> <td><input type= \"text\" name= \"username\" /></td> </tr> <tr> <td> 密码 </td> <td><input type= \"password\" name= \"password\" /></td> </tr> <tr> <td colspan= \"2\" ><input type= \"submit\" value= \"提交\" /></td> </tr> </table> </form> dologin.jsp中匹配： <h1> 根据表单自动匹配所有属性 </h1> <hr/> <jsp:useBean id= \"myUsers\" class= \"liulx.javabean.User\" scope= \"page\" /> <% request . setCharacterEncoding ( \"utf-8\" ); %> <jsp:setProperty name= \"myUsers\" property= \"*\" /> 用户名： <%= myUsers . getUsername () %> 密码： <%= myUsers . getPassword () %> 3.4 getProperty标签 <jsp:getProperty> 动作：获取指定Javabean对象的属性值 <jsp:getProperty name=\"JavaBean实例名\" property=\"属性名\" /> 可以直接得到值 用户名：<jsp:getProperty name=\"myUsers\" property=\"username\" /> 4. JavaBean四个作用域范围 使用useBeans的scope属性来置顶javabean的作用范围，由小到大排列是： page->request->session->application page对象仅在当前页面有效 request //可以通过HttpRequest.getAttribute()方法取得JavaBean对象.需要配合请求转发来使用，若使用请求重定向则无法访问到Javabean session //可以通过HttpSession.getAttribute()方法取得JavaBean对象则是在一次对话中都会有效 application//可以通过application.getAttribute()方法取得JavaBean对象。全局，在服务器一次运行期间都有效 request在源页面用request.getRequestDispatcher(\"/somePage.jsp\").forward(request, response); 内部转发的方式将数据传递到下一个页面可获取对象。 5. Model1简介 Model 1模型出现前，整个Web应用的情况：几乎全部由JSP页面组成，JSP页面接收处理客户端请求，对请求处理后直接做出响应。这样做的弊端：在页面层充斥着大量的业务逻辑代码和数据访问层代码，Web程序的可扩展性和可维护性非常差。 5.1 javaWeb应用开发，模式分为Model1和Model2 Model1早于Model2 在Model1之前，整个Web应用的情况：几乎全部由jsp页组成，jsp处理和响应客户端请求。 · 弊端：【界面层】充斥了大量业务逻辑代码和数据访问层代码，扩展性和维护性非常差 5.2 Model1 Javabean的出现，可以使jsp页面使用Javabean封装的数据和业务逻辑代码，大大提高程序可维护性。 Model1 = JSP + JavaBean。如图：JSP访问页面层 -> Javab业务逻辑层 -> 数据库数据访问层 6. 阶段项目","tags":"Java","url":"/java-webzhi-jsp-04-java-beans.html"},{"title":"Java-常用方法","text":"之前一直用C#比较多，最近开始研究Java，两者之间的库设计差别很大，故再次做个总结。 1. 日期 1.日期格式化 import java.text.SimpleDateFormat ; import java.util.Date ; SimpleDateFormat sdf = new SimpleDateFormat ( \"yyyy年MM月dd日\" ); String s = sdf . format ( new Date ()); 字符串转化为日期 SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); Date d = sdf.parse(\"2015年04月13日\"); 2. 泛型 1.新建泛型 可以再 new 后面直接使用 <> 来初始化，不需要指定类型，如下所示： ArrayList<Crime> crimes = new ArrayList<>();","tags":"Java","url":"/java-chang-yong-fang-fa.html"},{"title":"Java Web之JSP-02 JSP基础语法","text":"1. JSP简介 JSP页面元素构成： 静态内容 注释 声明 小脚本 表达式 指令 1.1 jsp指令 page指令：通常位于jsp页面的顶端，同一个页面可以有多个page指令。 include指令：将一个外部文件嵌入到当前jsp文件中，同时解析这个页面中的jsp语句。 taglib指令：使用标签库定义心得自定义标签。在jsp页面中启用定制行为 page指令语法： <% @page 属性 1 = \"value\" 属性 2 = \"value1, value2\" ... %> 属性 描述 默认值 language 指定jsp页面使用的脚本语言 java import 通过该属性来引用脚本语言中使用到的类文件 无 contentType 用来指定jsp页面所采用的编码方式 text/html,ISO-8859-1 1.2 JSP注释 html注释 <!--html注释--> jsp注释 <%--注释--%> jsp脚本注释 // /**/ 1.3 jsp脚本 语法： <% out . println ( \"大家好，欢迎大家学习javaee开发\" ); %> 1.4 jsp声明 在jsp页面中定义变量或者方法 <% ! java代码 %> <% ! String s = \"lixiang\" ; int add ( int x , int y ){ return x + y ; } 1.5 jsp表达式 <%= 表达式 %> //注意：表达式不以分号结束 <%= s %> <%= add ( 5 + 4 ) %> 1.6 jsp页面生命周期 jspService() 方法被调用来处理客户端的请求。对每一个请求，JSP引擎创建一个新的线程来处理该请求。如果有多个客户端同时请求该JSP文件，则JSP引擎会创建多个线程。每个客户端请求对应一个线程。以多线程方式执行可以大大降低对系统的资源需求，提高系统的并发量及响应时间。但也要注意多线程的编程带来的同步问题，由于该Servlet始终驻于内存，所以响应时间是非常快的。 1.7 jsp练习：打印乘法表 <% ! String printMultiTable (){ String s = \"\" ; for ( int i = 1 ; i <= 9 ; i ++ ){ for ( int j = 1 ; j <= i ; j ++ ){ s += j + \"*\" + i + \"=\" + i * j + \"&nbsp;&nbsp;\" ; } s += \"<br/>\" ; } return s ; } void printMultiTable2 ( JspWriter out ) throws IOException { for ( int i = 1 ; i <= 9 ; i ++ ){ for ( int j = 1 ; j <= i ; j ++ ){ out . println ( j + \"*\" + i + \"=\" + i * j + \"&nbsp;&nbsp;\" ); } out . println ( \"<br>\" ); } } %> <h1> 九九乘法表 </h1> <hr/> <%= printMultiTable () %> <hr/> <% printMultiTable2 ( out ); %>","tags":"Java","url":"/java-webzhi-jsp-02-jspji-chu-yu-fa.html"},{"title":"Java Web之JSP-01 Java Web简介","text":"1. Tomcat配置 1.1 创建环境变量 创建环境变量 CATALINA_HOME ,值为Tomcat所在根目录（比如，windows下可能为为 C:\\Program Files (x86)\\Apache Software Foundation\\Tomcat 7.0 ). 1.2 启动Tomcat 在 CATALINA_HOME 的bin目录下有startup脚本。 1.3 测试 地址：http://localhost:8080 2. Tomcat目录结构 3. 手工编写第一个Java Web应用程序 3.1 创建Web App目录 在Tomcat的webapps目录下创建目录myhome 3.2 在myhome目录下创建内容 1、创建index.jsp: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < title > 你好 </ title > </ head > < body > < h1 > 你好世界 </ h1 > </ body > </ html > 2、创建WEB-INF目录 从Tomcat的webapps/examples/WEB-INF下拷贝web.xml，并且只保留根标签 <?xml version=\"1.0\" encoding=\"ISO-8859-1\"?> <web-app xmlns= \"http://java.sun.com/xml/ns/javaee\" xmlns:xsi= \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation= \"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\" version= \"3.0\" metadata-complete= \"true\" > </web-app> 创建classes和lib子文件夹 4. WEB-INF目录详解 WEB-INF目录是一个安全目录，只有通过服务器才能访问。 web.xml,项目部署文件，比如配置项目的欢迎页面。 <welcome-file-list> <welcome-file> /haha.jsp </welcome-file> </welcome-file-list> classes文件夹，用以放置*.class文件。 lib文件夹，用于存放需要的jar包。 5. 使用eclipse开发web 5.1 MyEclipse配置JRE windows->preference->java->Installed JREs 5.2 MyEclipse集成Tomcat服务器 windows->preference->Myeclipse->server->Runtime Environments 启动Tomcat 5.3 使用MyEclipse创建Java web应用 新建web project，命名为MyFirstWebApp，其余默认 5.4 修改字体 windows->preference->General->Appearance->Colors and Fonts，然后修改Text Font。 6. 修改Tomcat服务器默认端口 修改conf/server.xml文件 <Connector executor=\"tomcatThreadPool\" port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" />","tags":"Java","url":"/java-webzhi-jsp-01-java-webjian-jie.html"},{"title":"HTML\\CSS补遗","text":"1. HTML标签 <strong> 和 <em> ：有了段落又有了标题，现在如果想在一段话中特别强调某几个文字，这时候就可以用到 <em> 或 <strong> 标签。但两者在强调的语气上有区别: <em> 表示强调， <strong> 表示更强烈的强调。并且在浏览器中 <em> 默认用 斜体 表示， <strong> 用 粗体 表示。两个标签相比，目前国内前端程序员更喜欢使用 <strong> 表示强调。 <span> 标签是没有语义的，它的作用就是为了设置单独的样式用的。 <q> 标签，短文本引用 <blockquote> 的作用也是引用别人的文本。但它是对长文本的引用，如在文章中引入大段某知名作家的文字，这时需要这个标签。 等等，上一节 <q> 标签不是也是对文本的引用吗？不要忘记 <q> 标签是对简短文本的引用，比如说引用一句话就用到 <q> 标签。 <br> 标签分行显示文本 &nbsp; 空格 <hr> 标签，添加水平横线 <address> 标签，为网页加入地址信息,在浏览器上显示的样式为斜体: <address>北京市西城区德外大街10号</address> <code> 标签:在介绍语言技术的网站中，必免不了在网页中显示一些计算机专业的编程代码，当代码为一行代码时，你就可以使用 <code> 标签了，如下面例子： <code>var i=i+300;</code> .注意：在文章中一般如果要插入多行代码时不能使用 标签了。如果是多行代码，可以使用 <pre> 标签. <pre> 标签为你的网页加入大段代码 <ul> 和 <ol> 无序和有序列表 table <table summary=\"\"><caption></caption><tr><th></th></tr><tr><td></td></tr></table> a: <a href=\"目标网址\" title=\"鼠标滑过显示的文本\">链接显示的文本</a> . <a> 标签在默认情况下，链接的网页是在当前浏览器窗口中打开，有时我们需要在新的浏览器窗口中打开，需要： <a href=\"目标网址\" target=\"_blank\">click here!</a> , href属性还可以是 mailto:550488300@qq.com 这种形式，其中参数如下图： 。 img: <img src=\"图片地址\" alt=\"下载失败时的替换文本\" title = \"提示文本\"> 2. Form标签 2.1 文本域，支持多行文本输入 当用户需要在表单中输入大段文字时，需要用到文本输入域。 语法： <textarea rows=\"行数\" cols=\"列数\">文本</textarea> 1、 <textarea> 标签是成对出现的，以 <textarea> 开始，以 </textarea> 结束。 2、cols ：多行输入域的列数。 3、rows ：多行输入域的行数。 4、在 <textarea></textarea> 标签之间可以输入默认值。 2.2 使用单选框、复选框，让用户选择 在使用表单设计调查表时，为了减少用户的操作，使用选择框是一个好主意，html中有两种选择框，即单选框和复选框，两者的区别是单选框中的选项用户只能选择一项，而复选框中用户可以任意选择多项，甚至全选。请看下面的例子: 语法： <input type=\"radio/checkbox\" value=\"值\" name=\"名称\" checked=\"checked\"/> 1、type: 当 type=\"radio\" 时，控件为单选框 当 type=\"checkbox\" 时，控件为复选框 2、value：提交数据到服务器的值（后台程序PHP使用） 3、name：为控件命名，以备后台程序 ASP、PHP 使用 4、checked：当设置 checked=\"checked\" 时，该选项被默认选中 注意 :同一组的单选按钮，name 取值一定要一致，比如上面例子为同一个名称\"radioLove\"，这样同一组的单选按钮才可以起到单选的作用。 2.3 select 单选： <select> <option value= \"看书\" > 看书 </option> <option value= \"旅游\" selected= \"selected\" > 旅游 </option> <option value= \"运动\" > 运动 </option> <option value= \"购物\" > 购物 </option> </select> 使用下拉列表框进行多选 下拉列表也可以进行多选操作，在 <select> 标签中设置 multiple=\"multiple\" 属性，就可以实现多选功能，在 widows 操作系统下，进行多选时按下Ctrl键同时进行单击（在 Mac下使用 Command +单击），可以选择多个选项。如下代码： <select multiple= \"multiple\" > <option value= \"看书\" > 看书 </option> <option value= \"旅游\" > 旅游 </option> <option value= \"运动\" > 运动 </option> <option value= \"购物\" > 购物 </option> </select> 2.4 使用提交按钮，提交数据 在表单中有两种按钮可以使用，分别为：提交按钮、重置。这一小节讲解提交按钮：当用户需要提交表单信息到服务器时，需要用到提交按钮。 语法： <input type=\"submit\" value=\"提交\"> type：只有当 type 值设置为 submit 时，按钮才有提交作用 value：按钮上显示的文字 2.5 使用重置按钮，重置表单信息 当用户需要重置表单信息到初始时的状态时，比如用户输入\"用户名\"后，发现书写有误，可以使用重置按钮使输入框恢复到初始状态。只需要把type设置为\"reset\"就可以。 语法： <input type=\"reset\" value=\"重置\"> type：只有当type值设置为reset时，按钮才有重置作用 value：按钮上显示的文字 <form action= \"save.php\" method= \"post\" > <label> 爱好: </label> <select> <option value= \"看书\" > 看书 </option> <option value= \"旅游\" selected= \"selected\" > 旅游 </option> <option value= \"运动\" > 运动 </option> <option value= \"购物\" > 购物 </option> </select> <input type= \"submit\" value= \"确定\" /> <input type= \"reset\" value= \"重置\" /> </form> 2.6 form表单中的label标签 小伙伴们，你们在前面学习表单各种控件的时候，有没有发现一个标签--label，这一小节就来揭晓它的作用。 label标签不会向用户呈现任何特殊效果，它的作用是为鼠标用户改进了可用性。如果你在 label 标签内点击文本，就会触发此控件。就是说，当用户单击选中该label标签时，浏览器就会自动将焦点转到和标签相关的表单控件上（就自动选中和该label标签相关连的表单控件上）。 语法： <label for=\"控件id名称\"> 注意：标签的 for 属性中的值应当与相关控件的 id 属性值一定要相同。 例子： <form> <label for= \"male\" > 男 </label> <input type= \"radio\" name= \"sex\" id= \"male\" /> <br /> <label for= \"female\" > 女 </label> <input type= \"radio\" name= \"sex\" id= \"female\" /> <label for= \"email\" > 输入你的邮箱地址 </label> <input type= \"email\" id= \"email\" placeholder= \"Enter email\" > </form> 3. CSS基础 优先级：内联式 > 嵌入式 > 外部式 3.1 子选择器 还有一个比较有用的选择器子选择器，即大于符号(>),用于选择指定标签元素的第一代子元素。 .food>li{border:1px solid red;} 3.2 包含(后代)选择器 包含选择器，即加入空格,用于选择指定标签元素下的后辈元素。 .first span{color:red;} 3.3 通用选择器 通用选择器是功能最强大的选择器，它使用一个（*）号指定，它的作用是匹配html中所有标签元素，如下使用下面代码使用html中任意标签元素字体颜色全部设置为红色： * {color:red;} 3.4 伪类选择符 更有趣的是伪类选择符，为什么叫做伪类选择符，它允许给html不存在的标签（标签的某种状态）设置样式，比如说我们给html中一个标签元素的鼠标滑过的状态来设置字体颜色： a:hover{color:red;} 上面一行代码就是为 a 标签鼠标滑过的状态设置字体颜色变红。这样就会使第一段文字内容中的\"胆小如鼠\"文字加入鼠标滑过字体颜色变为红色特效。 关于伪选择符： 关于伪类选择符，到目前为止，可以兼容所有浏鉴器的\"伪类选择符\"就是 a 标签上使用 :hover 了（其实伪类选择符还有很多，尤其是 css3 中，但是因为不能兼容所有浏鉴器，本教程只是讲了这一种最常用的）。其实 :hover 可以放在任意的标签上，比如说 p:hover，但是它们的兼容性也是很不好的，所以现在比较常用的还是 a:hover 的组合。 3.5 分组选择符 当你想为html中多个标签元素设置同一个样式时，可以使用分组选择符（，），如下代码为右侧代码编辑器中的h1、span标签同时设置字体颜色为红色： h1,span{color:red;} 它相当于下面两行代码： h1 { color : red ;} span { color : red ;} 3.6 CSS的继承、层叠和特殊性 3.6.1 继承 CSS的某些样式是具有继承性的，那么什么是继承呢？继承是一种规则，它允许样式不仅应用于某个特定html标签元素，而且应用于其后代。比如下面代码：如某种颜色应用于p标签，这个颜色设置不仅应用p标签，还应用于p标签中的所有子元素文本，这里子元素为span标签。 p{color:red;} <p>三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p> 可见右侧结果窗口中p中的文本与span中的文本都设置为了红色。但注意有一些css样式是不具有继承性的。如 border:1px solid red; p{border:1px solid red;} <p>三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p> 在上面例子中它代码的作用只是给p标签设置了边框为1像素、红色、实心边框线，而对于子元素span是没用起到作用的。 3.6.2 特殊性 有的时候我们为同一个元素设置了不同的CSS样式代码，那么元素会启用哪一个CSS样式呢?我们来看一下面的代码： p { color : red ;} .first { color : green ;} <p class=\"first\">三年级时，我还是一个<span>胆小如鼠</span>的小女孩。</p> p和.first都匹配到了p这个标签上，那么会显示哪种颜色呢？green是正确的颜色，那么为什么呢？是因为浏览器是根据权值来判断使用哪种css样式的，权值高的就使用哪种css样式。 下面是权值的规则： 标签的权值为1，类选择符的权值为10，ID选择符的权值最高为100。例如下面的代码： p { color : red ;} /*权值为1*/ p span { color : green ;} /*权值为1+1=2*/ .warning { color : white ;} /*权值为10*/ p span .warning { color : purple ;} /*权值为1+1+10=12*/ #footer .note p { color : yellow ;} /*权值为100+10+1=111*/ 注意：还有一个权值比较特殊--继承也有权值但很低，有的文献提出它只有0.1，所以可以理解为继承的权值最低。 3.6.3 层叠 我们来思考一个问题：如果在html文件中对于同一个元素可以有多个css样式存在并且这多个css样式具有相同权重值怎么办？好，这一小节中的层叠帮你解决这个问题。 层叠就是在html文件中对于同一个元素可以有多个css样式存在，当有相同权重的样式存在时，会根据这些css样式的前后顺序来决定，处于最后面的css样式会被应用。 如下面代码: p{color:red;} p{color:green;} <p class= \"first\" > 三年级时，我还是一个 <span> 胆小如鼠 </span> 的小女孩。 </p> 最后 p 中的文本会设置为green，这个层叠很好理解，理解为后面的样式会覆盖前面的样式。 所以前面的css样式优先级就不难理解了： 内联样式表（标签内部）> 嵌入样式表（当前文件中）> 外部样式表（外部文件中）。 3.6.4 重要性 我们在做网页代码的时，有些特殊的情况需要为某些样式设置具有最高权值，怎么办？这时候我们可以使用 !important 来解决。 如下代码： p{color:red!important;} p{color:green;} <p class= \"first\" > 三年级时，我还是一个 <span> 胆小如鼠 </span> 的小女孩。 </p> 这时 p 段落中的文本会显示的red红色。 注意： !important 要写在分号的前面 这里注意当网页制作者不设置css样式时，浏览器会按照自己的一套样式来显示网页。并且用户也可以在浏览器中设置自己习惯的样式，比如有的用户习惯把字号设置为大一些，使其查看网页的文本更加清楚。这时注意样式优先级为：浏览器默认的样式 < 网页制作者样式 < 用户自己设置的样式，但记住 !important 优先级样式是个例外，权值高于用户自己设置的样式。 3.7 CSS格式化排版 3.7.1 文字排版--字体 我们可以使用css样式为网页中的文字设置字体、字号、颜色等样式属性。下面我们来看一个例子，下面代码实现：为网页中的文字设置字体为宋体。 body{font-family:\"宋体\";} 这里注意不要设置不常用的字体，因为如果用户本地电脑上如果没有安装你设置的字体，就会显示浏览器默认的字体。（因为用户是否可以看到你设置的字体样式取决于用户本地电脑上是否安装你设置的字体。） 现在一般网页喜欢设置\"微软雅黑\"，如下代码： body{font-family:\"Microsoft Yahei\";} 或 body{font-family:\"微软雅黑\";} 注意：第一种方法比第二种方法兼容性更好一些。 因为这种字体即美观又可以在客户端安全的显示出来（用户本地一般都是默认安装的）。 3.7.2 文字排版--字号、颜色 可以使用下面代码设置网页中文字的字号为12像素，并把字体颜色设置为#666(灰色)： body{font-size:12px;color:#666} 3.7.3 文字排版--粗体 我们还可以使用css样式来改变文字的样式：粗体、斜体、下划线、删除线，可以使用下面代码实现设置文字以粗体样式显示出来。 p span{font-weight:bold;} 在这里大家可以看到，如果想为文字设置粗体是有单独的css样式来实现的，再不用为了实现粗体样式而使用h1-h6或strong标签了。 3.7.4 文字排版--斜体 以下代码可以实现文字以斜体样式在浏览器中显示： p a{font-style:italic;} <p>三年级时，我还是一个<a>胆小如鼠</a>的小女孩。</p> 3.7.5 文字排版--下划线 有些情况下想为文字设置为下划线样式，这样可以在视觉上强调文字，可以使用下面代码来实现： p a{text-decoration:underline;} <p> 三年级时，我还是一个 <a> 胆小如鼠 </a> 的小女孩。 </p> 3.7.6 文字排版--删除线 如果想在网页上设置删除线怎么办, 使用下面代码就可以实现： .oldPrice{text-decoration:line-through;} 3.7.7 段落排版--缩进 中文文字中的段前习惯空两个文字的空白，这个特殊的样式可以用下面代码来实现： p{text-indent:2em;} <p> 1922年的春天，一个想要成名名叫尼克卡拉威（托比?马奎尔Tobey Maguire 饰）的作家，离开了美国中西部，来到了纽约。那是一个道德感渐失，爵士乐流行，走私为王，股票飞涨的时代。为了追寻他的美国梦，他搬入纽约附近一海湾居住。 </p> 注意：2em的意思就是文字的2倍大小。 3.7.8 段落排版--行间距（行高） 这一小节我们来学习一下另一个在段落排版中起重要作用的行间距（行高）属性（line-height），如下代码实现设置段落行间距为1.5倍。 p{line-height:1.5em;} <p> 菲茨杰拉德，二十世纪美国文学巨擘之一，兼具作家和编剧双重身份。他以诗人的敏感和戏剧家的想象为\"爵士乐时代\"吟唱华丽挽歌，其诗人和梦想家的气质亦为那个奢靡年代的不二注解。 </p> 3.7.9 段落排版--字间距、字母间距 文字间隔、字母间隔设置： 如果想在网页排版中设置文字间隔或者字母间隔就可以使用 letter-spacing来实现，如下面代码： h1{ letter-spacing:50px; } <h1> 了不起的盖茨比 </h1> 注意：这个样式使用在英文单词时，是设置字母与字母之间的间距。 单词间距设置： 如果我想设置英文单词之间的间距呢？可以使用word-spacing来实现。如下代码： h1{ word-spacing:50px; } <h1> welcome to imooc! </h1> 3.7.10 段落排版--对齐 想为块状元素中的文本、图片设置居中样式吗？可以使用text-align样式代码，如下代码可实现文本居中显示。(那么什么是块状元素呢？在后面的11-1、11-2小节中会讲到。) h1{ text-align:center; } <h1> 了不起的盖茨比 </h1> 同样可以设置居左： h1{ text-align:left; } <h1> 了不起的盖茨比 </h1> 还可以设置居右： h1{ text-align:right; } <h1> 了不起的盖茨比 </h1> 3.8 CSS盒子模型 3.8.1 元素分类 在讲解CSS布局之前，我们需要提前知道一些知识，在CSS中，html中的标签元素大体被分为三种不同的类型：块状元素、内联元素(又叫行内元素)和内联块状元素。 常用的块状元素有： <div>、<p>、<h1>...<h6>、<ol>、<ul>、<dl>、<table>、<address>、<blockquote> 、<form> 常用的内联元素有： <a>、<span>、<br>、<i>、<em>、<strong>、<label>、<q>、<var>、<cite>、<code> 常用的内联块状元素有： <img>、<input> 3.8.2 元素分类--块级元素 什么是块级元素？在html中 <div>、 <p>、<h1>、<form>、<ul> 和 <li> 就是块级元素。设置 display:block 就是将元素显示为块级元素。如下代码就是将内联元素a转换为块状元素，从而使a元素具有块状元素特点。 a{display:block;} 块级元素特点： 1、每个块级元素都从新的一行开始，并且其后的元素也另起一行。（真霸道，一个块级元素独占一行） 2、元素的高度、宽度、行高以及顶和底边距都可设置。 3、元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度。 3.8.3 元素分类--内联元素 在html中， <span>、<a>、<label>、<input>、 <img>、 <strong> 和<em> 就是典型的内联元素（行内元素）（inline）元素。当然块状元素也可以通过代码 display:inline 将元素设置为内联元素。如下代码就是将块状元素div转换为内联元素，从页使用div元素具有内联元素特点。 内联元素特点： 1、和其他元素都在一行上； 2、元素的高度、宽度、行高及顶部和底部边距不可设置； 3、元素的宽度就是它包含的文字或图片的宽度，不可改变。 小伙伴们你们观查一下右侧代码段，有没有发现一个问题，内联元素之间有一个间距问题，这个问题在本小节的wiki中有介绍，感兴趣的小伙伴可以去查看。 3.8.4 元素分类--内联块状元素 内联块状元素（inline-block）就是同时具备内联元素、块状元素的特点，代码 display:inline-block 就是将元素设置为内联块状元素。(css2.1新增)， <img>、<input> 标签就是这种内联块状标签。 inline-block 元素特点： 1、和其他元素都在一行上； 2、元素的高度、宽度、行高以及顶和底边距都可设置。 提示：下一小节是用视频动画来讲解css中的盒模型。 3.8.5 盒模型--边框 盒子模型的边框就是围绕着内容及补白的线，这条线你可以设置它的粗细、样式和颜色(边框三个属性)。 如下面代码为 div 来设置边框粗细为 2px、样式为实心的、颜色为红色的边框： div { border : 2px solid red ; } 上面是 border 代码的缩写形式，可以分开写： div { border-width : 2px ; border-style : solid ; border-color : red ; } 注意： 1、border-style（边框样式）常见样式有： dashed（虚线）| dotted（点线）| solid（实线） 。 2、border-color（边框颜色）中的颜色可设置为十六进制颜色，如: border-color:#888;//前面的井号不要忘掉。 3、border-width（边框宽度）中的宽度也可以设置为： thin | medium | thick（但不是很常用），最常还是用象素（px）。 现在有一个问题，如果有想为 p 标签单独设置下边框，而其它三边都不设置边框样式怎么办呢？css 样式中允许只为一个方向的边框设置样式： div{border-bottom:1px solid red;} 同样可以使用下面代码实现其它三边(上、右、左)边框的设置： border-top :1px solid red ; border-right :1px solid red ; border-left :1px solid red ; 3.8.6 盒模型--宽度和高度 盒模型宽度和高度和我们平常所说的物体的宽度和高度理解是不一样的，css内定义的宽（width）和高（height），指的是填充以里的内容范围。 因此一个元素实际宽度（盒子的宽度）=左边界+左边框+左填充+内容宽度+右填充+右边框+右边界。 div { width : 200px ; padding : 20px ; border : 1px solid red ; margin : 10px ; } 3.8.7 盒模型--填充 元素内容与边框之间是可以设置距离的，称之为\"填充\"。填充也可分为上、右、下、左(顺时针)。如下代码： div{padding:20px 10px 15px 30px;} 顺序一定不要搞混。可以分开写上面代码： div { padding-top : 20px ; padding-right : 10px ; padding-bottom : 15px ; padding-left : 30px ; } 如果上、右、下、左的填充都为10px;可以这么写 div { padding : 10px ;} 如果上下填充一样为10px，左右一样为20px，可以这么写： div { padding : 10px 20px ;} 3.8.8 盒模型--边界 元素与其它元素之间的距离可以使用边界（margin）来设置。边界也是可分为上、右、下、左。如下代码： div{margin:20px 10px 15px 30px;} 也可以分开写： div { margin-top : 20px ; margin-right : 10px ; margin-bottom : 15px ; margin-left : 30px ; } 如果上右下左的边界都为10px;可以这么写： div{ margin:10px;} 如果上下边界一样为10px，左右一样为20px，可以这么写： div{ margin:10px 20px;} 总结一下：padding和margin的区别，padding在边框里，margin在边框外。 3.9 CSS布局模型 3.9.1 css布局模型 清楚了CSS 盒模型的基本概念、 盒模型类型， 我们就可以深入探讨网页布局的基本模型了。布局模型与盒模型一样都是 CSS 最基本、 最核心的概念。 但布局模型是建立在盒模型基础之上，又不同于我们常说的 CSS 布局样式或 CSS 布局模板。如果说布局模型是本，那么 CSS 布局模板就是末了，是外在的表现形式。 CSS包含3种基本的布局模型，用英文概括为：Flow、Layer 和 Float。 在网页中，元素有三种布局模型： 1、流动模型（Flow） 2、浮动模型 (Float) 3、层模型（Layer） 这三个布局模型究竟是什么布局？下面几个小节会详细给大家介绍。 3.9.2 流动模型 先来说一说流动模型，流动（Flow）是默认的网页布局模式。也就是说网页在默认状态下的 HTML 网页元素都是根据流动模型来分布网页内容的。 流动布局模型具有2个比较典型的特征： 块状元素都会在所处的包含元素内自上而下按顺序垂直延伸分布，因为在默认状态下，块状元素的宽度都为100%。实际上，块状元素都会以行的形式占据位置。 在流动模型下，内联元素都会在所处的包含元素内从左到右水平分布显示。（内联元素可不像块状元素这么霸道独占一行） 3.9.3 浮动模型 块状元素这么霸道都是独占一行，如果现在我们想让两个块状元素并排显示，怎么办呢？不要着急，设置元素浮动就可以实现这一愿望。 任何元素在默认情况下是不能浮动的，但可以用 CSS 定义为浮动，如 div、p、table、img 等元素都可以被定义为浮动。如下代码可以实现两个 div 元素一行显示。 div{ width:200px; height:200px; border:2px red solid; float:left; } <div id= \"div1\" ></div> <div id= \"div2\" ></div> 3.9.4 什么是层模型？ 什么是层布局模型？层布局模型就像是图像软件PhotoShop中非常流行的图层编辑功能一样，每个图层能够精确定位操作，但在网页设计领域，由于网页大小的活动性，层布局没能受到热捧。但是在网页上局部使用层布局还是有其方便之处的。下面我们来学习一下html中的层布局。 如何让html元素在网页中精确定位，就像图像软件PhotoShop中的图层一样可以对每个图层能够精确定位操作。CSS定义了一组定位（positioning）属性来支持层布局模型。 层模型有三种形式： 1. 绝对定位(position: absolute) 2. 相对定位(position: relative) 3. 固定定位(position: fixed) 3.9.5 层模型--绝对定位 如果想为元素设置层模型中的绝对定位，需要设置position:absolute(表示绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用left、right、top、bottom属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于body元素，即相对于浏览器窗口。 如下面代码可以实现div元素相对于浏览器窗口向右移动100px，向下移动50px。 div{ width:200px; height:200px; border:2px red solid; position:absolute; left:100px; top:50px; } <div id= \"div1\" ></div> 3.9.6 层模型--相对定位 如果想为元素设置层模型中的相对定位，需要设置position:relative（表示相对定位），它通过left、right、top、bottom属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按static(float)方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于以前的位置移动，移动的方向和幅度由left、right、top、bottom属性确定，偏移前的位置保留不动。 如下代码实现相对于以前位置向下移动50px，向右移动100px; #div1{ width:200px; height:200px; border:2px red solid; position:relative; left:100px; top:50px; } <div id= \"div1\" ></div> 什么叫做\"偏移前的位置保留不动\"呢？ 大家可以做一个实验，在右侧代码编辑器的19行div标签的后面加入一个span标签，在标并在span标签中写入一些文字。如下代码： <body> <div id= \"div1\" ></div><span> 偏移前的位置还保留不动，覆盖不了前面的div没有偏移前的位置 </span> </body> 从效果图中可以明显的看出，虽然div元素相对于以前的位置产生了偏移，但是div元素以前的位置还是保留着，所以后面的span元素是显示在了div元素以前位置的后面。 3.9.7 层模型--固定定位 fixed：表示固定定位，与absolute定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与background-attachment:fixed;属性功能相同。以下代码可以实现相对于浏览器视图向右移动100px，向下移动50px。并且拖动滚动条时位置固定不变。 #div1{ width:200px; height:200px; border:2px red solid; position:fixed; left:100px; top:50px; } <p> 文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本文本。 </p> .... 3.9.8 Relative与Absolute组合使用 小伙伴们学习了绝对定位的方法：使用position:absolute可以实现被设置元素相对于浏览器（body）设置定位以后，大家有没有想过可不可以相对于其它元素进行定位呢？答案是肯定的，当然可以。使用position:relative来帮忙，但是必须遵守下面规范： 1、参照定位的元素必须是相对定位元素的前辈元素： <div id= \"box1\" > <!--参照定位的元素--> <div id= \"box2\" > 相对参照元素进行定位 </div> <!--相对定位元素--> </div> 从上面代码可以看出box1是box2的父元素（父元素当然也是前辈元素了）。 2、参照定位的元素必须加入position:relative; #box1 { width : 200px ; height : 200px ; position : relative ; } 3、定位元素加入position:absolute，便可以使用top、bottom、left、right来进行偏移定位了。 #box2 { position : absolute ; top : 20px ; left : 30px ; } 这样box2就可以相对于父元素box1定位了（这里注意参照物就可以不是浏览器了，而可以自由设置了）。 3.10 CSS代码缩写，占用更少的带宽 3.10.1 盒模型代码简写 还记得在讲盒模型时外边距(margin)、内边距(padding)和边框(border)设置上下左右四个方向的边距是按照顺时针方向设置的：上右下左。具体应用在margin和padding的例子如下： margin:10px 15px 12px 14px;/*上设置为10px、右设置为15px、下设置为12px、左设置为14px*/ 通常有下面三种缩写方法: 1、如果top、right、bottom、left的值相同，如下面代码： margin:10px 10px 10px 10px; 可缩写为： margin:10px; 2、如果top和bottom值相同、left和 right的值相同，如下面代码： margin:10px 20px 10px 20px; 可缩写为： margin:10px 20px; 3、如果left和right的值相同，如下面代码： margin:10px 20px 30px 20px; 可缩写为： margin:10px 20px 30px; 注意：padding、border的缩写方法和margin是一致的。 3.10.2 颜色值缩写 关于颜色的css样式也是可以缩写的，当你设置的颜色是16进制的色彩值时，如果每两位的值相同，可以缩写一半。 例子1： p{color:#000000;} 可以缩写为： p{color: #000;} 例子2： p{color: #336699;} 可以缩写为： p{color: #369;} 3.10.3 字体缩写 网页中的字体css样式代码也有他自己的缩写方式，下面是给网页设置字体的代码： body { font-style : italic ; font-variant : small-caps ; font-weight : bold ; font-size : 12px ; line-height : 1.5em ; font-family : \"宋体\" , sans-serif ; } 这么多行的代码其实可以缩写为一句： body { font : italic small-caps bold 12px / 1.5em \"宋体\" , sans-serif ; } 注意： 1、使用这一简写方式你至少要指定 font-size 和 font-family 属性，其他的属性(如 font-weight、font-style、font-varient、line-height)如未指定将自动使用默认值。 2、在缩写时 font-size 与 line-height 中间要加入\"/\"斜扛。 一般情况下因为对于中文网站，英文还是比较少的，所以下面缩写代码比较常用： body { font : 12px / 1.5em \"宋体\" , sans-serif ; } 只是有字号、行间距、中文字体、英文字体设置。 3.11 单位和值 3.11.1 颜色值 在网页中的颜色设置是非常重要，有字体颜色（color）、背景颜色（background-color）、边框颜色（border）等，设置颜色的方法也有很多种： 1、英文命令颜色 前面几个小节中经常用到的就是这种设置方法： p{color:red;} 2、RGB颜色 这个与 photoshop 中的 RGB 颜色是一致的，由 R(red)、G(green)、B(blue) 三种颜色的比例来配色。 p{color:rgb(133,45,200);} 每一项的值可以是 0~255 之间的整数，也可以是 0%~100% 的百分数。如： p{color:rgb(20%,33%,25%);} 3、十六进制颜色 这种颜色设置方法是现在比较普遍使用的方法，其原理其实也是 RGB 设置，但是其每一项的值由 0-255 变成了十六进制 00-ff。 p{color:#00ffff;} 配色表： 3.11.2 长度值 长度单位总结一下，目前比较常用到px（像素）、em、% 百分比，要注意其实这三种单位都是相对单位。 1、像素 像素为什么是相对单位呢？因为像素指的是显示器上的小点（CSS规范中假设\"90像素=1英寸\"）。实际情况是浏览器会使用显示器的实际像素值有关，在目前大多数的设计者都倾向于使用像素（px）作为单位。 2、em 就是本元素给定字体的 font-size 值，如果元素的 font-size 为 14px ，那么 1em = 14px；如果 font-size 为 18px，那么 1em = 18px。如下代码： p{font-size:12px;text-indent:2em;} 上面代码就是可以实现段落首行缩进 24px（也就是两个字体大小的距离）。 下面注意一个特殊情况： 但当给 font-size 设置单位为 em 时，此时计算的标准以 p 的父元素的 font-size 为基础。如下代码： html: <p>以这个<span>例子</span>为例。</p> css: p { font-size : 14px } span { font-size : 0.8em ;} 结果 span 中的字体\"例子\"字体大小就为 11.2px（14 * 0.8 = 11.2px）。 3、百分比 p{font-size:12px;line-height:130%} 设置行高（行间距）为字体的130%（12 * 1.3 = 15.6px）。 3.12 css样式设置小技巧 3.12.1 水平居中设置-行内元素 我们在实际工作中常会遇到需要设置水平居中场景，今天我们就来看看怎么设置水平居中的。 如果被设置元素为文本、图片等行内元素时，水平居中是通过给父元素设置 text-align:center 来实现的。如下代码： html代码： <body> <div class= \"txtCenter\" > 我是文本，哈哈，我想要在父容器中水平居中显示。 </div> </body> css代码： <style> div.txtCenter{ text-align:center; } </style> 3.12.2 水平居中设置-定宽块状元素 当被设置元素为块状元素时用 text-align：center 就不起作用了，这时也分两种情况：定宽块状元素和不定宽块状元素。这一小节我们先来讲一讲定宽块状元素。 满足定宽和块状两个条件的元素是可以通过设置\"左右margin\"值为\"auto\"来实现居中的。我们来看个例子就是设置 div 这个块状元素水平居中： html代码： <body> <div> 我是定宽块状元素，哈哈，我要水平居中显示。 </div> </body> css代码： <style> div{ border:1px solid red;/*为了显示居中效果明显为 div 设置了边框*/ width:500px;/*定宽*/ margin:20px auto;/* margin-left 与 margin-right 设置为 auto */ } </style> 也可以写成： margin-left :auto ; margin-right :auto ; 注意：元素的\"上下 margin\" 是可以随意设置的。 3.12.3 水平居中总结-不定宽块状元素方法（一） 在实际工作中我们会遇到需要为\"不定宽度的块状元素\"设置居中，比如网页上的分页导航，因为分页的数量是不确定的，所以我们不能通过设置宽度来限制它的弹性。 不定宽度的块状元素有三种方法居中（这三种方法目前使用的都比多）： 1. 加入 table 标签 2. 设置 display:inline 方法 3. 设置 position:relative 和 left:50%; 这一小节我们来讲一下第一种方法： 第一步：为需要设置的居中的元素外面加入一个 table 标签 ( 包括 、 、 )。 第二步：为这个 table 设置\"左右 margin 居中\"（这个和定宽块状元素的方法一样）。 举例如下： html代码： <div> <table> <tbody> <tr><td> <ul> <li><a href= \"#\" > 1 </a></li> <li><a href= \"#\" > 2 </a></li> <li><a href= \"#\" > 3 </a></li> </ul> </td></tr> </tbody> </table> </div> css代码： <style> table{ margin:0 auto; } ul{list-style:none;margin:0;padding:0;} li{float:left;display:inline;margin-right:8px;} </style> ``` ####3.12.4 水平居中总结-不定宽块状元素方法（二） 第二种方法：改变块级元素的 dispaly 为 inline 类型，然后使用 text-align:center 来实现居中效果。如下例子： html代码： 1 2 3 css代码： .container{ text-align:center; } .container ul{ list-style:none; margin:0; padding:0; display:inline; } .container li{ margin-right:8px; display:inline; } 这种方法相比第一种方法的优势是不用增加无语义标签，简化了标签的嵌套深度，但也存在着一些问题：它将块状元素的 display 类型改为 inline，变成了行内元素，所以少了一些功能，比如设定长度值。 ####3.12.5 水平居中总结-不定宽块状元素方法（三） 方法三：通过给父元素设置 float，然后给父元素设置 position : relative 和 left : 50 %，子元素设置 position:relative 和 left:-50% 来实现水平居中。 代码如下： 1 2 3 css代码： .container{ float:left; position:relative; left:50% } .container ul{ list-style:none; margin:0; padding:0; position:relative; left:-50%; } .container li{float:left;display:inline;margin-right:8px;} 这种方法可以保留块状元素仍以 display:block 的形式显示，优点不添加无语议表标签，不增加嵌套深度，但它的缺点是设置了 position:relative，带来了一定的副作用。 这三种方法使用得都非常广泛，各有优缺点，具体选用哪种方法，可以视具体情况而定。 ####3.12.6 垂直居中-父元素高度确定的单行文本 父元素高度确定的单行文本的竖直居中的方法是通过设置父元素的 height 和 line-height 高度一致来实现的。如下代码： hi,imooc! css代码： .container{ height:100px; line-height:100px; background:#999; } ####3.12.7 垂直居中-父元素高度确定的多行文本（方法一） 父元素高度确定的多行文本、图片、块状元素的竖直居中的方法有两种： 方法一：使用插入 table (包括tbody、tr、td)标签，同时设置 vertical-align：middle。 说到竖直居中，css 中有一个用于竖直居中的属性 vertical-align，但这个样式只有在父元素为 td 或 th 时，才会生效。所以又要插入 table 标签了。下面看一下例子： html代码： 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 css代码： table td{height:500px;background:#ccc} 因为 td 标签默认情况下就默认设置了 vertical-align 为 middle，所以我们不需要显式地设置了。 ####3.12.8 垂直居中-父元素高度确定的多行文本（方法二） 在 chrome、firefox 及 IE8 以上的浏览器下可以设置块级元素的 display 为 table-cell，激活 vertical-align 属性，但注意 IE6、7 并不支持这个样式。 html代码： 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 看我是否可以居中。 css代码： .container{ height:300px; background:#ccc; display:table-cell;/*IE8以上及Chrome、Firefox*/ vertical-align:middle;/*IE8以上及Chrome、Firefox*/ } 这种方法的好处是不用添加多余的无意义的标签，但缺点也很明显，它的兼容性不是很好，不兼容 IE6、7。 ####3.12.9 隐性改变display类型 有一个有趣的现象就是当为元素（不论之前是什么类型元素，display:none 除外）设置以下 2 个句之一： position : absolute float : left 或 float:right 元素会自动变为以 display:inline-block 的方式显示，当然就可以设置元素的 width 和 height 了且默认宽度不占满父元素。 如下面的代码，小伙伴们都知道 a 标签是行内元素，所以设置它的 width 是 没有效果的，但是设置为 position:absolute 以后，就可以了。 进入课程请单击这里 css代码 .container a{ position:absolute; width:200px; background:#ccc; } ``` 想不起 display:inline-block 是做什么的小伙伴们，单击\"元素分类--内联块状元素\"可返回到前面小节进行复习。","tags":"Web","url":"/htmlcssbu-yi.html"},{"title":"企业网站布局实践-10 新闻详情页的制作","text":"1. 页面结构 <div class= \"list_box\" > <h2> 新闻中心 </h2> <h1> 【慕客访谈▪用户篇】\"有为屌丝\"在路上 </h1> <p class= \"list_box_newsInfo\" > 发布人：Admin 发布时间：2015-04-06 浏览3246次 </p> <div class= \"list_box_newsContent\" > </div> </div> 2. 样式 text-indent: 2em; 缩进2个文本尺寸 // 新闻列表区域 .list_box { width : 770px ; min-height : 350px ; _height : 350px ; border : 1px solid #E8E8E8 ; float : right ; background-color : #FFF ; // 新闻类别头部标题 h2 { height : 35px ; line-height : 35px ; font-size : 14px ; font-family : \"微软雅黑\" ; color : #666 ; background : url(../images/type_bg.png) repeat-x ; padding-left : 20px ; } // 新闻标题 h1 { font-family : \"微软雅黑\" ; font-size : 20px ; text-align : center ; margin : 10px 0 ; } & _newsInfo { color : #666 ; text-align : center ; border-bottom : 1px dotted #666 ; } & _newsContent { font-size : 14px ; padding : 20px ; line-height : 25px ; text-indent : 2em ; // 缩进 2 个文本尺寸 } }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-10-xin-wen-xiang-qing-ye-de-zhi-zuo.html"},{"title":"企业网站布局实践-09 新闻列表页制作","text":"1. 新闻列表页的制作 新闻列表页和首页对比如下： 主要是两点不同，第一个是新闻列表页焦点图不再具有切换效果，图片大小也不一样；第二个就是内容区是2栏可变长的。 2. 页面结构 <div class= \"ad\" id= \"picBox\" style= \"height:243px\" > <img src= \"images/ad.jpg\" alt= \"ad\" > </div> <!-- ad结束 --> <div class= \"list_main\" > <div class= \"news_type\" ></div> <!-- news_type结束 --> <div class= \"list_box\" ></div> <!-- list_box结束 --> </div> <!-- list_main结束 --> 3. 内容展示区制作 /*--------------------新闻列表页----------------------------*/ .list_main { height : 350px ; background-color : #FFF ; margin-top : 10px ; } .news_type { width : 220px ; min-height : 350px ; _height : 350px ; border : 1px solid #E8E8E8 ; background-color : #F9C ; float : left ; } .list_box { width : 770px ; min-height : 350px ; _height : 350px ; background-color : #F9F ; border : 1px solid #E8E8E8 ; float : right ; } 4. 左侧列表制作 <div class= \"news_type\" > <h2> 新闻中心 </h2> <div class= \"news_type_content\" > <ul> <li><a href= \"list.html\" > 公司新闻 </a></li> <li><a href= \"list.html\" > 行业新闻 </a></li> <li><a href= \"list.html\" > 媒体报道 </a></li> <li><a href= \"list.html\" > 活动专题 </a></li> <li><a href= \"list.html\" > 精彩视频 </a></li> <li><a href= \"list.html\" > 资源下载 </a></li> <li><a href= \"list.html\" > 公司内刊 </a></li> </ul> </div> </div> <!-- news_type结束 --> // 新闻类别 .news_type { width : 220px ; min-height : 350px ; _height : 350px ; border : 1px solid #E8E8E8 ; float : left ; // 新闻类别头部标题 h2 { height : 35px ; line-height : 35px ; font-size : 14px ; font-family : \"微软雅黑\" ; color : #666 ; background : url(../images/title_bg.gif) repeat-x ; padding-left : 20px ; } // 列表区域 & _content { height : 265px ; background : url(../images/content_bg.gif) repeat-x ; li { list-style-type : none ; height : 30px ; line-height : 30px ; a { color : #666 ; text-decoration : none ; background : url(../images/li_bg.gif) no-repeat left center ; // 图像左侧居中 padding-left : 15px ; display : block ; &: hover { color : #009CDF ; background : url(../images/li_bg2.gif) no-repeat left center ; background-color : #F2F2F2 ; // 即设置背景图像又设置背景颜色 } } } } } 5. 新闻列表制作 <div class= \"list_box\" > <h2> 新闻中心 </h2> <div class= \"news_list\" > <ul> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【慕客访谈 用户篇】\"有为屌丝\"在路上 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【有奖活动】给父亲的三行书信 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 《程序猿，请晒出你的童年》活动获奖公告 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【慕课访谈】破茧成蝶——美女程序员的蜕变史 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【有奖活动】给父亲的三行书信 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【慕客访谈 用户篇】\"有为屌丝\"在路上 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 《程序猿，请晒出你的童年》活动获奖公告 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【慕课访谈】破茧成蝶——美女程序员的蜕变史 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 【慕客访谈 用户篇】\"有为屌丝\"在路上 </a></li> <li><span> 2015-04-06 </span><a href= \"news.html\" > 《程序猿，请晒出你的童年》活动获奖公告 </a></li> </ul> </div> <!-- news_list结束 --> </div> <!-- list_box结束 --> // 新闻列表区域 .list_box { width : 770px ; min-height : 350px ; _height : 350px ; border : 1px solid #E8E8E8 ; float : right ; // 新闻类别头部标题 h2 { height : 35px ; line-height : 35px ; font-size : 14px ; font-family : \"微软雅黑\" ; color : #666 ; background : url(../images/type_bg.png) repeat-x ; padding-left : 20px ; } } // 新闻列表 .news_list { . news_list (); } 6. 页码制作 a标签是内联元素，为了使内联元素具有块级元素的一些属性同时使所有的a标签显示在同一行上，我们需要把a标签设置为行内块元素inline-block。 <div class= \"page\" > <a href= \"#\" > 首页 </a> <a href= \"#\" > &lt; </a> <a href= \"#\" > 1 </a> <a href= \"#\" > 2 </a> <a href= \"#\" > 3 </a> <a href= \"#\" > ... </a> <a href= \"#\" > &gt; </a> <a href= \"#\" > 末页 </a> </div> <!-- page结束 --> // 页码 .page { height : 40px ; margin-top : 10px ; text-align : center ; a { border : 1px solid #E8E8E8 ; text-decoration : none ; margin : 5px ; padding : 5px 10px ; display : inline - block ; // 行内块级元素 &: link , &: visited { color : #000 ; } & :hover , & :active { color : #FFF ; background-color : #cc1b1b ; } } }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-09-xin-wen-lie-biao-ye-zhi-zuo.html"},{"title":"企业网站布局实践-08 底部版权区制作","text":"1. 结构分析 2. 文档结构 <div class= \"copyright\" > <div class= \"copyright_content\" > <ul> <li> 关于 <ul> <li> 品牌故事 </li> <li> 联系我们 </li> <li> 加入我们 </li> <li> 版权声明 </li> </ul> </li> <li> 课程 <ul> <li> PHP开发 </li> <li> 前端开发 </li> <li> JAVA开发 </li> <li> Android开发 </li> </ul> </li> <li> 关注 <ul> <li> 新浪微博 </li> <li> 新浪微博 </li> <li> 企业微信 </li> <li> QQ空间 </li> </ul> </li> <li> 留言 <ul> <li> 意见反馈 </li> <li> 问题留言 </li> <li> 媒体联络 </li> <li> 在线客服 </li> </ul> </li> <li><img src= \"images/weixin.png\" alt= \"微信\" width= \"30px\" height= \"27px\" > 微信 <ul> <li><img src= \"images/qrcode.jpg\" alt= \"扫描关注慕课网官方微信\" width= \"102\" height= \"102\" /></li> </ul> </li> </ul> </div> <!-- copyright_content结束 --> </div> <!-- copyright结束 --> 3. LESS实现 .copyright { clear: both ; width: 100%; height: 200 px ; background-color: #E8E8E8; margin-top: 10 px ; } .copyright_content { width: 1000 px ; margin: 0 auto ; padding-top: 20 px ; height: 180 px ; li { list-style-type: none ; float: left ; width: 200 px ; text-align: center ; background: url (.. / images / line.png ) no-repeat right center ; font-size: 18 px ; font-family: \"微软雅黑\"; color: #999; line-height: 30 px ; ul li { font-size: 14 px ; } } }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-08-di-bu-ban-quan-qu-zhi-zuo.html"},{"title":"企业网站布局实践-07 侧边栏制作","text":"1. 结构分析 从图中我们知道，除标题外，其余内容大致分成上下两部分。分别是上面的视频和下面的广告。下面我们来实现这个效果。 2. 文档结构 <div class= \"sidebar\" > <div class= \"video\" > <div class= \"title\" > <h2 class= \"title_left\" > 媒体聚焦 </h2><span class= \"title_right\" ><a href= \"news.html\" > More &gt;&gt; </a></span> </div> <!-- title结束 --> <p class= \"video_content\" > <embed src= \"http://player.youku.com/player.php/sid/XNjkzMDE5MTUy/v.swf\" allowfullscreen= \"true\" quality= \"high\" width= \"220\" height= \"140\" align= \"middle\" allowscriptaccess= \"always\" type= \"application/x-shockwave-flash\" > </p> <!-- video_content结束 --> </div> <!-- video结束 --> <div class= \"service\" > <img src= \"images/app.jpg\" alt= \"app\" > </div> <!-- services结束 --> </div> <!-- sidebar结束 --> 3. LESS实现 .sidebar { width: 230 px ; .video { height: 185 px ; margin-bottom: 10 px ; border: 1 px solid #E8E8E8; & _content { height: 150 px ; text-align: center ; } } } .service { height: 55 px ; border: 1 px solid #E8E8E8; }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-07-ce-bian-lan-zhi-zuo.html"},{"title":"企业网站布局实践-06 课程中心制作","text":"1. 结构分析 2. 网页结构 <div class= \"course\" > <div class= \"title\" > <h2 class= \"title_left\" > 课程中心 </h2><span class= \"title_right\" ><a href= \"news.html\" > More &gt;&gt; </a></span> </div> <!-- title结束 --> <div class= \"course_pic\" > <img src= \"images/css.jpg\" alt= \"css\" ><h2><a href= \"news.html\" > CSS圆角进化论 </a></h2><p> CSS圆角的实现，经历了三大发展阶段：背景图片方式、CSS2.0+HTML标签模拟、CSS3.0圆角属性）。本案例详细讲解每一种的实现方式，并对实现的优缺点进行对比分析。 </p> </div> <!-- course_pic结束 --> <div class= \"course_type\" > <ul> <li> PHP开发 </li> <li> 前端开发 </li> <li> JAVA开发 </li> <li> Android开发 </li> </ul> </div> <!-- course_type结束 --> </div> <!-- course结束 --> course分为3部分： title部分与新闻中心类似 course_pic图片课程部分与新闻中心也类似 course_type部分就是一个列表 3. LESS实现 1、首先是course整个框架，在之前已经定义过 .news , .course , .sidebar { height: 250 px ; float: left ; } 2、title部分与新闻中心的title是使用同一套 // 标题 .title { height : 35px ; border-bottom : 2px solid #E8E8E8 ; // 新闻中心 & _left { width : 70% ; line-height : 35px ; // 垂直居中 font-family : \"微软雅黑\" ; font-size : 14px ; font-weight : bold ; color : #786F66 ; float : left ; padding-left : 20px ; } // 更多 & _right { width : 20% ; line-height : 35px ; float : right ; text-align : right ; a { text-decoration : none ; color : #999999 ; font-family : \"宋体\" ; font-size : 10px ; font-weight : normal ; padding-right : 10px ; } } } 3、图片 因为这部分与新闻中心的有些类似，只是高度不同，因此，我们将它提取为一个通用LESS // 图片内容 .pic_content ( @pic_height ) { height : @pic_height ; margin-top : 10px ; line-height : 22px ; // 设置行高 img { float : left ; margin : 0 5px ; } a { color : #C00 ; text-decoration : none ; } } // 调用 & _pic { . pic_content ( 120px ); } 4、课程类型 先固定高度与宽度，居中，设置背景图。 然后再设置其中的li，使其居中，左右间距为15px & _type { height : 37px ; width : 372px ; background : url(../images/product_type_bg.jpg) no-repeat ; margin : 20px auto ; li { list-style-type : none ; float : left ; line-height : 37px ; margin : 0 15px ; text-align : center ; } } 效果图如下：","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-06-ke-cheng-zhong-xin-zhi-zuo.html"},{"title":"企业网站布局实践-05 新闻中心制作","text":"1、结构分析 从上到下可以分为新闻标题、图片新闻和图片新闻。 2、创建结构 新闻中心分为标题、图片新闻和新闻列表3部分。 其中，新闻列表还是使用无序列表。 <div class= \"news\" > <div class= \"title\" > <h2> 新闻中心 </h2><a href= \"news.html\" > More &gt;&gt; </a> </div> <!-- title结束 --> <div class= \"pic_news\" > <img src= \"images/news.jpg\" alt= \"\" ><h2> 520 慕女神喊你来表白！ </h2> <p> 活动时间：5月20日—5月25日 <br> 获奖公布时间：5月26日 <br> Learn More>> </p> </div> <!-- pic_news结束 --> <div class= \"news_list\" > <ul> <li><a href= \"news.html\" > 【慕客访谈 用户篇】\"有为屌丝\"在路上 </a><span> 2014-06-01 </span></li> <li><a href= \"news.html\" > 【有奖活动】给父亲的三行书信 </a><span> 2014-06-01 </span></li> <li><a href= \"news.html\" > 《程序猿，请晒出你的童年》活动获奖公告 </a><span> 2014-05-30 </span></li> <li><a href= \"news.html\" > 【慕课访谈】破茧成蝶——美女程序员的蜕变史 </a><span> 2014-05-28 </span></li> </ul> </div> <!-- news_list结束 --> </div> <!-- news结束 --> 3、创建新闻中心标题的CSS 新闻标题是title节 .news { width: 340 px ; border: 1 px solid #E8E8E8; background-color: #FFF; .title { height: 35 px ; border-bottom: 2 px solid #E8E8E8; //\"新闻中心\"几个字左对齐 & _left { width: 70%; line-height: 35 px ; //居中 font-family: \"微软雅黑\"; font-size: 14 px ; font-weight: bold ; color: #786F66; float: left ; padding-left : 20 px ; } //\" more \"右对齐 & _right { width: 20%; line-height: 35 px ; float: right ; text-align: right ; a { text-decoration: none ; color : #999999; font-family: \"宋体\"; font-size: 10 px ; font-weight: normal ; padding-right: 10 px ; } } } } 说明： - text-decoration 去除a的下划线 - line-height 设置行高可以设置居中对齐 运行结果如下： 4、新闻中心之图片新闻 // 图片新闻 .pic_news { height : 80px ; margin-top : 10px ; line-height : 22px ; // 设置行高 img { float : left ; margin-top : 0 5px ; } a { color : #C00 ; text-decoration : none ; } } 说明： - line-height 设置行高可以增大文字行间距。 5、新闻中心之新闻列表 // 新闻列表 .news_list () { margin-top : 20px ; li { list-style-type : none ; // 去除默认样式 background : url(../images/list.jpg) no-repeat ; // 添加新样式 padding-left : 10px ; // 保持图标与文字一段距离 margin : 8px ; // 设置周围间距 border-bottom : 1px dotted #CCC ; // 每条新闻下加虚线 // 新闻链接样式 a { &: link , &: visited { text-decoration : none ; color : #000 ; } & :hover , & :active { text-decoration : none ; color : #F00 ; } } // 日期 span { color : #999 ; float : right ; } } } 注意li符号可以通过background、padding-left、list-style-type 3者结合进行设置，也可使用list-style-image进行设置。 list-style-type可以设置列表项目符号为：none无项目符号，disc实心圆，circle空心圆，square实心方块等但是不可以设置图片为项目符号。","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-05-xin-wen-zhong-xin-zhi-zuo.html"},{"title":"企业网站布局实践-04 信息展示区制作","text":"1. 结构分析 分析如下： 盒子之间的间距应该是多少呢？ 整个盒子宽度是1000px，3个盒子宽度是340、410以及230px(总和为980px)，那么外边据是否就是10px了呢（10*2+980=1000）？不是的，因为每个小盒子左右都有1px的边框，一共6px，因此是(20-6)/2 = 7px. 2. 实现 首先定义结构： <div class= \"main\" > <div class= \"news\" ></div> <div class= \"course\" ></div> <div class= \"sidebar\" ></div> </div> <!-- main结束 --> 其次是LESS // 定义区域整体高度 .main { height : 250px ; margin-top : 5px ; background-color : #23E ; } // 定义子盒子高度与浮动 .news , .course , .sidebar { height : 250px ; float : left ; } // 定义每个盒子 .news { width : 340px ; border : 1px solid #E8E8E8 ; background-color : #DAF ; } .course { width : 410px ; border : 1px solid #E8E8E8 ; margin : 0 7px ; background-color : #AEF ; } .sidebar { width : 230px ; background-color : #333 ; }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-04-xin-xi-zhan-shi-qu-zhi-zuo.html"},{"title":"企业网站布局实践-03焦点图制作","text":"1. 使用myFocus焦点图库 http://demo.jb51.net/js/myfocus/download.html 选择demo演示下载解压，拷贝js文件夹与当前js文件夹合并。 1.1 引入myFocus库文件和样式文件 <script src= \"js/myFocus-2.0.1.min.js\" ></script> <script src= \"js/mf-pattern/mF_YSlider.js\" ></script> <link rel= \"stylesheet\" href= \"js/mf-pattern/mF_YSlider.css\" > 1.2 构建页面中使用的图片 首先添加图片 <div class= \"ad\" id= \"picBox\" > <ul> <li><img src= \"images/ad2.jpg\" alt= \"\" ></li> <li><img src= \"images/ad3.jpg\" alt= \"\" ></li> <li><img src= \"images/ad4.jpg\" alt= \"\" ></li> </ul> </div> <!-- ad结束 --> 然后定义ad的样式，我们知道图片的高度是310px .ad { height: 310 px ; } 此时预览图片可以看到图片溢出了ad取，需要增加 overflow:hidden .ad { height: 310 px ; overflow: hidden ; } 1.3 增加切换动作 给.ad添加id，并给里面添加一层 <div class=\"pic\"> 。 <div class= \"ad\" id= \"picBox\" > <div class= \"pic\" > <ul> <li><img src= \"images/ad2.jpg\" alt= \"\" ></li> <li><img src= \"images/ad3.jpg\" alt= \"\" ></li> <li><img src= \"images/ad4.jpg\" alt= \"\" ></li> </ul> </div> </div> <!-- ad结束 --> 添加js <script> myFocus.set({ id:'picBox' }); </script> 1.4 添加loading提示 刚加载时，可能会发生白屏现象，我们可以给焦点图添加loading动画。 <div class= \"ad\" id= \"picBox\" > <div class= \"loading\" ><img src= \"images/loading.gif\" alt= \"图片加载中\" ></div> <div class= \"pic\" > <ul> <li><img src= \"images/ad2.jpg\" alt= \"\" ></li> <li><img src= \"images/ad3.jpg\" alt= \"\" ></li> <li><img src= \"images/ad4.jpg\" alt= \"\" ></li> </ul> </div> </div> <!-- ad结束 --> 运行效果如下：","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-03jiao-dian-tu-zhi-zuo.html"},{"title":"企业网站布局实践-02导航部分制作","text":"1. 分析 我们将导航分为左中右三部分。 其中导航中部分为两部分，分别放置菜单栏和搜索框。 导航栏菜单使用有序列表或无需列表，搜索框使用form表单的input标签。 2. 实现HTML 添加nav的html <div class= \"nav\" > <div class= \"nav_left\" ></div> <div class= \"nav_mid\" > <div class= \"nav_mid_left\" > <ul> <li><a href= \"#\" > 首页 </a></li> <li><a href= \"#\" > 关于慕课 </a></li> <li><a href= \"#\" > 新闻动态 </a></li> <li><a href= \"#\" > 课程中心 </a></li> <li><a href= \"#\" > 在线课程 </a></li> <li><a href= \"#\" > 人才招聘 </a></li> </ul> </div> <div class= \"nav_mid_right\" > <form action= \"\" method= \"post\" ><input type= \"text\" ></form> </div> </div> <!-- nav_mid结束 --> <div class= \"nav_right\" ></div> </div> <!-- nav结束 --> 3. 实现LESS 3.1 实现框架 .nav { @ nav_h: 40 px ; @ nav_w: 10 px ; height: @ nav_h ; clear: both ; & _left { width: @ nav_w ; height: @ nav_h ; background: url (.. / images / nav_left.jpg ) no-repeat ; // background-image: url (.. / images / nav_left.jpg ) ; // background-repeat: no-repeat ; float: left ; } & _mid { width: 980 px ; background: url (.. / images / nav_bg.jpg ) repeat-x ; float: left ; } & _right { width: @ nav_w ; height: @ nav_h ; background: url (.. / images / nav_right.jpg ) no-repeat ; float: left ; } } 3.2 实现菜单文本 & _mid { width : 980px ; background : url(../images/nav_bg.jpg) repeat-x ; & _left , & _right { float : left ; } & _left { width : 680px ; li { float : left ; list-style : none ; // 去掉默认 list-style width : 100px ; text-align : center ; // 文本中间对齐 line-height : 40px ; // 文本垂直居中，与对应的盒子高度对齐 } a { &: link , &: visited { text-decoration : none ; color : #FFF ; font-size : 16px ; font-family : \"微软雅黑\" ; } & :hover , & :active { text-decoration : none ; color : #FF0 ; font-size : 16px ; font-family : \"微软雅黑\" ; } } } 实现搜索框 .search_text { width: 190 px ; height: 25 px ; padding-right: 25 px ; //为背景图腾出空间 background: url (.. / images / search.jpg ) no-repeat right center ; //背景图右侧垂直居中 background-color: #FFF;//设置背景色 margin-top: 7 px ; //处于导航中间 boader: 1 px solid #FFF; //边框白色为1 } 更改菜单背景颜色 由于a标签属于内联元素，无高度和宽度属性，因此控制鼠标经过状态改变背景颜色时，仅在有文字的地方显示背景颜色。解决的办法是把a标签变为块级元素. display : block 综上，实现一个菜单基本如下： <ul> <li><a href= \"#\" > 全部 </a></li> <li><a href= \"#\" > 初级 </a></li> <li><a href= \"#\" > 中级 </a></li> <li><a href= \"#\" > 高级 </a></li> </ul> /*1. 每个列表项的宽度为50px，高度为30px */ ul { height : 30px ; } /*2. 列表中的文字在水平和垂直方向上均居中显示*/ li { list-style : none ; float : left ; width : 50px ; text-align : center ; line-height : 30px ; } /*3. 超链接初始状态和访问后的状态均为黑色无下划线，鼠标经过和点击时文字均为白色，无下划线，背景颜色为#BE3948。*/ li a { display : block ; } li a :link , li a :visited { color : #000 ; text-decoration : none ; } li a :hover , li a :active { color : #FFF ; text-decoration : none ; background-color : #BE3948 ; } 效果图：","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-02dao-hang-bu-fen-zhi-zuo.html"},{"title":"企业网站布局实践-01页面头部制作","text":"1. 总体分析 网站的架构采用自顶向下渐进明细的过程进行规划。 网站首页设计如下： 2. 页面头部制作 1、居中 margin : 0 auto ; 2、更改li的图标 list-style-image : url (../ images / li_bg .gif ); 去除li的默认图标 list-style-type :none ; // 或者 list-style :none 3、浮动菜单右侧 float : right ; 4、菜单的宽度直接设置li的width 5、文本垂直居中 设置元素文字行高等于盒子的高度 line-height : 27px ; 6、去掉a链接的下划线 text-decoration : none ; 设置链接正常状态： a { &: link , &: visited { color : #8E8E8E ; text-decoration : none ; } & :hover , & :active { color : #D90 ; text-decoration : none ; } } 7、文字与图片水平中间对齐 img { vertical-align : middle ; } 效果如下： 代码如下： html <div class= \"top\" > <div class= \"top_content\" > <ul> <li><a href= \"#\" > 加入我们 </a></li> <li><a href= \"#\" > 添加收藏 </a></li> <li><a href= \"#\" > 设为首页 </a></li> </ul> </div> </div> <!-- top结束 --> <div class= \"wrap\" > <div class= \"logo\" > <div class= \"logo_left\" > <img src= \"images/logo.jpg\" alt= \"慕课网\" > </div> <div class= \"logo_right\" > <img src= \"images/tel.jpg\" alt= \"服务热线\" > 24小时服务热线: <span class= \"tel\" > 123-456-7890 </span> </div> </div> <!-- logo结束 --> </div> <!-- wrap结束 --> 对应的LESS .top { width: 100%; height: 27 px ; background: url (.. / images / top_bg.jpg ) repert-x ; & _content { width: 1000 px ; margin: 0 auto ; li { list-style-image: url (.. / images / li_bg.gif ) ; float: right ; width: 80 px ; line-height: 27 px ; } a { &: link , & : visited { color: #8E8E8E; text-decoration: none ; } &: hover , & : active { color: #D90; text-decoration: none ; } } } } .wrap { width: 1000 px ; margin: 0 auto ; background-color: #FFF; .logo { height: 80 px ; & _left { width: 200 px ; float: left ; } & _right { width: 300 px ; float: right ; height: 28 px ; margin-top: 30 px ; color: #8E8E8E; img { vertical-align: middle ; margin-right: 10 px ; } } } } .tel { font-family: \"微软雅黑\"; font-size: 16 px ; color: #C00; }","tags":"Web","url":"/qi-ye-wang-zhan-bu-ju-shi-jian-01ye-mian-tou-bu-zhi-zuo.html"},{"title":"网页布局基础","text":"1. 自动居中一列布局 1.1 相关知识讲解 1.1.1 W3C标准： 结构化标准语言(HTML和XML) 表现标准语言(CSS) 行为标准语言(DOM和ECMAScript) 倡导结构、样式、行为分离 1.1.2 CSS中的定位机制 CSS中，存在3种定位机制： - 标准文档流(Normal Flow) - 浮动(Floats) - 绝对定位(Absolute Position) 1.1.3 标准文档流 特点： 从上到下，从左到右，输出文档内容 由块级元素与行级元素组成 块级元素 从左到右，独占一行 触碰到页面边缘时，会自动换行。 常见块级元素： div ul li dl dt p 行级元素 能在同一行内显示，不会改变HTML的文档结构 常见行级元素： span strong img input ... 块级元素和行级元素都是盒子模型。 1.2 盒子模型 css中盒子模型包含属性margin、border、padding、width与height，他们可以把它转移到我们日常生活中的盒子（箱子）上来理解，日常生活中所见的盒子也具有这些属性，所以叫它盒子模式。那么内容就是盒子里装的东西（element）；而填充（padding）就是怕盒子里装的东西（贵重的）损坏而添加的泡沫或者其它抗震的辅料；边框（border）就是盒子本身了；至于边界（margin）则说明盒子摆放的时候的不能全部堆在一起，要留一定空隙保持通风，同时也为了方便取出嘛。 1.2.1 盒子模型由4部分组成 边框(border) 外边框(margin) 内边距(padding) 盒子中的内容(content) 其中边框、外边框和内边框有4个方向，同时设置是顺时针方向设置（上、右、下、左） 设置4个值时就是上右下左 设置3个值：第一个值代表top，第二个代表right\\left，第三个是bottom 设置2个值：第一个代表top\\bottom, 第二个代表right\\left 设置1个值：4个方向属性都是相同的。 就近原则：行内样式>内部样式>外部原则 1.2.2 边框的设置 粗细、样式、颜色的顺序，3者缺一不可 img { margin : 10px 18px ; border : 1px solid #b1adad ; } 注意：图片之间的间距是用margin来设置的 1.2.3 盒子3D模型 见下图 1.2.4 背景设置 .book { background: url ( images / t_book.gif ) 0 0 no-repeat ; } 设置顺序：背景图 横坐标 纵坐标 重复 颜色; 其中横坐标、纵坐标、颜色可以省略。 从盒子3D模型可以知道，背景层在边框和内容与内间距的下层，为了避免内容遮盖住背景图片，应该给盒子添加内边距(padding)。 1.2.4 盒子模型尺寸 盒子模型尺寸=边框+外边框+内边框+盒子中的内容尺寸 css中width与height的计算方法 在 CSS 中，width 和 height 指的是内容区域的宽度和高度。增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的尺寸。 但是在浏览器中实际的宽度与高度的值是按width=margin-left + margin-right + padding-left + padding-right + width与height=margin-left + margin-right + padding-left + padding-right + height这个计算的。所以当我们布局一个网页的时候，经常会遇到这样的一种情况，那就是最终网页成型的宽度或是高度会超出我们预先的计算，其实就就是所谓的CSS的盒模型造成的。因此在我们布局网页的时候要将这一部分内容计算在内。 例如：#div{margin:10px;padding:10px;border:10px;width:100px;height:100px;} 他的实际width为160px ，height为160px。 1.3 网页布局基础-自动居中一列布局 将页面设置为 { margin : 0px auto ; width : 960px ;} auto是让浏览器自动计算两边的外边距。width可以使像素，也可以是百分比。 注意：设置自动居中的div不能再设置浮动(float)或绝对定位属性(position:absolute) 2. 横向两列布局 2.1 浮动布局简洁及float属性 浮动布局：CSS中规定的第三种定位机制，通过设置float属性实现横向多列。 float属性有4个属性值： left:左浮动 right:右浮动 none:不浮动 inherit:从父元素继承float属性 特点： 1. 元素会左移，或右移，直到碰触到容器为止 2. 设置了浮动的元素，仍旧处于标准文档流中 当元素没有设置宽度值，而设置了浮动属性，元素的宽度随内容的变化而变化。 当元素设置浮动属性后，会对相邻的元素产生影响（相邻元素特指 紧邻后面 的元素）。 当两个元素都设置浮动时，其紧挨着的相邻元素就会被影响。 2.2 清除浮动常用的两种方法 第一种方法：为元素设置 clear 属性，并设置为 clear:both; 或 clear:left; 或者 clear:right; 第二种方法：为元素设置 width:100% 或固定宽度，然后 overflow:hidden; 2015-07-09补充： CSS3中还有一种方法： .article-preview { &> div { float: left ; } &: after { content: ''; display: block ; clear: both ; } } 2.3 横向两列布局 主要方法： float属性，使纵向两列的块级元素，横向排列； margin属性，设置两列之间的间距。 设置float的两列布局对其父包含块和父包含的紧邻元素产生影响，因此需对父包含和紧邻元素清除浮动： 对父包含块清除不能使用 clear:both; ，要使用 overflow:hidden; ; 紧邻元素使用 clear:both; 清除浮动。 最好不要设置div的高度 。 增加两列之间的间距使用margin或者设置另一侧为right浮动。 3. 绝对定位布局 3.1 绝对定位布局简介 CSS中规定的第三种定位机制。能够实现横向多列布局及较为复杂的定位，例如：带有遮罩层效果的提示框、固定层效果、全屏广告等。 position有3种形式：1. 静态定位（默认的） 2. 相对的(relative) 3. 绝对定位(absolute, fixed) position有4个属性值：static, relative, absolute, fixed(固定定位) 3.2 相对定位 特点： 相对于自身原有位置进行便宜; 仍旧处于标准文档流中; 随即拥有偏移属性(top, right, bottom, left)和z-index属性。 设置相对定位后，可以设置偏移属性： top:50px;left:100px; . 3.3 绝对定位 特点： 建立了以包含块为基准的定位 完全脱离了标准文档流 随即拥有了偏移属性和Z-index属性 3.3.1 未设置偏移量 特点： 无论是否存在 已定位祖先元素 ，都保持在元素出事位置； 脱离了标准文档流，宽度随内容而变 如果一个元素存在相对定位、绝对定位、固定定位中的任何一个，都叫已定位了 一般来说，设置了绝对定位的元素其父包含块需要设置相对定位。 3.3.2 使用绝对定位实现横向两列布局 这种应用比较少。 一般应用于：一列固定宽度，另一列宽度自适应的情况 主要应用技能： relative:父元素相对定位 absolute：自适应宽度元素绝对定位 margin:让绝对定位的元素给固定宽度的元素让出一些位置。 注意：固定宽度列的高度要大于自适应列","tags":"Web","url":"/wang-ye-bu-ju-ji-chu.html"},{"title":"LESS学习笔记","text":"1. LESS注释 //不会被编译到CSS中 /*编译到CSS*/ 2. 变量 // 定义 @test_width : 10px ; .box { width :@ test_width ; // 调用 } 3. 混合 // 第一种 .box1 { border : 5px solid pink ; } .box2 { . box1 ; } // 第二种 .box3 ( @border_width ) { border : @border_width solid yellow ; } .box3_1 { . box3 ( 3px ); } // 第三种 .box4 ( @border_width :1px ) { border : @border_width solid yellow ; } .box4_1 { . box4 (); } 4. 匹配模式 .traingle ( top , @w : 5 px , @c : #ccc){ } .traingle ( bottom , @w : 5 px , @c : #ccc){ } //通用匹配，不论匹配哪一个都会把这个给带上 .traingle ( @_ , @w : 5 px , @c : #ccc){ } .box { .traingle ( top ) ;//也会调用通用匹配哦 } 5. 嵌套 ul{ //... li{ } a { //... &:hover{ } } }","tags":"Web","url":"/lessxue-xi-bi-ji.html"},{"title":"PhoneGap命令行的使用","text":"1. 环境配置 1.1 常用框架 jQuery Backbone.js dojo bootstrap kendo UI Sencha jQuery Mobile PhoneJS AngularJS ICENIUM 1.2 Node.js 下载并安装nodejs 1.3 iOS 下载Xcode 打开Xcode 1.4 Android 定义ANDROID_HOME=E:\\adt\\sdk 将 E:\\adt\\sdk\\platform-tools 和 E:\\adt\\sdk\\tools 加入到环境变量中去。 1.5 Ant 定义ANT_HOME=C:\\apache-ant-1.9.3 2 安装PhoneGap 2.1 安装PhoneGap npm install -g phonegap 安装过后通过 phonegap -v 看是否安装成功 2.2 安装cordova npm install -g cordova 通过 cordova -v 来查看是否成功 一般安装phonegap即可 3 使用PhoneGap和Cordova 3.1 创建项目 >phonegap create project_name project_id display_name 或者使用cordova创建： >cordova create project_name project_id displayname 3.2 应用结构 hooks platforms:平台 plugins: 插件 www：应用代码目录 3.3 build >phonegap build android >phonegap build ios 或者使用cordova命令 >cordova platform add android >cordova build android >cordova platform add ios >cordova build ios >cordova build 如果想要移除某个平台 >cordova platform remove android 4 测试 4.1 iOS测试 >sudo npm install -g ios-deploy >sudo npm install -g ios-sim >phonegap run ios 4.2 Android测试 >phonegap run android 4.3 cordova >cordova run android 5 插件 5.1 安装插件 >phonegap plugin add org.apache.cordova.device 或者直接使用url 5.2 移除插件 >phonegap plugin remove org.apache.cordova.device 5.3 查看安装的插件 >phonegap plugin list 6 合并 7 Hooks before_prepare, before_build, before_install, 等 after_prepare, after_build, after_build, etc >cordova prepare 8 编译部署 8.1 phoneGap build >phonegap remote login -u username -p password >phonegap remote build android 8.2 phonegap serve >phonegap serve #能直接运行 9 下一步 grunt-phonegap","tags":"移动开发","url":"/phonegapming-ling-xing-de-shi-yong.html"},{"title":"ASP.NET MVC5 学习笔记-5 测试","text":"ASP.NET MVC5 学习笔记-5 测试 1. 测试步骤 准备 执行 检查 2. 创建单元测试 注意：单元测试不要包含数据库操作，包含数据库操作的一般成为集成测试。 2.1 编写测试代码 namespace AspNetMVCEssential.Tests.Controllers { [TestClass] public class HomeControllerTest { [TestMethod] public void Index() { // Arrange HomeController controller = new HomeController(); // Act ViewResult result = controller.Index() as ViewResult; // Assert Assert.IsNotNull(result); } [TestMethod] public void About() { // Arrange HomeController controller = new HomeController(); // Act ViewResult result = controller.About() as ViewResult; // Assert Assert.AreEqual(\"Your application description page.\", result.ViewBag.Message); } [TestMethod] public void Contact() { // Arrange HomeController controller = new HomeController(); // Act ViewResult result = controller.Contact() as ViewResult; // Assert Assert.IsNotNull(result); } } } 2.2 运行测试 选定菜单\"测试\"->\"运行\"->运行所有测试或者未成功的测试。 可以在\"测试\"->\"窗口\"->\"测试资源管理器\"中对测试进行管理。 3 Mock测试 Mock测试就是在测试过程中，对于某些不容易构造或者不容易获取的对象，用一个虚拟的对象来创建以便测试的测试方法。 我们要对 TransactionController.cs 进行测试，直接操作数据库不行，怎么办呢？我们可以使用虚拟的接口来进行测试。这需要我们更改一些代码. 3.1 首先，我们更改 TransactionController.cs 更改db为 IApplicationDbContext 类型，并且添加构造方法： private IApplicationDbContext db; //实际使用 public TransactionController() { db = new ApplicationDbContext(); } //生成使用 public TransactionController(IApplicationDbContext dbContext) { db = dbContext; } 3.2 创建IApplicationDbContext对象 public interface IApplication { IDbSet<CheckingAccount> CheckingAccounts{get;set;} IDbSet<Transaction> Transactions{get; set;} public int SaveChanges(); } 让实际的ApplicationDbContext实现IApplicationDbContext。 另外创建一个假的FakeApplicationDbContext实现IApplicationDbContext public class FakeApplicationDbContext:IApplicationDbContext { IDbSet<CheckingAccount> CheckingAccounts{get;set;} IDbSet<Transaction> Transactions{get; set;} public int SaveChanges(){return 0} } 再创建一个FakeDbSet using System; using System.Collections.Generic; using System.Linq; using System.Text; namespace EntityExtensions { public class FakeDbSet<T> : System.Data.Entity.IDbSet<T> where T : class { private readonly List<T> list = new List<T>(); public FakeDbSet() { list = new List<T>(); } public FakeDbSet(IEnumerable<T> contents) { this.list = contents.ToList(); } #region IDbSet<T> Members public T Add(T entity) { this.list.Add(entity); return entity; } public T Attach(T entity) { this.list.Add(entity); return entity; } public TDerivedEntity Create<TDerivedEntity>() where TDerivedEntity : class, T { throw new NotImplementedException(); } public T Create() { throw new NotImplementedException(); } public T Find(params object[] keyValues) { throw new NotImplementedException(); } public System.Collections.ObjectModel.ObservableCollection<T> Local { get { throw new NotImplementedException(); } } public T Remove(T entity) { this.list.Remove(entity); return entity; } #endregion #region IEnumerable<T> Members public IEnumerator<T> GetEnumerator() { return this.list.GetEnumerator(); } #endregion #region IEnumerable Members System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() { return this.list.GetEnumerator(); } #endregion #region IQueryable Members public Type ElementType { get { return this.list.AsQueryable().ElementType; } } public System.Linq.Expressions.Expression Expression { get { return this.list.AsQueryable().Expression; } } public IQueryProvider Provider { get { return this.list.AsQueryable().Provider; } } #endregion } } 另外一种方法是使用 Install-Package FakeDbSet 4 TDD 4.1 TDD基本流程 创建失败的测试 用最简单的方法实现 优化 4.2 创建测试 注意，测试应该也引用EF。","tags":"DotNet","url":"/aspnet-mvc5-xue-xi-bi-ji-5-ce-shi.html"},{"title":"ASP.NET MVC5 学习笔记-3 Model","text":"ASP.NET MVC5 学习笔记-3 Model 1. Model 1.1 添加一个模型 注意 ，添加属性时可以输入\"prop\"，会自动输入代码段。 public class CheckoutAccount { public int Id { get; set; } public string AccountNumber { get; set; } public string FirstName { get; set; } public string LastName { get; set; } public string Balance { get; set; } } 1.2 添加一个\"包含读写操作的MVC 5控制器\"CheckingAccountController 去掉Details的参数Id，因为现在我没还没有数据库。 public ActionResult Details() { return View(); } 1.3 在Details上添加视图 在Details动作上右键，添加视图： 视图名称 Details 模板 Details 模型 CheckoutAccount 数据上下文类：空 创建为分布视图：不勾选 引用脚本库：不勾选 使用布局页：默认布局 @model AspNetMVCEssential.Models.CheckoutAccount @{ ViewBag.Title = \"Details\"; } <h2> Details </h2> <div> <h4> CheckoutAccount </h4> <hr /> <dl class= \"dl-horizontal\" > <dt> @Html.DisplayNameFor(model => model.AccountNumber) </dt> <dd> @Html.DisplayFor(model => model.AccountNumber) </dd> <dt> @Html.DisplayNameFor(model => model.FirstName) </dt> <dd> @Html.DisplayFor(model => model.FirstName) </dd> <dt> @Html.DisplayNameFor(model => model.LastName) </dt> <dd> @Html.DisplayFor(model => model.LastName) </dd> <dt> @Html.DisplayNameFor(model => model.Balance) </dt> <dd> @Html.DisplayFor(model => model.Balance) </dd> </dl> </div> <p> @Html.ActionLink(\"Edit\", \"Edit\", new { id = Model.Id }) | @Html.ActionLink(\"Back to List\", \"Index\") </p> 说明： 第一行代码指明模板Model类型，任何@Model都是 CheckoutAccount 类型。 Html.DisplayNameFor(model => model.AccountNumber) 模型属性的名称 Html.DisplayFor(model => model.AccountNumber) 模型属性的值 1.4 添加首页到Details页面的链接 <div class= \"col-md-6 margin-top-20\" > <a href= \"@Url.Action(\" Details\", \"CheckingAccount\")\" class= \"btn btn-primary btn-lg btn-block\" ><span class= \"glyphicon glyphicon-question-sign\" ></span> 余额查询 </a> </div> @Url.Action(\"action\", \"controller\") 返回URL，而不是 <a> 2. 显示和验证模型属性 2.1 清理Details视图 @model AspNetMVCEssential.Models.CheckoutAccount @{ ViewBag.Title = \"Details\"; } <div class= \"row\" > <div class= \"col-md-6 col-md-offset-3\" > <h2> 账户查询 </h2> <dl class= \"dl-horizontal\" > <dt> @Html.DisplayNameFor(model => model.AccountNumber) </dt> <dd> @Html.DisplayFor(model => model.AccountNumber) </dd> <dt> @Html.DisplayNameFor(model => model.FirstName) </dt> <dd> @Html.DisplayFor(model => model.FirstName) </dd> <dt> @Html.DisplayNameFor(model => model.LastName) </dt> <dd> @Html.DisplayFor(model => model.LastName) </dd> <dt> @Html.DisplayNameFor(model => model.Balance) </dt> <dd> @Html.DisplayFor(model => model.Balance) </dd> </dl> </div> </div> 2.2 修改Model [Display(Name=\"Account\")] public class CheckoutAccount { public int Id { get; set; } [Display(Name = \"账户\")] public string AccountNumber { get; set; } public string FirstName { get; set; } public string LastName { get; set; } [Display(Name = \"姓名\")] public string Name { get { return FirstName + \" \" + LastName; } } [DataType(DataType.Currency)] public int Balance { get; set; } } 2.3 创建Create对应的视图 此时要选择引用脚本库。 @using (Html.BeginForm()) { @Html.AntiForgeryToken() <div class= \"form-horizontal\" > <h4> CheckoutAccount </h4> <hr /> @Html.ValidationSummary(true) <div class= \"form-group\" > @Html.LabelFor(model => model.AccountNumber, new { @class = \"control-label col-md-2\" }) <div class= \"col-md-10\" > @Html.EditorFor(model => model.AccountNumber) @Html.ValidationMessageFor(model => model.AccountNumber) </div> </div> ... } ``` - `@Html.LabelFor(model=>model.Account)`产生Label - `@Html.EditorFor(model=>model.Account)`产生input - `@Html.ValidationMessageFor(model=>model.AccountNumber)`验证信息 - `@Html.ValidationSummary(true)`验证汇总 ###2.4 修改CheckAccount [Required] //[StringLength(10, MinimumLength = 6)] [RegularExpression(@\"\\d{6,10}\", ErrorMessage = \"账户必须是6-10个字符\")] [Display(Name = \"账户\")] public string AccountNumber { get; set; } [Required] public string FirstName { get; set; } [Required] public string LastName { get; set; } [Display(Name = \"姓名\")] public string Name { get { return FirstName + \" \" + LastName; } } [Required] [DataType(DataType.Currency)] public int Balance { get; set; } 都是一些验证字段，注意每个都可以有`ErrorMessage`参数。 -- ##3. ViewModel ViewModel不在数据库中存储，专门用于处理Form，类似Django中的Form类。 ###3.1 ViewModel定义 打开Models文件夹下的AccountViewModel，我们看到ViewModel定义与普通Model并没有明显区别，只是命名约定都是以\"ViewModel\"结尾。 public class LoginViewModel [Required] [DataType(DataType.Password)] [Display(Name = \"密码\")] public string Password { get ; set; } [Display(Name = \"记住我?\")] public bool RememberMe { get ; set; } } ###3.2 ViewModel在Action中的应用 [HttpPost] [AllowAnonymous] [ValidateAntiForgeryToken] public async Task Login(LoginViewModel model, string returnUrl) { if (ModelState.IsValid) { var user = await UserManager.FindAsync(model.UserName, model.Password); if (user != null) { await SignInAsync(user, model.RememberMe); return RedirectToLocal(returnUrl); } else { ModelState.AddModelError(\"\", \"Invalid username or password.\"); } } // 如果我们进行到这一步时某个地方出错，则重新显示表单 return View(model); } 可以看到ViewModel只是接收用户的输入并封装，然后再使用封装的字段查找数据库中对应的Model。 ###3.3 ViewModel在视图中的应用 @model AspNetMVCEssential.Models.LoginViewModel @{ ViewBag.Title = \"登录\"; } @ViewBag.Title。 @using (Html.BeginForm(\"Login\", \"Account\", new { ReturnUrl = ViewBag.ReturnUrl }, FormMethod.Post, new { @class = \"form-horizontal\", role = \"form\" })) { @Html.AntiForgeryToken() 使用本地帐户登录。 @Html.ValidationSummary(true) @Html.LabelFor(m => m.UserName, new { @class = \"col-md-2 control-label\" }) @Html.TextBoxFor(m => m.UserName, new { @class = \"form-control\" }) @Html.ValidationMessageFor(m => m.UserName) ... } ... \u0002wzxhzdk:10\u0003 public class ApplicationDbContext : IdentityDbContext { public ApplicationDbContext() : base(\"DefaultConnection\") { } public DbSet CheckoutAccounts { get; set; } } \u0002wzxhzdk:11\u0003 public virtual ApplicationUser User { get; set; } public string ApplicationUserId { get; set; } \u0002wzxhzdk:12\u0003 [HttpPost] [AllowAnonymous] [ValidateAntiForgeryToken] public async Task Register(RegisterViewModel model) { if (ModelState.IsValid) { var user = new ApplicationUser() { UserName = model.Email, Email = model.Email}; var result = await UserManager.CreateAsync(user, model.Password); if (result.Succeeded) { //创建CheckoutAcount var db = new ApplicationDbContext(); var checkoutAccount = new CheckoutAccount { AccountNumber = \"00000123\", FirstName = model.FirstName, LastName = model.LastName, Balance = 0, ApplicationUserId = user.Id }; db.CheckoutAccounts.Add(checkoutAccount); db.SaveChanges(); await SignInAsync(user, isPersistent: false); return RedirectToAction(\"Index\", \"Home\"); } else { AddErrors(result); } } // 如果我们进行到这一步时某个地方出错，则重新显示表单 return View(model); } \u0002wzxhzdk:13\u0003 return View(model); \u0002wzxhzdk:14\u0003 @model MvcMovie.Models.Movie @{ ViewBag.Title = \"Details\"; } Details Movie @Html.DisplayNameFor(model => model.Title) @*Markup omitted for clarity.*@ @Html.ActionLink(\"Edit\", \"Edit\", new { id = Model.ID }) | @Html.ActionLink(\"Back to List\", \"Index\") \u0002wzxhzdk:15\u0003 @model IEnumerable @foreach (var item in Model) { @Html.DisplayFor(modelItem => item.Title) @Html.ActionLink(\"Edit\", \"Edit\", new { id=item.ID }) } \u0002wzxhzdk:16\u0003 [Required] [StringLength(10)] [Column(TypeName = \"varchar\")] [RegularExpression(@\"\\d{6,10}\", ErrorMessage = \"账户必须是6-10个字符\")] [Display(Name = \"账户\")] public string AccountNumber { get; set; } \u0002wzxhzdk:17\u0003 PM> Enable-Migrations -ContextType ApplicationDbContext 正在检查上下文的目标是否为现有数据库... 检测到使用数据库初始值设定项创建的数据库。已搭建与现有数据库对应的迁移\"201410311619291_InitialCreate\"的基架。若要改用自动迁移，请删除 Migrations 文件夹并重新运行指定了 -EnableAutomaticMigrations 参数的 Enable-Migrations。 已为项目 AspNetMVCEssential 启用 Code First 迁移。 \u0002wzxhzdk:18\u0003 PM> Add-Migration AccountNumberChanges 正在为迁移\"AccountNumberChanges\"搭建基架。 此迁移文件的设计器代码包含当前 Code First 模型的快照。在下一次搭建迁移基架时，将使用此快照计算对模型的更改。如果对要包含在此迁移中的模型进行其他更改，则您可通过再次运行\"Add-Migration AccountNumberChanges\"重新搭建基架。 \u0002wzxhzdk:19\u0003 PM> Update-Database -Script 正在应用显式迁移: [201410311643166_AccountNumberChanges]。 正在应用显式迁移: 201410311643166_AccountNumberChanges。 \u0002wzxhzdk:20\u0003 PM> Update-Database -Verbose Using StartUp project 'AspNetMVCEssential'. Using NuGet project 'AspNetMVCEssential'. 指定\"-Verbose\"标志以查看应用于目标数据库的 SQL 语句。 目标数据库为: \"aspnet-AspNetMVCEssential-20141031091551\"(DataSource: .，提供程序: System.Data.SqlClient，来源: Configuration)。 正在应用显式迁移: [201410311643166_AccountNumberChanges]。 正在应用显式迁移: 201410311643166_AccountNumberChanges。 ... 正在运行 Seed 方法。 \u0002wzxhzdk:21\u0003 PM> Update-Databse -TargetMigration IntialCreate \u0002wzxhzdk:22\u0003 internal sealed class Configuration : DbMigrationsConfiguration { public Configuration() { //设置自动迁移 AutomaticMigrationsEnabled = true; ContextKey = \"AspNetMVCEssential.Models.ApplicationDbContext\"; } //... } \u0002wzxhzdk:23\u0003 PM> Update-Database -Verbose Using StartUp project 'AspNetMVCEssential'. Using NuGet project 'AspNetMVCEssential'. 指定\"-Verbose\"标志以查看应用于目标数据库的 SQL 语句。 目标数据库为: \"aspnet-AspNetMVCEssential-20141031091551\"(DataSource: .，提供程序: System.Data.SqlClient，来源: Configuration)。 没有挂起的显式迁移。 正在应用自动迁移: 201410311656382_AutomaticMigration。 System.Data.Entity.Migrations.Infrastructure.AutomaticDataLossException: 未应用自动迁移，因为自动迁移会导致数据丢失。如果要在可能导致数据丢失的情况下允许应用自动迁移，请在 DbMigrationsConfiguration 上将 AutomaticMigrationDataLossAllowed 设置为 \"true\"。也可以将 Update-Database 与 \"-Force\" 选项一起使用，或者构建基架执行显式迁移。 在 System.Data.Entity.Migrations.DbMigrator.AutoMigrate(String migrationId, VersionedModel sourceModel, VersionedModel targetModel, Boolean downgrading) 。。。 在 System.Data.Entity.Migrations.MigrationsDomainCommand.Execute(Action command) 未应用自动迁移，因为自动迁移会导致数据丢失。如果要在可能导致数据丢失的情况下允许应用自动迁移，请在 DbMigrationsConfiguration 上将 AutomaticMigrationDataLossAllowed 设置为 \"true\"。也可以将 Update-Database 与 \"-Force\" 选项一起使用，或者构建基架执行显式迁移。 \u0002wzxhzdk:24\u0003 PM> Update-Database -Verbose -Force ```","tags":"DotNet","url":"/aspnet-mvc5-xue-xi-bi-ji-3-model.html"},{"title":"ASP.NET MVC5 学习笔记-4 OWIN和Katana","text":"ASP.NET MVC5 学习笔记-4 OWIN和Katana 1. Owin OWIN全名：Open Web Interface for .NET. 它是一个说明，而非一个框架，该声明用来实现Web服务器和框架的松耦合。它提供了模块化、轻量级和便携的设计。类似Node.js, WSGI. Katana是微软实现的OWIN组件的集合。包含基础设施组件和功能性组件。并且暴露出了OWIN管道用来添加组件。可以在IIS、OwinHost.exe或者自定义的服务器中托管。 比如OWIN提供了新的登录模式，比如，打开Web.config文件，我们看到： <system.web> <authentication mode= \"None\" /> <compilation debug= \"true\" targetFramework= \"4.5\" /> <httpRuntime targetFramework= \"4.5\" /> </system.web> 我们看到 <authentication mode=\"None\"/> ，这里我们不在使用传统的Form认证，而是使用Owin的认证。我们打开Startup.cs文件，看到如下内容： public partial class Startup { public void Configuration(IAppBuilder app) { ConfigureAuth(app); } } 这里我们使用 ConfigureAuth(app) 来配置认证，打开这个方法的定义，可以看到如下方法： public void ConfigureAuth ( IAppBuilder app ) { // 使应用程序可以使用 Cookie 来存储已登录用户的信息 app . UseCookieAuthentication ( new CookieAuthenticationOptions { AuthenticationType = DefaultAuthenticationTypes . ApplicationCookie , LoginPath = new PathString ( \"/Account/Login\" ) } ); // Use a cookie to temporarily store information about a user logging in with a third party login provider app .UseExternalSignInCookie ( DefaultAuthenticationTypes .ExternalCookie ); // 取消注释以下行可允许使用第三方登录提供程序登录 // app .UseMicrosoftAccountAuthentication ( // clientId : \"\" , // clientSecret : \"\" ); // app .UseTwitterAuthentication ( // consumerKey : \"\" , // consumerSecret : \"\" ); // app .UseFacebookAuthentication ( // appId : \"\" , // appSecret : \"\" ); // app .UseGoogleAuthentication (); } 2. 本地认证Local Authentication 默认就是本地认证： // 使应用程序可以使用 Cookie 来存储已登录用户的信息 app.UseCookieAuthentication(new CookieAuthenticationOptions { AuthenticationType = DefaultAuthenticationTypes.ApplicationCookie, LoginPath = new PathString(\"/Account/Login\") }); // Use a cookie to temporarily store information about a user logging in with a third party login provider app.UseExternalSignInCookie(DefaultAuthenticationTypes.ExternalCookie); 3. 添加Facebook认证 // 取消注释以下行可允许使用第三方登录提供程序登录 // app .UseMicrosoftAccountAuthentication ( // clientId : \"\" , // clientSecret : \"\" ); // app .UseTwitterAuthentication ( // consumerKey : \"\" , // consumerSecret : \"\" ); // app .UseFacebookAuthentication ( // appId : \"\" , // appSecret : \"\" ); // app .UseGoogleAuthentication (); 取消注释对应的行，并且添加appId和appSecret。 第二步，如果在创建账户后需要做一些其他的操作，修改AccountController.cs中的 ExternalLoginConfirmation 方法。 4. Identity身份 4.1 使用Claim添加自定义的字段 Identity 是第一个产生出来为每个用户识别身份的。 Account 的 Register 方法先生成创建一个 IdentityResult ，然后再使用 SignInAsync 。 Claim是一个关于用户的声明，由Identity provider提供，比如用户1有Admin角色。 Asp.Net生成的数据库中有 AspNetUsers ， AspNetUserRoles 和 AspNetUserClaims 表，其中 AspNetUserClaims 用来存储用户自定义的一些信息。 比如给用户在注册时添加一个名称： public async Task < ActionResult > Register ( RegisterViewModel model ) { if ( ModelState . IsValid ) { var user = new ApplicationUser () { UserName = model . Email , Email = model . Email } ; var result = await UserManager .CreateAsync ( user , model .Password ); if ( result .Succeeded ) { // 添加 Claims UserManager . AddClaim ( user . Id , new Claim ( ClaimTypes . GivenName , model . FirstName )); var service = new CheckingAccountService ( HttpContext . GetOwinContext () . Get < ApplicationDbContext > ()); service . CreateCheckingAccount ( model . FirstName , model . LastName , user . Id , 0 ); await SignInAsync ( user , isPersistent : false ); return RedirectToAction ( \"Index\" , \"Home\" ); } else { AddErrors ( result ); } } // 如果我们进行到这一步时某个地方出错 ， 则重新显示表单 return View ( model ); } 获取Claims var identity = (ClaimsIdentity) User.Identity; var name = identity.FindFirstValue(ClaimTypes.GivenName) ?? identity.GetUserName(); 4.2 在model中添加自定义的字段 打开 IdentityModels.cs ，在 ApplicationUser 中添加: public class ApplicationUser : IdentityUser { public async Task<ClaimsIdentity> GenerateUserIdentityAsync(UserManager<ApplicationUser> manager) { var userIdentity = await manager.CreateIdentityAsync(this, DefaultAuthenticationTypes.ApplicationCookie); return userIdentity; } public string Pin { get; set; } } 5 基于角色的认证 5.1 为每个用户添加余额显示 每个Controller都有一个User属性，获取当前UserId的方法如下： var userId = User.Identity.GetUserId(); 比如，我们要获取之前定义的账户余额，可以打开 CheckingAccountController.cs 中添加下面的代码 private ApplicationDbContext db = new ApplicationDbContext(); // // GET: /CheckingAccount/Details/ public ActionResult Details() { var userId = User.Identity.GetUserId(); var checkingAccount = db.CheckoutAccounts.First(c => c.ApplicationUserId == userId); return View(checkingAccount); } 这样每个用户就都能看到自己的账户余额了。 5.2 显示用户账户余额列表 在 CheckingAccountController.cs 中添加： public ActionResult List() { return View(db.CheckoutAccounts.ToList()); } 现在，我们为List添加视图，右键： 注意 ，如果按照上图配置发生错误，并且错误是\"运行所选代码生成器时出错\"，那么应该将数据上下文类留空，这样就可以了。 然后编辑生成的模板，将编辑改为： @Html.ActionLink(\"详细\", \"DetailsForAdmin\", new { id=item.Id }) | 并且，在 CheckingAccountController.cs 中添加： [Authorize(Roles = \"Admin\")] public ActionResult DetailsForAdmin(int id) { var checkingAccount = db.CheckoutAccounts.First(c => c.Id == id); return View(\"Details\", checkingAccount); } 请注意，我们添加了 [Authorize(Roles=\"Admin\")] 来限定只有Admin组的才能访问，下一节我们讲介绍如何使用角色分配。 6 给用户赋值角色 打开 Migrations\\Configurations ，在 Seed 方法中添加如下： protected override void Seed(AspNetMVCEssential.Models.ApplicationDbContext context) { //UserStore一定要使用context作为参数 var userStore = new UserStore<ApplicationUser>(context); var userManager = new UserManager<ApplicationUser>(userStore); if (!context.Users.Any(u => u.UserName == \"liulixiang1988\")) { //1、创建用户 var user = new ApplicationUser { UserName = \"liulixiang1988\", Email = \"liulixiang1988@gmail.com\" }; //下面这句会创建一个用户并且会立即执行，不需调用SaveChanges userManager.Create(user, \"passW0rd\"); //2、创建用户相关的账户 var service = new CheckingAccountService(context); service.CreateCheckingAccount(\"liulixiang1988\", \"管理员\", user.Id, 1000); //3、添加角色并保存 context.Roles.AddOrUpdate(r => r.Name, new IdentityRole { Name = \"Admin\" }); context.SaveChanges(); //4、给用户添加角色，指定Id和角色名 userManager.AddToRole(user.Id, \"Admin\"); } }","tags":"DotNet","url":"/aspnet-mvc5-xue-xi-bi-ji-4-owinhe-katana.html"},{"title":"ASP.NET MVC5 学习笔记-1 控制器、路由、返回类型、选择器、过滤器","text":"ASP.NET MVC5 学习笔记-1 控制器、路由、返回类型、选择器、过滤器 1. Action 1.1 新建项目 新建项目->Web->Asp.net Web应用程序，选择MVC，选择添加测试。 在解决方案上右键，选择\"管理NuGet程序包\"，在更新页更新全部程序包。 1.2 控制器 控制器在Controllers文件夹内，命名规则是\"名称+Controller\" 2. 路由 2.1 路由规则 {controller}/{action}/{id} 其中{id}是可选的。 2.2 路由定义RouteConfig.cs public class RouteConfig { public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Home\", action = \"Index\", id = UrlParameter.Optional } ); } } 我们自定义一个路由： public static void RegisterRoutes(RouteCollection routes) { routes.IgnoreRoute(\"{resource}.axd/{*pathInfo}\"); routes.MapRoute( name: \"Serial Number\", url: \"serial/{lettercase}\", defaults: new { controller = \"Home\", action = \"Serial\", lettercase=\"upper\" } ); routes.MapRoute( name: \"Default\", url: \"{controller}/{action}/{id}\", defaults: new { controller = \"Home\", action = \"Index\", id = UrlParameter.Optional } ); } 它定义了一个路由，路由名称为\"Serial Number\", url以\"serial\"开头，含有一个lettercase参数，使用HomeController.Serial来处理，lettercase默认值为\"upper\". 现在在HomeController.cs中定义： public ActionResult Serial(string lettercase) { var serial = \"ASP.NET mvc5\"; if (lettercase == \"lower\") { serial = serial.ToLower(); } return Content(serial); } 此时访问：http://localhost:17681/serial/ 或者 http://localhost:17681/serial/lower 都可以。 如果路由中没有包含{lettercase}，则可以使用querystring方式传递lettercase: http://localhost:17681/serial/?lettercase=lower: routes.MapRoute( name: \"Serial Number\", url: \"serial\", defaults: new { controller = \"Home\", action = \"Serial\" } ); vs快捷键：F5运行调试； ctrl+F5：运行但不调试，此时运行时可以修改代码；ctrl+shift+b：编译代码，可以在运行时重新加载而无需重启。 3 返回类型 内建Action Result类型： ViewResult：渲染返回完整的网页 PartialViewResult:渲染返回网页的一部分，用于Ajax比较多； ContentResult: 返回用户自定义的内容（text,xml)等； JsonResult: 返回Json类型 RedirectToRouteResult:重定向 3.1 PartialViewResult的例子 public ActionResult Index() { return PartialView(); } 3.2 JsonResult的例子 public ActionResult Serial(string lettercase) { var serial = \"ASP.NET mvc5\"; if (lettercase == \"lower\") { serial = serial.ToLower(); } //return Content(serial); return Json(new {name = \"serial\", value = serial}, JsonRequestBehavior.AllowGet); } 3.3 RedirectToRouteResult的例子 public ActionResult Serial(string lettercase) { var serial = \"ASP.NET mvc5\"; if (lettercase == \"lower\") { serial = serial.ToLower(); } return RedirectToAction(\"Index\"); } 4 Action Selector 4.1 HttpPost public ActionResult Contact() { ViewBag.TheMessage = \"有问题的话请留言哦~\"; return View(); } [HttpPost] public ActionResult Contact(string message) { ViewBag.TheMessage = \"感谢你的留言~\"; return View(); } 对应的视图 <form method= \"POST\" > <input type= \"text\" name= \"message\" /> <input type= \"submit\" /> </form> 4.1.1 防止CSRF，使用 ValidateAntiForgeryToken ： [HttpPost] [ValidateAntiForgeryToken] public ActionResult Create([Bind(Include = \"ID,Title,ReleaseDate,Genre,Price\")] Movie movie) { if (ModelState.IsValid) { db.Movies.Add(movie) ; db.SaveChanges() ; return RedirectToAction(\"Index\") ; } return View(movie) ; } 对应的视图使用 @Html.AntiForgeryToken ： @using (Html.BeginForm()) { @Html.AntiForgeryToken() <div class= \"form-horizontal\" > <h4> Movie </h4> <hr /> @Html.ValidationSummary(true, \"\", new { @class = \"text-danger\" }) <div class= \"form-group\" > @Html.LabelFor(model => model.Title, htmlAttributes: new { @class = \"control-label col-md-2\" }) <div class= \"col-md-10\" > @Html.EditorFor(model => model.Title, new { htmlAttributes = new { @class = \"form-control\" } }) @Html.ValidationMessageFor(model => model.Title, \"\", new { @class = \"text-danger\" }) </div> </div> 4.1.2 验证Post请求 ModelState.IsValid 使用 ModelState.IsValid 来验证发送来的模型是否正常。 [HttpPost] [ValidateAntiForgeryToken] public ActionResult Edit([Bind(Include = \"ID,Title,ReleaseDate,Genre,Price\")] Movie movie) { if (ModelState.IsValid) { db.Entry(movie).State = EntityState.Modified; db.SaveChanges(); return RedirectToAction(\"Index\"); } return View(movie); } 4.2 ActionName [ActionName(\"about-the-site\")] public ActionResult About() { ViewBag.Message = \"Your application description page.\"; return View(\"About\") ; } 此时访问地址就是http://localhost:17681/Home/about-the-site 4.3 Route [Route(\"home/create\")] public ActionResult Create() { } 5. 过滤器 常见的过滤器 5.1 Authorize属性 [Authorize(Roles=\"administrator\", Users=\"liulx\")] [HttpPost] public ActionResult Create(Customer customer) { db.Customers.Add(customer) ; db.SaveChanges() ; return RedirectToAction(\"Index\") ; } Authorize 可以不带参数，修饰class，如果class是 Authorize 修饰的，那么可以用[AllowAnonymous]修饰对应的方法允许匿名访问。 5.2 Action filter 创建自定义的Action Filter： 继承 ActionFilterAttribute 类 重写 OnActionExecuting 方法，该方法在Action之前执行 重写 OnActionExecuted 方法，该方法在Action之后执行 public class MyLoggingFilterAttribute : ActionFilterAttribute { public override void OnActionExecuted(ActionExecutedContext filterContext) { var request = filterContext.HttpContext.Request; // Logger.logRequest(request.UserHostAddress); base.OnActionExecuted(filterContext); } } 调用 [MyLoggingFilter] public ActionResult Index() { // throw new StackOverflowException() ; return View() ; } 要想在全局应用自定义的Filter，可以这样： public class FilterConfig { public static void RegisterGlobalFilters(GlobalFilterCollection filters) { //添加自定义Filter filters.Add(new MyLoggingFilterAttribute()); filters.Add(new HandleErrorAttribute()); } } 5.3 Result Filter [OutputCache(Duration=1800)] public ActionResult Index() { // throw new StackOverflowException() ; return View() ; } [OutputCache(Duration=1800, VaryByParam=\"id\")] public ActionResult Details(int id) { Product p = db.Products.Find(id); return View(p); } 5.4 Exception Filter [HandleError(View=\"MyError\")] public ActionResult Index() { // throw new StackOverflowException() ; return View() ; } [HandleError(View=\"MyError2\", ExceptionType=typeof(DivideByZeroException))] public ActionResult Details(int id) { Product p = db.Products.Find(id); return View(p); }","tags":"DotNet","url":"/aspnet-mvc5-xue-xi-bi-ji-1-kong-zhi-qi-lu-you-fan-hui-lei-xing-xuan-ze-qi-guo-lu-qi.html"},{"title":"ASP.NET MVC5 学习笔记-2 Razor","text":"ASP.NET MVC5 学习笔记-2 Razor 1. Razor @*注释*@ 你在用 @Request.Browser.Browser, 发送邮件给support@qq.com, 转义@@qq @{ var amounts = new List <Decimal> {100, 25.00m, 30.0m, -40}; } <ul> @foreach (decimal amount in amounts) { <li> @formatAmount(amount) </li> <text> 普通文本 </text> @:普通文本 } </ul> @helper formatAmount(decimal amount) { var color = \"green\"; if (amount < 0 ) { color = \"red\" ; } <span style= \"color:@color\" > @String.Format(\"{0:c}\", amount) </span> } 2. Layout 2.1 模板继承 Views 文件夹下 _ViewStart.cshtml 定义了全局的Layout： @{ Layout = \"~/Views/Shared/_Layout.cshtml\"; } 如果给某个控制器指定特定的layout，就是在这个控制器对应的文件夹下再建一个 _ViewStart.cshmtl ，里面内容与上面相同。 如果想给某个特定Action指定layout，可以这样： @{ ViewBag.Title = \"Home Page\"; Layout = \"MyLayout.cshtml\"; } 2.2 layout定义 <div class= \"container body-content\" > @RenderBody() <hr /> <footer> <p> &copy; @DateTime.Now.Year - 我的 ASP.NET 应用程序 </p> </footer> </div> @Scripts.Render(\"~/bundles/jquery\") @Scripts.Render(\"~/bundles/bootstrap\") @RenderSection(\"scripts\", required: false) RenderBody()就是默认全部。RenderSection()在子模板中可以省略，但定义如下： ```@section scripts ##3. Html Helpers ###3.1 Html.ActionLink @Html.ActionLink(\"连接名\", \"Action\", \"Controller\", new {paramter=\"\"}, new ) @Html.ActionLink(\"连接名\", \"Action\", \"Controller\") ###3.2 Html.Partial 包含部分模板 @Html.Partial(\"_LoginPartial\") ###3.3 Html.BeginForm `Html.BeginForm(\"action\", \"form\", Method, css)` using (Html.BeginForm(\"LogOff\", \"Account\", FormMethod.Post, new { id = \"logoutForm\", @class = \"navbar-right\" })) { //注意着一行，防止CSRF @Html.AntiForgeryToken() @Html.ActionLink(\"你好 \" + User.Identity.GetUserName() + \"!\", \"Manage\", \"Account\", routeValues: null, htmlAttributes: new { title = \"管理\" }) 注销 } 如果使用了```@Html.AntiForgeryToken()```，则对应的Action应该添加`ValidateAntiForgeryToken` [HttpPost] [ValidateAntiForgeryToken] public ActionResult LogOff() ###3.4 Html.Action 输出Action的结果作为页面的一部分 © @DateTime.Now.Year - 我的 ASP.NET 应用程序 @Html.Action(\"Serial\", \"Home\", new{lettercase=\"lower\"}) ###3.5 下拉框 代码 public ActionResult Index(string movieGenre, string searchString) { var GenreLst = new List (); var GenreQry = from d in db.Movies orderby d.Genre select d.Genre; GenreLst.AddRange(GenreQry.Distinct()); ViewBag.movieGenre = new SelectList(GenreLst); ... } 对应的视图 \">@using (Html.BeginForm(\"Index\", \"Movies\", FormMethod.Get)) 使用`Html.DropDownList`和`Html.TextBox`等中绑定的名称和ViewBag中的值相同时可以自动绑定。 ##4. Bundling和Minification @Styles.Render(\"~/Content/css\") @Scripts.Render(\"~/bundles/modernizr\") @Scripts.Render(\"~/bundles/jquery\") @Scripts.Render(\"~/bundles/bootstrap\") public class BundleConfig { // 有关绑定的详细信息，请访问 http://go.microsoft.com/fwlink/?LinkId=301862 public static void RegisterBundles(BundleCollection bundles) { bundles.Add(new ScriptBundle(\"~/bundles/jquery\").Include( \"~/Scripts/jquery-{version}.js\")); bundles.Add(new ScriptBundle(\"~/bundles/jqueryval\").Include( \"~/Scripts/jquery.validate*\")); // 使用要用于开发和学习的 Modernizr 的开发版本。然后，当你做好 // 生产准备时，请使用 http://modernizr.com 上的生成工具来仅选择所需的测试。 bundles.Add(new ScriptBundle(\"~/bundles/modernizr\").Include( \"~/Scripts/modernizr-*\")); bundles.Add(new ScriptBundle(\"~/bundles/bootstrap\").Include( \"~/Scripts/bootstrap.js\", \"~/Scripts/respond.js\")); bundles.Add(new StyleBundle(\"~/Content/css\").Include( \"~/Content/bootstrap.css\", \"~/Content/site.css\")); //压缩 BundleTable.EnableOptimizations = true; } } ``` 5. Bootstrap ASP.NET MVC 5默认支持BootStrap","tags":"DotNet","url":"/aspnet-mvc5-xue-xi-bi-ji-2-razor.html"},{"title":"[翻译]使用ASP.NET Web API 2、Owin和Identity来创建Token认证(1)","text":"使用ASP.NET Web API 2、Owin和Identity来创建Token认证(1) 0. 简介 0.1 Token认证 0.2 Web API 1. 创建后端API 1.1 第一步 创建Web API项目 使用VS2013，创建\"ASP.NET Web应用程序\"，解决方案名为AngularJSAuthentication，项目名为AngularJSAuthentication.API: 1.2 第二步 安装必要的NuGet包 Install-Package Microsoft.AspNet.WebApi.Owin -Version 5.1.2 Install-Package Microsoft.Owin.Host.SystemWeb -Version 2.1.0 其中， Microsoft.Owin.Host.SystemWeb 包是用来Owin服务器的API能够在IIS上运行 1.3 第三步 添加Owin\"启动(Startup)\"类 右键，添加新类 Startup ，我们会修改好几次这个类，现在它应该是这个样子： using System.Web.Http; using AngularJSAuthentication.API; using Microsoft.Owin; using Owin; [assembly: OwinStartup(typeof (Startup))] namespace AngularJSAuthentication.API { public class Startup { public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); WebApiConfig.Register(config); app.UseWebApi(config); } } } assembly 属性声明了启动时启动的类，也就是说 Startup 类在应用启动的时候会被调用。 Configuration 方法接收的参数 IAppBuilder 实例app是主机传过来的。 app 是一个接口，用来组成我们服务器的应用。 HttpConfiguration 对象用来配置路由，因此，我们把它传递给 WebApiConfig 类的 Register 方法。 最后，我们把 config 对象传递给 UserWebApi 扩展方法，实现ASP.NET Web API和Owin Server的管道。 通常， WebApiConfig 由模板自动生成。如果没有，就在 App_Start 文件夹下创建： public static class WebApiConfig { public static void Register(HttpConfiguration config) { // Web API routes config.MapHttpAttributeRoutes(); config.Routes.MapHttpRoute( name: \"DefaultApi\", routeTemplate: \"api/{controller}/{id}\", defaults: new { id = RouteParameter.Optional } ); var jsonFormatter = config.Formatters.OfType<JsonMediaTypeFormatter>().First(); jsonFormatter.SerializerSettings.ContractResolver = new CamelCasePropertyNamesContractResolver(); } } 1.4 第四步 删除Global.asax类 不再需要这个类，也不需要 Application_Start 事件，因为我们已经配置了 Startup 类，所以放心删除它吧。 1.5 第五步 添加Windows Identity System(Windows身份认证系统) 配置过Web API后，现在可以添加支持注册和验证用户的包了，安装如下包 Install-Package Microsoft.AspNet.Identity.Owin -Version 2.0.1 Install-Package Microsoft.AspNet.Identity.EntityFramework -Version 2.0.1 第一个包用来支持ASP.NET Identity Owin，第二个包可以让ASP.NET Identity使用Entity Framework,这样我们就能保存用户到SQL Server数据库了。 现在我们需要添加一个Database context类，用来负责与数据库交互。因此，添加 AuthContext 类： public class AuthContext: IdentityDbContext<IdentityUser> { public AuthContext(): base(\"AuthContext\") { } } 能看到这个类继承自 IdentityDbContext 类。可以把这个特殊类型的 DbContext 类。它支持所有Entity Framework的code-first映射，以及DbSet属性用来管理数据库的身份表。可以读 Scott Allen的博客 了解更多。 现在，我们在 Models 文件夹下添加一个 UserModel 类，它包含一些用来验证注册请求。 using System.ComponentModel.DataAnnotations; namespace AngularJSAuthentication.API.Models { public class UserModel { [Required] [Display(Name = \"用户名\")] public string UserName { get; set; } [Required] [StringLength(100, ErrorMessage = \"{0}至少要有{2}个字符\", MinimumLength = 6)] [DataType(DataType.Password)] [Display(Name = \"密码\")] public string Password { get; set; } [DataType(DataType.Password)] [Display(Name = \"确认密码\")] [Compare(\"Password\", ErrorMessage = \"两次密码输入不一致\")] public string ConfirmedPassword { get; set; } } } 最后，我们在web.config中添加连接字符串： <connectionStrings> <add name= \"AuthContext\" connectionString= \"Data Source=.;Initial Catalog=AngularJSAuth;Integrated Security=SSPI;\" providerName= \"System.Data.SqlClient\" /> </connectionStrings> 1.6 第六步 添加仓库类来支持ASP.NET Identity System 现在，我们要实现两个方法 RegisterUser 和 FindUser ，因此，我们添加一个名为 AuthRepository 的类： public class AuthRepository : IDisposable { private readonly AuthContext _ctx; private readonly UserManager<IdentityUser> _userManager; public AuthRepository() { _ctx = new AuthContext(); _userManager = new UserManager<IdentityUser>(new UserStore<IdentityUser>(_ctx)); } public void Dispose() { _ctx.Dispose(); _userManager.Dispose(); } public async Task<IdentityResult> RegisterUser(UserModel userModel) { var user = new IdentityUser { UserName = userModel.UserName }; IdentityResult result = await _userManager.CreateAsync(user, userModel.Password); return result; } public async Task<IdentityUser> FindUser(string username, string password) { IdentityUser user = await _userManager.FindAsync(username, password); return user; } } 我们依赖 UserManager 来提供用户信息的逻辑操作。 UserManager 指导什么时候hash密码，怎么以及何时验证用户，以及如何管理请求。读 ASP.NET Identity System 来了解更多。 1.7 第七步 添加我们的\"账户\"控制器(\"Account\" Controller) 现在是时候添加我们的第一个Web API控制器了，这个控制器用来注册新用户。在 Controllers 文件夹下添加一个空Web API 2的控制器 AccountController ： [RoutePrefix(\"api/account\")] public class AccountController : ApiController { private AuthRepository _repo = null; public AccountController() { _repo = new AuthRepository(); } //POST /api/Acount/Register [AllowAnonymous] [Route(\"Register\")] public async Task<IHttpActionResult> Register(UserModel userModel) { if (!ModelState.IsValid) { return BadRequest(ModelState) ; } IdentityResult result = await _repo.RegisterUser(userModel); IHttpActionResult errorResult = GetErrorResult(result); if (errorResult != null) { return errorResult; } return Ok() ; } protected override void Dispose(bool disposing) { if (disposing) { _repo.Dispose() ; } base.Dispose(disposing) ; } private IHttpActionResult GetErrorResult(IdentityResult result) { if (result = = null) { return InternalServerError(); } if (!result.Succeeded) { if (result.Errors ! = null) { foreach (var error in result.Errors) { ModelState.AddModelError(\"\", error); } } if (ModelState.IsValid) { return BadRequest() ; } return BadRequest(ModelState) ; } return null ; } } 任何人想要注册，必须使用HTTP POST请求'/api/account/register'，而且请求必须包含如下的JSON对象： { \"userName\": \"liu\", \"password\": \"123456\", \"confirmPassword\": \"123456\" } 现在可以使用HTTP POST请求网址：\"http://localhost:port/api/account/register\"，如果一切正常就会收到HTTP状态码200，而且数据库会自动在表 dbo.AspNetUsers 中创建一个用户。 注意： 通过HTTPS发送POST请求非常重要，因为敏感信息会被加密。 GetErrorResult 方法是一个帮助方法用来验证 UserModel ，并且返回相应的HTTP状态码。 1.8 第八步 添加具有安全保护的\"订单\"控制器(Order Controller) 现在我们想要添加控制器来处理我们的订单，我们设定这个控制器为认证用户返回订单，为了保持简单我们返回静态数据。因此在 Controllers 下添加一个 OrdersController ： [RoutePrefix(\"api/Orders\")] public class OrdersController : ApiController { // GET api/<controller> [Authorize] [Route(\"\")] public IHttpActionResult Get() { return Ok(Order.CreateOrders()) ; } #region Helpers public class Order { public int OrderID { get ; set; } public string CustomerName { get ; set; } public string ShipperCity { get ; set; } public Boolean IsShipped { get ; set; } public static List<Order> CreateOrders() { var OrderList = new List<Order> { new Order {OrderID = 10248, CustomerName = \"Taiseer Joudeh\", ShipperCity = \"Amman\", IsShipped = true }, new Order {OrderID = 10249, CustomerName = \"Ahmad Hasan\", ShipperCity = \"Dubai\", IsShipped = false}, new Order {OrderID = 10250,CustomerName = \"Tamer Yaser\", ShipperCity = \"Jeddah\", IsShipped = false }, new Order {OrderID = 10251,CustomerName = \"Lina Majed\", ShipperCity = \"Abu Dhabi\", IsShipped = false}, new Order {OrderID = 10252,CustomerName = \"Yasmeen Rami\", ShipperCity = \"Kuwait\", IsShipped = true} }; return OrderList ; } } #endregion } 注意我们在 Get 上加了一个 Authorize 属性，此时，如果访问 \"http://localhost:port/api/orders\"就会收到401未授权状态码。因为我们的请求当中并没有包含授权头信息。 1.9 第九步 添加支持OAuth Token生成功能 现在我们该让API增加OAuth功能 Install-Package Microsoft.Owin.Security.OAuth -Version 2.1.0 打开 Startup 类，添加 ConfigureOAuth 方法，并在 Configuration 方法的第一行调用它： public class Startup { public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); WebApiConfig.Register(config); app.UseWebApi(config); } public void ConfigreOAuth(IAppBuilder app) { var oauthServerOptions = new OAuthAuthorizationServerOptions { AllowInsecureHttp = true, TokenEndpointPath = new PathString(\"/token\"), AccessTokenExpireTimeSpan = TimeSpan.FromDays(1), Provider = new SimpleAuthorizationServerProvider() }; app.UseOAuthAuthorizationServer(oauthServerOptions); app.UseOAuthBearerAuthentication(new OAuthBearerAuthenticationOptions()); } } 我们创建了一个 OAuthAuthorizationServerOptions 类的实例，并且设置了如下的一些选项： 产生令牌的路径 http://localhost:port/token 。后面我们会看到如何使用HTTP POST请求产生令牌 令牌24小时过期 我们指明如何验证用户的凭据，来返回令牌，就是使用后面我们要定义的一个类 SimpleAuthorizationServerProvider 然后将选项实例传递给扩展方法 UseOAuthAuthorizationServer ，这样我们就将认证中间件添加到了管道当中去了。 1.10 第十步 实现\"SimpleAuthorizationServerProvider\"类 创建一个 Providers 文件夹，然后添加一个 SimpleAuthorizationServerProvider 类： public class SimpleAuthorizationServerProvider: OAuthAuthorizationServerProvider { public override async Task ValidateClientAuthentication(OAuthValidateClientAuthenticationContext context) { context.Validated(); } public override async Task GrantResourceOwnerCredentials(OAuthGrantResourceOwnerCredentialsContext context) { context.OwinContext.Response.Headers.Add(\"Access-Control-Allow-Origin\", new []{\"*\"}); using (var _repo = new AuthRepository()) { IdentityUser user = await _repo.FindUser(context.UserName, context.Password); if (user == null) { context.SetError(\"invalid_grant\", \"用户名或者密码不正确\"); return; } var identity = new ClaimsIdentity(context.Options.AuthenticationType); identity.AddClaim(new Claim(\"sub\", context.UserName)); identity.AddClaim(new Claim(\"role\", \"user\")); context.Validated(identity); } } } 该类继承自 OAuthAuthorizationServerProvider ，我们重写了两个方法，第一个是用来验证客户端的。本例中我们只有一个客户端，因此永远验证成功。 第二个方法 GrantResourceOwnerCredentials 负责验证发送给认证服务器令牌端的用户名和密码。 如果认证成功，我们创建一个 ClaimsIdentity 类，并且传递认证类型给它。然后添加两个请求( sub 和 role )，他们会被包含在签名令牌中。也可以添加别的,但是会增加令牌的大小。 最后使用 context.Validate(identity) 生成令牌。 为了让令牌中间件提供者允许CORS，我们需要添加头\"Access-Control-Allow-Origin\"到Owin的上下文中。如果忘记这么做，从浏览器中调用生成令牌就会失败。 1.11 第十一步 允许ASP.NET Web API支持CORS 首先，需要安装对应的NuGet包： Install-Package Microsoft.Owin.Cors 然后再次打开类 Startup ，并添加 public void Configuration(IAppBuilder app) { var config = new HttpConfiguration(); ConfigreOAuth(app); WebApiConfig.Register(config); //添加这行 app.UseCors(CorsOptions.AllowAll); app.UseWebApi(config); } 1.12 第十二步 测试后端API 注意，content-type和payload type都是\"x-www-form-urlencoded\"类型，因此payload body将是form(grant_type=password&username=\"liulx\"&password=\"123456\")。如果一切正常我们会在响应中收到一个签名令牌。 \"grant_type\"指明授权类型，此处是密码。 现在既然有了token，我们就可以访问安全数据/api/Orders了：","tags":"DotNet","url":"/fan-yi-shi-yong-aspnet-web-api-2-owinhe-identitylai-chuang-jian-tokenren-zheng-1.html"},{"title":"Flask笔记－01 基本应用框架","text":"1. 初始化 from flask import Flask app = Flask ( __name__ ) __name__ 的作用是用来给Flask来判断应用的根路径的。 2. 路由和视图函数 @app.route ( '/' ) def hello_world (): return 'Hello World!' 如果要给路由添加参数，可以这样: 其中 <name> 就是参数，如果你想给参数加上类型，可以使用 /user/<int:id> ，Flask支持在路由中使用 int , float 和 path 等类型。 path 是字符串，但是并不把 / 当作分隔符，而是把它看作动态组成的一部分。 3. 启动服务器 Flask包含了一个小型的开发服务器，启动它： if __name__ == '__main__' : app . run ( debug = True ) 其中 debug=True 用来开启debug模式。正式环境中不需要。 4. 一个完整的应用 上面我们分别介绍了一部分，现在看看一个整体应用，保存到文件hello.py中： from flask import Flask app = Flask ( __name__ ) @app.route ( '/' ) def hello_world (): return 'Hello World!' if __name__ == '__main__' : app . run ( debug = True ) 启动应用： $ python hello.py * Running on http://127.0.0.1:5000/ * Restarting with reloader 5. 请求响应循环 5.1 应用和请求上下文 Flask使用 上下文Context 的概念来让一些对象暂时性的全局可访问。因为有了上下文，所以可以这样写： from flask import request @app.route ( '/browser' ) def browser (): user_agent = request . headers . get ( 'User-Agent' ) return '<p>你的浏览器是： %s ' % user_agent 注意 request 是如何被使用的。考虑到并发型，我们知道 request 不能是全局性的变量，所以每个线程都需要一个不同的 request 对象。上下文帮助我们实现了一些变量能在一个线程内全局访问。 Flask有两种上下文， 应用上下文 和 请求上下文 ，如下表所示: 变量名称 上下文 描述 current_app 应用上下文 活动应用的实例对象 g 应用上下文 一个对象，应用可以用它在处理请求的过程中来进行暂时存储。每次请求都会被重置。 request 应用上下文 请求对象 session 请求上下文 用户会话，一个用来在请求之间存储数据的字典。 Flask在分发请求之前激活（或者叫 推送 ）应用和请求上下文，并在处理请求后移除它们。当推送应用上下文时， current_app 和 g 可用，否则会抛出异常。 request 和 session 也是如此。 下面展示了应用上下文如何工作的。 >>> from hello import app >>> from flask import current_app >>> current_app . name Traceback ( most recent call last ): ... RuntimeError : working outside of application context >>> app_ctx = app . app_context () >>> app_ctx . push () >>> current_app . name 'hello' >>> app_ctx . pop () 注意，使用 app.app_context() 来获得应用上下文。 5.2 请求分发 Flask使用 URL映射 来进行请求分发。创建映射可以使用 app.route() 装饰器或者 app.add_url_rule() 。 要查看Flask应用中的URL映射，可以这样 >>> from flask_web_dev import app >>> app . url_map Map ([ < Rule '/' ( GET , HEAD , OPTIONS ) -> hello_world > , < Rule '/static/<filename>' ( GET , HEAD , OPTIONS ) -> static > , < Rule '/user/<name>' ( GET , HEAD , OPTIONS ) -> user > ]) 其中 GET, HEAD, OPTIONS 时方法。 /static/<filename> 是Flask用来做静态文件映射的特殊方法。 5.3 请求勾子 有时需要在请求执行前和执行后运行一些代码，比如应用启动时创建数据库连接，或者验证发出请求的用户。我们可以使用请求勾子： before_first_request ：注册一个在第一个请求前被运行的方法 before_request : 注册一个在每个请求前运行的方法 after_request : 注册一个在请求后执行的方法，但是当请求发出异常时不执行 teardown_request : 注册一个在请求后执行的方法，即使请求发出异常后仍然执行 一种常见的模式是用全局变量 g 在请求勾子方法和视图方法之间共享数据，比如， before_request 处理方法用来从数据库中加载用户，并且存储到 g.user 中。在视图方法中可以使用它。 5.4 响应 Flask期望视图函数返回一个值作为响应给请求。 如果希望返回状态码： @app.route ( '/' ) def hello_world (): return 'Hello World!' , 400 Flask的视图函数除了返回tuple之外还可以直接返回 Response 对象。使用 make_response 可以创建 Response 对象。你可以在这个 Response 对象的基础上再进行配置。 from flask import make_response @app.route ( '/' ) def index (): response = make_response ( '<h1>This document carries a cookie!</h1>' ) response . set_cookie ( 'answer' , '42' ) return response 还有一个特殊的响应类型叫做 重定向 。它返回一个url给浏览器用来进行跳转，状态码302, url放在返回头的 Location 中。Flask提供了 redirect 方法用来重定向： @app.route ( '/redirect_demo' ) def redirect_demo (): return redirect ( 'http://www.baidu.com' ) 另外一个特殊的响应是使用 abort 来处理错误的，不需返回，而是通过引发异常来将控制权转让给web服务器： from flask import abort @app.route ( '/abort_demo/<int:id>' ) def abort_demo ( id ): if id != 2 : abort ( 404 ) return '<h1>user id is %s ' % id 6. Flask扩展 Flask被设计的易于扩展，它有意避开了一些重要领域比如用户认证和数据库，留给用户来自由实现。可以使用扩展或者python包来实现不同的想法。 下面将使用 Flask-Script 来使flask应用可以接受命令行参数。 6.1 使用Flask-Script来实现命令行参数。 Flask本身实现了一些可配置项，但要在 app.run() 中指定，这不方便。Flask-Script就是添加命令行解析用的。 pip install flask-script from flask.ext.script import Manager manager = Manager ( app ) if __name__ == '__main__' : manager . run () Flask的扩展都在 flask.ext 包下。flask-script中的 Manager 接受Flask的实例对象，这也是Flask扩展的常用方法。 此时，再运行程序，就会有这样的结果： $ python flask_web_dev.py usage: flask_web_dev.py [ -? ] { runserver,shell } ... positional arguments: { runserver,shell } runserver Runs the Flask development server i.e. app.run () shell Runs a Python shell inside Flask application context. optional arguments: -?, --help show this help message and exit shell 参数用来再当前应用上下文下启动python，可以用来做测试时使用。 runserver 可以使用debug模式启动服务器，但还有更多用法 python flask_web_dev.py runserver -? $ python flask_web_dev.py runserver -? usage: flask_web_dev.py runserver [ -? ] [ -h HOST ] [ -p PORT ] [ --threaded ] [ --processes PROCESSES ] [ --passthrough-errors ] [ -d ] [ -D ] [ -r ] [ -R ] Runs the Flask development server i.e. app.run () optional arguments: -?, --help show this help message and exit -h HOST, --host HOST -p PORT, --port PORT --threaded --processes PROCESSES --passthrough-errors -d, --debug enable the Werkzeug debugger ( DO NOT use in production code ) -D, --no-debug disable the Werkzeug debugger -r, --reload monitor Python files for changes ( not 100 { 'type' : None, 'prog' : 'flask_web_dev.py runserver' , 'required' : False, 'const' : True, 'default' : None, 'container' : <argparse._ArgumentGroup object at 0x102aaef28>, 'help' : 'monitor Python files for changes (not 100% safe for production use)' , 'dest' : 'use_reloader' , 'choices' : None, 'option_strings' : [ '-r' , '--reload' ] , 'metavar' : None, 'nargs' : 0 } afe for production use ) -R, --no-reload do not monitor Python files for changes --host 很有用，它可以用来指定地址。默认情况下Flask使用 localhost ，但是可以这样指定： $ python flask_web_dev.py runserver --host 0.0.0.0 * Running on http://0.0.0.0:5000/ 下一章我们将介绍模板。","tags":"Python","url":"/flaskbi-ji-01-ji-ben-ying-yong-kuang-jia.html"},{"title":"使用Android开发一个阅后即焚－03 在tab中使用fragment","text":"1. 为什么使用fragment? 简而言之，fragment可以让我们复用设计和代码。 2. fragment如何作为tab使用 在Activity里创建一个fragment container 创建fragment对应的class和layout 在Activity中添加初始化的fragment。当Activity加载时，初始化的fragment也应该加载 添加tab到Action Bar。Action Bar用来控制和显示tab 添加 TabListener 来加载新的fragment 可以在layout中使用fragment元素来显示的包含fragment。 3. 从模板中修改tab tab中的fragment到底是在哪里定义的呢？我们打开MainActivity，看到文件最后，定义了静态类： public static class PlaceholderFragment extends Fragment { /** * The fragment argument representing the section number for this * fragment. */ private static final String ARG_SECTION_NUMBER = \"section_number\" ; /** * Returns a new instance of this fragment for the given section * number. */ public static PlaceholderFragment newInstance ( int sectionNumber ) { PlaceholderFragment fragment = new PlaceholderFragment (); Bundle args = new Bundle (); args . putInt ( ARG_SECTION_NUMBER , sectionNumber ); fragment . setArguments ( args ); return fragment ; } public PlaceholderFragment () { } @Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . fragment_main , container , false ); return rootView ; } } 现在先不对这个类做太多深入了解，我们往上看，会看到一个 SectionsPagerAdapter 类的定义，这个类用可以看作是mvc中的控制器，用来连接视图和模型，其中视图就是屏幕，模型就是Fragment。 我们把它抽出来存放到一个单独的类中： public class SectionsPagerAdapter extends FragmentPagerAdapter { private Context mContext ; public SectionsPagerAdapter ( Context context , FragmentManager fm ) { super ( fm ); mContext = context ; } @Override public Fragment getItem ( int position ) { // getItem is called to instantiate the fragment for the given page. // Return a PlaceholderFragment (defined as a static inner class below). return MainActivity . PlaceholderFragment . newInstance ( position + 1 ); } @Override public int getCount () { // Show 2 total pages. return 2 ; } @Override public CharSequence getPageTitle ( int position ) { Locale l = Locale . getDefault (); switch ( position ) { case 0 : return mContext . getString ( R . string . title_section1 ). toUpperCase ( l ); case 1 : return mContext . getString ( R . string . title_section2 ). toUpperCase ( l ); } return null ; } } 注意，因为 getString 是 Context 类的方法。因此，我们需要传进来 Context ，而 Activity 类是 Context 的子类，所以调用时将 Activity 传给它即可。 // Create the adapter that will return a fragment for each of the three // primary sections of the activity. mSectionsPagerAdapter = new SectionsPagerAdapter ( this , getFragmentManager ()); 另外，更改数量为2，两个的标题分别为\"收件箱\"和\"好友\"。 4. 从模板中修改fragment 现在我们已经有了所有的一切，除了fragement，目前用来的还是默认的fragment。我们要做的就是把它给替换掉。 4.1 添加 InboxFragment 新建一个类，类名是 InboxFragment , 这个类继承自，继承自 android.app.ListFragment (也可以继承自 android.support.v4.app.ListFragment ，这样Android4.0之前的版本也能够使用）。 这里需要说明的是因为我们创建的是List类型的视图，所以创建了ListFragment，如同ListActivity对应Activity一样，ListFragment也对应继承自Fragment。 打开MainActivity，复制其中的PlaceHolderFragment的 onCreateView 方法到 InboxFragment 之中。Fragment像Activity一样也有 onCreate 方法，但是这里我们关注的是 onCreateView 方法，该方法在对应的Layout画面渲染时调用。修改后的类如下所示，同时，删除MainActivity中对应的PlaceHolderFragment。 public class InboxFragment extends ListFragment { @Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . fragment_main , container , false ); return rootView ; } } 上面的例子中 inflater.inflate(R.layout.fragment_main, container, false) 可以当作Activity中的 setContentView 方法，其中第一个参数就是layout，第二个参数是MainActivity中的 ViewPage ，第三个参数始终是 false 。 4.2 修改InboxFragment对应的layout 首先，重构 fragment_main.xml 为 fragment_inbox.xml . 然后，修改 fragment_inbox 的内容： <RelativeLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \"io.github.liulixiang1988.rabbit.InboxFragment\" > <ListView android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:id= \"@android:id/list\" android:layout_alignParentTop= \"true\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" /> <TextView android:id= \"@android:id/empty\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"@string/empty_inbox_label\" /> </RelativeLayout> 我们在这里做了一个列表，并且列表为空时显示\"没有新消息\"（在empty_inbox_label中定义）。 4.3 添加好友列表 类似的，添加 FriendsFragment , fragment_friends.xml 等，然后修改SectionPagerAdapter`。 4.4 修改 SectionsPagerAdapter public Fragment getItem(int position) { switch (position){ case 0 : return new InboxFragment(); case 1: return new FriendsFragment(); } return null; } 最后，运行如下： 5 理解基于Fragment的代码的其他部分 我们知道，创建一个Fragment程序分为以下几步： 在Activity中创建一个Fragment的容器（创建 SectionsPagerAdapter ，并且在 MainActivity 中添加了 SectionsPagerAdapter 实例） 创建Fragment的类和布局（创建 FriendsFragment 和 InboxFragment 和对应的xml） 在Activity中初始化Fragment（在 SectionsPagerAdapter 中的 getItem 中创建） 在Action Bar中添加tab 添加TabListener来加载新的Fragment 我们已经做了步骤1、2、3，现在我们打开 MainActivity 来看看它的 onCreate 方法： protected void onCreate(Bundle savedInstanceState) { //... // 设置Action Bar final ActionBar actionBar = getActionBar(); actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_TABS); // 设置返回fragment的adapter mSectionsPagerAdapter = new SectionsPagerAdapter(this, getFragmentManager()); // 设置ViewPager mViewPager = (ViewPager) findViewById(R.id.pager); mViewPager.setAdapter(mSectionsPagerAdapter); //在不同的区域滑动时，选择对应的tab，并且使用对应的ActionBar.Tab#select()来完成这些 mViewPager.setOnPageChangeListener(new ViewPager.SimpleOnPageChangeListener() { @Override public void onPageSelected(int position) { actionBar.setSelectedNavigationItem(position); } }); // 对每一节，添加tab到action bar for (int i = 0; i < mSectionsPagerAdapter.getCount(); i++) { // Create a tab with text corresponding to the page title defined by // the adapter. Also specify this Activity object, which implements // the TabListener interface, as the callback (listener) for when // this tab is selected. actionBar.addTab( actionBar.newTab() .setText(mSectionsPagerAdapter.getPageTitle(i)) .setTabListener(this)); } }","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-yue-hou-ji-fen-03-zai-tabzhong-shi-yong-fragment.html"},{"title":"使用Android开发一个阅后即焚-02 使用Parse.com添加用户","text":"1. 创建Parse.com账户和应用 1.1 创建Parse.com的账户 1.2 添加Parse.com的SDK 直接将Paser.com的SDK添加到app/libs文件夹内即可。 1.3 创建一个继承自Application的对象 public class RabbitApplication extends Application { @Override public void onCreate () { super . onCreate (); Parse . initialize ( this , \"6wZyARdh21YE1SFqceoIh24beo9WCzpYnjMCgqCV\" , \"9KT8jUIBizQbLh2yo5QLUWz74LJcRnIUcorTDuN8\" ); } } Application通常在app启动的时候就会自动创建。Application在app中是一个单例模式，而且Application也是整个app生命周期最长的对象。所有的Activity和Service都是共用着一个Application，所以Application通常用来共享数据，数据传递和数据缓存。 其中的 Parse.initialize() 时根据每个账户不同而不同，具体参见https://parse.com/apps/quickstart#parse_data/mobile/android/native/existing 仅仅自定义一个Application类时不行的，还需要在AndroidManifest.xml中的 <Application> 节点添加 android:name=\".RabbitApplication\" 属性. 1.4 添加Parse.com所需要的权限 <uses-permission android:name= \"android.permission.INTERNET\" /> <uses-permission android:name= \"android.permission.ACCESS_NETWORK_STATE\" /> 1.5 测试Parse 在RabbitApplication中的 onCreate 方法中添加 ParseObject testObject = new ParseObject ( \"TestObject\" ); testObject . put ( \"foo\" , \"bar\" ); testObject . saveInBackground (); 此时，点击运行程序。然后在Parse.com中的core里查看，我们可以看到一个表格。 2. 使用对话框处理错误 在SignUpActivity中的 onCreate 添加： mUserName = ( EditText ) findViewById ( R . id . usernameField ); mPassword = ( EditText ) findViewById ( R . id . passwordField ); mEmail = ( EditText ) findViewById ( R . id . emailField ); mSendBtn = ( Button ) findViewById ( R . id . btnSignup ); mSendBtn . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { String username = mUserName . getText (). toString (). trim (); String password = mPassword . getText (). toString (). trim (); String email = mEmail . getText (). toString (). trim (); if ( username . isEmpty () || password . isEmpty () || email . isEmpty ()){ AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ); builder . setTitle ( R . string . signup_error_title ) . setMessage ( R . string . signup_error_message ) . setPositiveButton ( android . R . string . ok , null ); AlertDialog alertDialog = builder . create (); alertDialog . show (); } else { //todo: new user here } } }); 3. 使用Parse创建用户 创建用户很简单，文档在https://parse.com/docs/android_guide#users-signup mSendBtn . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { //... if ( username . isEmpty () || password . isEmpty () || email . isEmpty ()){ //... } else { ParseUser user = new ParseUser (); user . setUsername ( username ); user . setPassword ( password ); user . setEmail ( email ); user . signUpInBackground ( new SignUpCallback () { @Override public void done ( ParseException e ) { if ( e == null ){ Intent intent = new Intent ( SignUpActivity . this , MainActivity . class ); intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ); intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ); startActivity ( intent ); } else { AlertDialog . Builder builder = new AlertDialog . Builder ( SignUpActivity . this ); builder . setTitle ( R . string . signup_error_title ) . setMessage ( e . getMessage ()) . setPositiveButton ( android . R . string . ok , null ); AlertDialog alertDialog = builder . create (); alertDialog . show (); } } }); } } }); 运行程序并注册，然后到https://www.parse.com/apps/rabbit--45/collections#class/_User 可以看到已经注册了一个用户 4. 用户登录 4.1 用户登录代码 使用Parse.com登录的文档在：https://parse.com/docs/android_guide#users-login 打开LoginActivity，添加如下代码 protected EditText mUserName ; protected EditText mPassword ; protected Button mLoginBtn ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_login ); //... mUserName = ( EditText ) findViewById ( R . id . usernameField ); mPassword = ( EditText ) findViewById ( R . id . passwordField ); mLoginBtn = ( Button ) findViewById ( R . id . btnLogin ); mLoginBtn . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View v ) { String username = mUserName . getText (). toString (). trim (); String password = mPassword . getText (). toString (). trim (); //用户名密码不能为空 if ( username . isEmpty () || password . isEmpty ()){ AlertDialog . Builder builder = new AlertDialog . Builder ( LoginActivity . this ); builder . setTitle ( R . string . login_error_title ) . setMessage ( R . string . login_error_message ) . setPositiveButton ( android . R . string . ok , null ); AlertDialog alertDialog = builder . create (); alertDialog . show (); } else { //登录 ParseUser . logInInBackground ( username , password , new LogInCallback () { @Override public void done ( ParseUser parseUser , ParseException e ) { if ( e == null ){ //登录成功 Intent intent = new Intent ( LoginActivity . this , MainActivity . class ); intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ); intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ); startActivity ( intent ); } else { //登录失败 AlertDialog . Builder builder = new AlertDialog . Builder ( LoginActivity . this ); builder . setTitle ( R . string . login_error_title ) . setMessage ( e . getMessage ()) . setPositiveButton ( android . R . string . ok , null ); AlertDialog alertDialog = builder . create (); alertDialog . show (); } } }); } } }); } 4.2 修改MainActivity Parse获取当前用户的方法：https://parse.com/docs/android_guide#users-current 打开MainActivity.java，修改 onCreate 方法： ParseUser currentUser = ParseUser . getCurrentUser (); if ( currentUser != null ) { Log . v ( TAG , currentUser . getUsername ()); } else { // show the signup or login screen Intent intent = new Intent ( this , LoginActivity . class ); //第1种方法 //intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK); //第2种方法 intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ); intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ); startActivity ( intent ); } 5. 用户登出 Parse登出用户的方法也在：https://parse.com/docs/android_guide#users-current 同时，我们还需要考虑一个问题，在哪里添加登出按钮比较合适呢？一般我们可以在菜单栏中添加退出按钮。 5.1 添加菜单 Android的菜单是在 onCreateOptionsMenu 方法中定义，打开MainActivity.java，我们看到它的菜单定义是： @Override public boolean onCreateOptionsMenu ( Menu menu ) { // Inflate the menu; this adds items to the action bar if it is present. getMenuInflater (). inflate ( R . menu . main , menu ); return true ; } 从上面的代码我们知道，MainActivity对应的菜单是在 res/menu/main.xml 中定义。打开这个文件，我们在里面定义菜单如下： <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" tools:context= \".MainActivity\" > <item android:id= \"@+id/action_logout\" android:title= \"@string/menu_logout_label\" android:orderInCategory= \"100\" android:showAsAction= \"never\" /> </menu> 说明： - orderInCategory:定义了一个顺序，值越小越在上面，值越大越在下面 - showAsAction:定义了是否在菜单栏中显示该动作， always 表示一直显示， ifRoom 表示有足够空间时显示， never 表示不显示. 5.2 菜单事件处理方法 Android的菜单事件处理方法是在 onOptionsItemSelected 中处理的。比如我们要处理登出事件，在 onOptionsItemSelected 中添加： @Override public boolean onOptionsItemSelected ( MenuItem item ) { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item . getItemId (); if ( id == R . id . action_logout ) { //登出 ParseUser . logOut (); navigateToLoginScreen (); return true ; } return super . onOptionsItemSelected ( item ); } 其中 navigateToLoginScreent() 方法如下： public void navigateToLoginScreen (){ // show the signup or login screen Intent intent = new Intent ( this , LoginActivity . class ); //第1种方法 //intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK); //第2种方法 intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ); intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ); startActivity ( intent ); } 6. 添加指示器表示登录状态 之前在使用Android创建博客阅读器的过程中，我们使用在layout中添加指示器的方法来添加指示器。除了这种方法之外，我们还可以使用另外一种方法在菜单中添加指示器。 打开SignUpActivity.java，在 onCreate 中添加： requestWindowFeature ( Window . FEATURE_INDETERMINATE_PROGRESS ); setContentView ( R . layout . activity_login ); 注意这两个的顺序，不能搞混，否则会导致程序崩溃。 后面就可以使用 setProgressBarIndeterminateVisibility(); 来显示和隐藏指示器了。比如 setProgressBarIndeterminateVisibility ( true ); ParseUser . logInInBackground ( username , password , new LogInCallback () { @Override public void done ( ParseUser parseUser , ParseException e ) { setProgressBarIndeterminateVisibility ( false ); //... } } 7. 总结 本节，我们学习了如何使用Parse，如何将Parse SDK添加到现有项目中，如何创建用户、用户登录、用户登出、使用对话框处理错误和使用指示器来显示注册、登录状态等等。","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-yue-hou-ji-fen-02-shi-yong-parsecomtian-jia-yong-hu.html"},{"title":"使用Android开发阅后即焚应用-01 开始","text":"1.阅后即焚应用介绍 阅后即焚是一款应用，用户可以适用它分享文字、照片给他的朋友，朋友们看过发来的消息之后该消息会自动销毁。 阅后即焚包含用户登录、用户注册、收件箱、好友列表、好友编辑、拍照等功能。 2.开始项目 本次项目适用Android Stuidio进行开发。 打开Android Studio，选择\"New Project\"，然后输入信息如下： 选择最小SDK，我们选定4.0版本为最小SDK： 选择\"Tabbed Activity\"标签页作为基础Activity： 最后，设置项目的MainActivity、Title和Navigation Style。注意，Navigation Style选择\"Action Bar Tabs(with ViewPager)\"： 现在，我们设置好了项目，但是还有一件事情要做，我们只希望应用是垂直的，而不希望手机放平时，应用也跟着水平。我们需要编辑AndroidManifest.xml文件。双击AndroidManifest.xml，文件打开，我们在 activity 中添加属性 android:screenOrientation=\"portrait\" 。与eclipse不同，Android Studio目前还没有图形化编辑AndroidManifest.xml的界面。 3. 添加用户登录Activity 我们可以到http://www.mobile-patterns.com/ 查看一些优秀的设计，看看别人时怎么做登录设计的。 要添加登录页面，在菜单中选择\"File\"->\"New...\"->\"Activity\"->\"Blank Activity\"(注意，还有一个\"Login Activity\"，但在这里我们不选用它，而是从头创建)。弹出对话框中输入： 设置用户界面为垂直的，方法同设置MainActivity相同，添加 android:screenOrientation=\"portrait\" 构建用户登录界面如下： 对应的xml如下 <RelativeLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingLeft= \"@dimen/activity_horizontal_margin\" android:paddingRight= \"@dimen/activity_horizontal_margin\" android:paddingTop= \"@dimen/activity_vertical_margin\" android:paddingBottom= \"@dimen/activity_vertical_margin\" tools:context= \"io.github.liulixiang1988.rabbit.LoginActivity\" > <EditText android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:id= \"@+id/username\" android:layout_alignParentTop= \"true\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" android:hint= \"@string/username\" /> <EditText android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:inputType= \"textPassword\" android:ems= \"10\" android:id= \"@+id/password\" android:layout_below= \"@+id/username\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" android:hint= \"@string/password\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"@string/login_btn_label\" android:id= \"@+id/btnLogin\" android:layout_below= \"@+id/password\" android:layout_centerHorizontal= \"true\" /> <TextView android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:textAppearance= \"?android:attr/textAppearanceSmall\" android:text= \"@string/signup_text_label\" android:id= \"@+id/txtSignUp\" android:layout_marginTop= \"78dp\" android:layout_below= \"@+id/btnLogin\" android:layout_centerHorizontal= \"true\" /> </RelativeLayout> 现在，我们想运行一下看看效果，但是启动界面时 MainActivity ，因此，我们在 MainActivity 的 onCreate 方法中添加： @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main ); //用户登录界面 Intent intent = new Intent ( this , LoginActivity . class ); startActivity ( intent ); ... } 4. 添加用户注册Activity 新建Activity，添加的Activity名称为 SignupActivity 。 设置界面垂直。 设置Layout如下： 对应的xml如下： <RelativeLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:paddingLeft= \"@dimen/activity_horizontal_margin\" android:paddingRight= \"@dimen/activity_horizontal_margin\" android:paddingTop= \"@dimen/activity_vertical_margin\" android:paddingBottom= \"@dimen/activity_vertical_margin\" tools:context= \"io.github.liulixiang1988.rabbit.SignupActivity\" > <EditText android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:id= \"@+id/usernameField\" android:layout_alignParentTop= \"true\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" android:hint= \"@string/username\" /> <EditText android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:inputType= \"textPassword\" android:ems= \"10\" android:id= \"@+id/passwordField\" android:layout_below= \"@+id/usernameField\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" android:hint= \"@string/password\" /> <EditText android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:inputType= \"textEmailAddress\" android:ems= \"10\" android:id= \"@+id/emailField\" android:layout_below= \"@+id/passwordField\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" android:hint= \"@string/email_text_label\" /> <Button android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:text= \"@string/signup_btn_label\" android:id= \"@+id/btnSignup\" android:layout_below= \"@+id/emailField\" android:layout_alignParentLeft= \"true\" android:layout_alignParentStart= \"true\" /> </RelativeLayout> 添加从登录LoginActivity到注册SignupActivity的跳转。打开LoginActivity，添加如下： protected TextView txtSignup ; @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_login ); txtSignup = ( TextView ) findViewById ( R . id . txtSignUp ); txtSignup . setOnClickListener ( new View . OnClickListener () { @Override public void onClick ( View view ) { Intent i = new Intent ( LoginActivity . this , SignupActivity . class ); startActivity ( i ); } }); } 5. Back和Up导航 Up导航是在app内导航到上一级别， 始终是在同一个app内 , 而Back导航则是根据用户的历史记录进行导航，比如导航到桌面或者其他应用中。 现在我们想要设置Signup(注册)的Up导航是Login(登录)，该怎么办呢？ 打开AndroidManifest.xml，在Signup中添加 android:parentActivityName ，如下： <activity android:name= \".SignupActivity\" android:label= \"@string/title_activity_signup\" android:parentActivityName= \".LoginActivity\" > </activity> 注意 ， android:parentActivityName 的值设置为Activity类名，也可以设置全名，比如 io.github.liulixiang1988.rabbit.LoginActivity 现在，我们再次运行程序，点击\"注册\"后，界面切换到注册，如下： 请注意图中用红色线框住的那一部分，有一个返回图标，点击它就会返回到登录界面。 另一个问题，如果我们在登录界面按鼠标上的返回按钮，那会发生什么呢？我们点击一下看看，竟然是收件箱画面： 这肯定不对，因为用户没有登录，不应该看到这个画面。 这种是由于什么原因导致的呢？Android在Activity跳转的过程中，会自己维护一个堆栈用来存放Activity的顺序，该堆栈适用后进先出的方式，在按返回按钮时会逐层返回Activity。有时我们想开辟一个新的堆栈，这个时候就需要添加一些flag来告诉Android我们的想法。对于Rabbit应用，我们希望用户在登录界面点击返回按钮时不要回到收件箱。这个时候，我们需要在MainActivity中设置flag。 Intent intent = new Intent ( this , LoginActivity . class ); //第1种方法 //intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK); //第2种方法 intent . addFlags ( Intent . FLAG_ACTIVITY_NEW_TASK ); intent . addFlags ( Intent . FLAG_ACTIVITY_CLEAR_TASK ); startActivity ( intent ); 这样，当在登录界面时按返回按钮就不会有到收件箱这种现象了。","tags":"Android","url":"/shi-yong-androidkai-fa-yue-hou-ji-fen-ying-yong-01-kai-shi.html"},{"title":"使用Android开发一个博客阅读器-05 使用Intent显示和共享博客","text":"1 在浏览器中打开网页 1.1 ListView 添加单击事件响应 要是 ListView 响应单击事件，重载函数： @Override protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ); } 参数： - l：发生点击事件的ListView - v: ListView中被点击的视图 - position：被点击的视图在list中的位置 - id：被点击视图的行ID 1.2 获取URL @Override protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ); JSONArray blogPosts ; try { blogPosts = blogData . getJSONArray ( \"posts\" ); JSONObject blogPost = blogPosts . getJSONObject ( position ); String blogUrl = blogPost . getString ( \"url\" ); } catch ( JSONException e ) { Log . e ( TAG , \"Exception Caught\" , e ); } } 1.3 使用Intent在浏览器中打开URL @Override protected void onListItemClick ( ListView l , View v , int position , long id ) { super . onListItemClick ( l , v , position , id ); JSONArray blogPosts ; try { blogPosts = blogData . getJSONArray ( \"posts\" ); JSONObject blogPost = blogPosts . getJSONObject ( position ); String blogUrl = blogPost . getString ( \"url\" ); //设置Intent Intent i = new Intent ( Intent . ACTION_VIEW ); i . setData ( Uri . parse ( blogUrl )); startActivity ( i ); } catch ( JSONException e ) { Log . e ( TAG , \"Exception Caught\" , e ); } } 使用 Intent.setData 来设置 Uri ，Uri则是通过 Uri.parse(String) 来创建。 2 在应用中打开网页 2.1 创建一个包含 WebView 的Activity 对应的layout <RelativeLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \"liulx.blogreader.BlogPostActivity\" > <WebView android:id= \"@+id/webView1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" /> </RelativeLayout> 2.2 使用Inent调用 在MainListActivity中，修改 Intent ： Intent i = new Intent ( this , BlogPostActivity . class ); 其他不变。这种创建方法是显示创建。 2.3 在包含 WebView 的Activity中打开网页 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_blog_post ); Intent i = getIntent (); Uri uri = i . getData (); WebView webView = ( WebView ) findViewById ( R . id . webView1 ); webView . loadUrl ( uri . toString ()); } 打开网页用的是 webView.loadUrl() 方法 3 使用Intent进行简单的共享 3.1 下载ActionBar图标 3.2 创建ActionBar Item 打开menu/blog_post.xml，删除原来的item，然后添加新的item。 打开xml文件，使用eclipse的 ctrl+shift+f ，格式化代码如下： <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" > <item android:id= \"@+id/share_post\" android:icon= \"@drawable/ic_action_share\" android:showAsAction= \"always\" android:title= \"@string/share_post\" > </item> </menu> 3.3 添加菜单项点击响应 重写 public boolean onOptionsItemSelected ( MenuItem item ) { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item . getItemId (); if ( id == R . id . share_post ) { } return super . onOptionsItemSelected ( item ); } 3.4 创建共享Intent @Override public boolean onOptionsItemSelected ( MenuItem item ) { // Handle action bar item clicks here. The action bar will // automatically handle clicks on the Home/Up button, so long // as you specify a parent activity in AndroidManifest.xml. int id = item . getItemId (); if ( id == R . id . share_post ) { sharePost (); } return super . onOptionsItemSelected ( item ); } private void sharePost () { Intent shareIntent = new Intent ( Intent . ACTION_SEND ); shareIntent . setType ( \"text/plain\" ); shareIntent . putExtra ( Intent . EXTRA_TEXT , url ); startActivity ( Intent . createChooser ( shareIntent , getString ( R . string . share_post ))); } 其中， - Intent.ACTION_SEND - 用来设置发送Intent - shareIntent.putExtra(Intent.EXTRA_TEXT, url); 与 ACTION_SEND 配合使用 - Intent.createChooser(shareIntent, getString(R.string.share_post)) 选择Intent菜单 4 总结 本节主要学习了如何使用Intent在浏览器、应用中打开网址，以及如何使用简单的共享。 至此，该应用完结，你创建了一个完整的应用。","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-05-shi-yong-intentxian-shi-he-gong-xiang-bo-ke.html"},{"title":"使用Android开发一个博客阅读器-04 在List中展现数据","text":"1 完成我们的异步任务AsyncTask 在 前一篇文章 中，我们的JSON数据并不是从主线程中直接获取，而是使用了 AsyncTask 类。 AsyncTask 类执行异步操作有4步： onPreExecute() ，在任务执行之前调用UI线程。主要用来设置任务，比如在用户界面中显示一个进度条。 doInBackground(Params...) , 在执行完 onPreExecute() 后立即调用后台任务线程。这个用来执行耗时的后台操作。异步任务的参数在这个步骤中传递。并且结果必须在此不返回，并且传递给最后一步（即第四部）。这一步也可以使用 publishProgress(Progress...) ，用来发布进度。这些值在 onProgressUpdate(Progress...) 步骤中被发布到UI线程。 onProgressUpdate(Progress...) 在调用 publishPorgress(Porgress...) 后调用UI线程。用来展现后台计算的执行进度。比如，它可以用来展现一个进度条的动画或者在文本中显示日志。 onPostExecute(Result) ，在后台计算完成后调用UI线程。在这步中，后台计算的结果作为参数传递进来。 根据上面的条件，我们对之前的异步任务类进行改造： - 更改返回类型为 JSONObject - 添加 onPostExecute 方法，参数类型还是 JSONObject ，在这里通知UI线程进行更新列表 - 在MainListActivity中增加一个 JSONObject 字段，用来保存获取的JSON数据 代码如下： public class MainListActivity extends ListActivity { //... protected JSONObject blogData ; //... public void updateList (){ if ( blogData == null ){ // TODO: handle error } else { try { Log . d ( TAG , blogData . toString ( 2 )); } catch ( JSONException e ) { Log . e ( TAG , \"Exception caught\" , e ); } } } private class GetBlogPostTasks extends AsyncTask < Object , Void , JSONObject >{ @Override protected JSONObject doInBackground ( Object ... params ) { int responseCode = 1 ; JSONObject jsonResponse = null ; try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); HttpURLConnection connection = ( HttpURLConnection ) blogFeedUrl . openConnection (); connection . connect (); responseCode = connection . getResponseCode (); if ( responseCode == HttpURLConnection . HTTP_OK ){ InputStream inputStream = connection . getInputStream (); Reader reader = new InputStreamReader ( inputStream ); int contentLength = connection . getContentLength (); char [] charArray = new char [ contentLength ]; reader . read ( charArray ); String responseData = new String ( charArray ); jsonResponse = new JSONObject ( responseData ); String status = jsonResponse . getString ( \"status\" ); Log . v ( TAG , status ); JSONArray jsonPosts = jsonResponse . getJSONArray ( \"posts\" ); for ( int i = 0 ; i < jsonPosts . length (); i ++){ JSONObject jsonPost = jsonPosts . getJSONObject ( i ); String title = jsonPost . getString ( \"title\" ); Log . i ( TAG , \"Post \" + i + \": \" + title ); } } else { Log . i ( TAG , \"Unsuccessful HTTP Response Code: \" + responseCode ); } } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( IOException e ) { Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( Exception e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } return jsonResponse ; } @Override protected void onPostExecute ( JSONObject result ) { blogData = result ; updateList (); } } } 2 填充字符串数组，并且创建Adapter适配器 JSONArray jsonPosts = blogData . getJSONArray ( \"posts\" ); blogPostTitles = new String [ jsonPosts . length ()]; for ( int i = 0 ; i < jsonPosts . length (); i ++){ JSONObject post = jsonPosts . getJSONObject ( i ); String title = post . getString ( \"title\" ); title = Html . fromHtml ( title ). toString (); blogPostTitles [ i ] = title ; } ArrayAdapter < String > adapter = new ArrayAdapter < String >( this , android . R . layout . simple_list_item_1 , blogPostTitles ); setListAdapter ( adapter ); 注意： 因为title中可能包含一些特殊的字符，比如\"New Course: Treehouse Club – JavaScript\"，如果直接显示，就太不友好了，因此，需要对它进行转化，使用 Html.fromHtml(title) 进行转化，但是 fromHtml() 返回的是 Spanned ,因此需要使用 toString() 方法返回字符串。 3 使用对话窗处理错误 AlertDialog.Builder 是工厂模式。 AlertDialog . Builder builder = new AlertDialog . Builder ( this ); builder . setTitle ( R . string . error_title ); builder . setMessage ( R . string . error_message ); builder . setPositiveButton ( android . R . string . ok , null ); AlertDialog dialog = builder . create (); dialog . show (); setPositiveButton(android.R.string.ok, null) 设置按钮与按钮事件，我们不需要设置按钮点击事件，仅仅是消失，所以传递null即可。 4 清理展示 在展示具体应用之前，我们需要修改2个东西：第一，如果从网络中加载数据时间过长，我们的应用显示的是\"没有数据\"；第二，我们想要在list中添加作者。对于第一个问题，我们可以通过添加指示器来实现 4.1 添加指示器 设置 ListView 对应的empty TextView 首先，清空 TextView 的Text <TextView android:id= \"@android:id/empty\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_alignParentLeft= \"true\" android:layout_alignParentTop= \"true\" /> 然后，打开MainListActivity.java，在错误对话框代码下面添加如下代码： TextView textView = ( TextView ) getListView (). getEmptyView (); textView . setText ( getString ( R . string . no_data )); 注意 , ListView 对应的空 TextView ( android:id=\"@android:id/empty\" )，获取它不是通过 getViewById() ，而是 getListView().getEmptyView() 。 获取strings.xml中的字符串： getString(R.string.no_data) 添加指示器 <ProgressBar android:id= \"@+id/progressBar1\" style= \"?android:attr/progressBarStyleLarge\" android:layout_width= \"wrap_content\" android:layout_height= \"wrap_content\" android:layout_centerInParent= \"true\" /> 说明： layout_centerInParent=\"true\" 让指示器居中。 在程序中添加 protected ProgressBar progressBar; 在 onCreate 中初始化 progressBar 并且使其可见： progressBar = ( ProgressBar ) findViewById ( R . id . progressBar1 ); if ( isNetworkAvailable ()) { progressBar . setVisibility ( View . VISIBLE ); //设置可见 GetBlogPostTasks getBlogPostTask = new GetBlogPostTasks (); getBlogPostTask . execute (); } else { Toast . makeText ( this , \"网络连接不可用\" , Toast . LENGTH_LONG ). show (); } 在 updateList 中将 progressBar 设置为不可见： progressBar.setVisibility(View.INVISIBLE); 重构 修改 updateList 为 handleBlogResponse ，并将 blogData==null 时的内容提取到新方法 updateDisplayForError() 中。 5 给List添加作者 public static final String KEY_TITLE = \"title\" ; public static final String KEY_AUTHOR = \"author\" ; public void handleBlogResponse (){ progressBar . setVisibility ( View . INVISIBLE ); if ( blogData == null ){ updateDispalyForError (); } else { try { JSONArray jsonPosts = blogData . getJSONArray ( \"posts\" ); //ArrayList就是一个数组List， HashMap类似字典 ArrayList < HashMap < String , String >> blogPosts = new ArrayList < HashMap < String , String >>(); for ( int i = 0 ; i < jsonPosts . length (); i ++){ JSONObject post = jsonPosts . getJSONObject ( i ); //获取title String title = post . getString ( KEY_TITLE ); title = Html . fromHtml ( title ). toString (); //获取作者 String author = post . getString ( KEY_AUTHOR ); author = Html . fromHtml ( author ). toString (); //创建字典 HashMap < String , String > blogPost = new HashMap < String , String >(); blogPost . put ( KEY_TITLE , title ); blogPost . put ( KEY_AUTHOR , author ); //添加字典到ArrayList blogPosts . add ( blogPost ); } //映射form字段 String [] keys = { KEY_TITLE , KEY_AUTHOR }; //映射to字段 int [] ids = { android . R . id . text1 , android . R . id . text2 }; //使用SimpleAdapter代替ArrayAdapter，可以添加映射 SimpleAdapter adapter = new SimpleAdapter ( this , blogPosts , android . R . layout . simple_list_item_2 , keys , ids ); setListAdapter ( adapter ); } catch ( JSONException e ) { Log . e ( TAG , \"Exception caught\" , e ); } } } 6 总结 本节我们学习了如何处理异步的数据；Adapter适配器的使用；对话框的使用；进度指示器的使用；SimpleAdapter的使用。","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-04-zai-listzhong-zhan-xian-shu-ju.html"},{"title":"Django SQL Server数据库驱动,根据现有数据库生成models以及数据库迁移","text":"1. SQL Sever驱动 1.1 安装 mssql数据库 使用django-mssql，依赖pywin32，如果安装时发生错误，请用下面这种方法： pip install django-mssql --pre 1.2 配置 在settings.py中，设置： # Database # https://docs.djangoproject.com/en/1.6/ref/settings/#databases DATABASES = { 'default': { 'ENGINE': 'sqlserver_ado', 'NAME': 'data_center', 'USER': 'sa', 'PASSWORD': 'test', 'HOST': 'localhost', } } 2. 根据现有数据库生产models python manage.py inspectdb > models.py 3. 数据库迁移 3.1 south安装 pip install south ./manage.py syncdb 3.2 在新建的App中使用South a. 前期准备 创建信app,并将其添加到INSTALL_APPS中： ./manage.py startapp testapp 打开app的models.py，创建model： b. 第一次迁移 ./manage.py schemamigration testapp --initial ./mange.py migrate testapp c.之后的迁移 ./manage.py schemamigration testapp --auto ./mange.py migrate testapp 4. Django 1.7中的数据库迁移 4.1 创建工程之后，进行第一次迁移 当使用 django-admin.py startproject mysite 之后，进行第一次： python manage.py migrate 4.2 之后的迁移分为3部走 修改model 使用 python manage.py makemigrations 迁移名称 创建迁移 使用 python manage.py migrate 应用迁移 注意 ，可以使用 python mange.py sqlmigrate 迁移名 版本号 查看迁移，比如： python manage.py sqlmigrate polls 00001","tags":"Python","url":"/django-sql-servershu-ju-ku-qu-dong-gen-ju-xian-you-shu-ju-ku-sheng-cheng-modelsyi-ji-shu-ju-ku-qian-yi.html"},{"title":"使用Android开发一个博客阅读器-03 从网络中获取数据","text":"1 获取URL 在MainListActivity.java中添加两个常量： public static final int NUMBER_OF_POSTS = 20 ; //博客数目 public static final String TAG = MainListActivity . class . getSimpleName (); //用来做日志输出时调用 然后修改 onCreate 方法： protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_main_list ); try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } ArrayAdapter < String > adapter = new ArrayAdapter < String >( this , android . R . layout . simple_list_item_1 , names ); setListAdapter ( adapter ); } 2 从网上获取数据的错误方法 要让应用能够上网，首先，需要在AndroidManifest.xml中添加权限 <uses-sdk android:minSdkVersion= \"9\" android:targetSdkVersion= \"21\" /> <uses-permission android:name= \"android.permission.INTERNET\" /> 然后在 onCreate 方法中添加如下方法： try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); HttpURLConnection connection = ( HttpsURLConnection ) blogFeedUrl . openConnection (); connection . connect (); int responseCode = connection . getResponseCode (); Log . i ( TAG , \"Response Code:\" + responseCode ); } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( IOException e ) { Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( Exception e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } 上面的方法错在哪呢？错在将网络访问放在主线程内进行。 3. 异步请求 android.os.AsyncTask 用来执行异步请求。要实现自己的异步请求，需要做下面的工作。 3.1 继承 android.os.AsyncTask ，实现 doInBackground 方法 private class GetBlogPostTasks extends AsyncTask < Object , Object , Object >{ @Override protected Object doInBackground ( Object ... params ) { return null } } AsyncTask<Object, Object, Object> 的三个参数分别是： 传递给 doInBackground 的参数类型 后台执行的进度单位的类型 返回值得类型 由此，我们进行改造，因为我们不用传递给 doInBackground 参数，所以不用对第一个参数进行修改。并且，我们也不用关心进度情况，可以将第二个参数类型修改为 Void ，最后，我们希望返回状态码，因此第三个类型，修改为 String 。 注意， doInBackground 的返回值也要修改。 一般来说，异步的类直接放到要使用它的类里面，因此，我们在 MainListActivity 中添加的代码如下： private class GetBlogPostTasks extends AsyncTask < Object , Void , String >{ @Override protected String doInBackground ( Object ... params ) { int responseCode = 1 ; try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); HttpURLConnection connection = ( HttpURLConnection ) blogFeedUrl . openConnection (); connection . connect (); responseCode = connection . getResponseCode (); Log . i ( TAG , \"Response Code:\" + responseCode ); } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( IOException e ) { Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( Exception e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } return \"Response Status\" + responseCode ; } } 3.2 调用异步类 调用异步类的方法比较容易，在 MainListActivity 的 onCreate 方法中添加： GetBlogPostTasks getBlogPostTask = new GetBlogPostTasks (); getBlogPostTask . execute (); 4 处理无法联网的情况 在从网上获取数据时，我们还有一件事情要做，就是处理网络不可用的时候的情况。 要检查网络状况，也需要对应的权限，在AndroidManifest文件中添加对应的权限： <uses-permission android:name= \"android.permission.ACCESS_NETWORK_STATE\" /> 然后在 MainListActivity 中添加方法用来检查网络情况： public boolean isNetworkAvailable (){ ConnectivityManager manager = ( ConnectivityManager ) getSystemService ( Context . CONNECTIVITY_SERVICE ); NetworkInfo networkinfo = manager . getActiveNetworkInfo (); boolean isAvailable = false ; if ( networkinfo != null && networkinfo . isConnected ()){ isAvailable = true ; } return isAvailable ; } getSystemService 获取的是 Object 类型，需要转换一下 Context 定义了一些系统自带Service的常量 ConnectivityManager 类的 getActiviteNetworkInfo 方法返回 NetworkInfo 类 NetworkInfo 的 isConnected 方法用来检查是否已经联网 最后，更改 onCreate 方法，在网络访问前先检查网络状况，如果网络状况不好提醒用户： if ( isNetworkAvailable ()) { GetBlogPostTasks getBlogPostTask = new GetBlogPostTasks (); getBlogPostTask . execute (); } else { Toast . makeText ( this , \"网络连接不可用\" , Toast . LENGTH_LONG ). show (); } 5 从HTTP请求中获得JSON数据 获取JSON数据的网址是http://blog.teamtreehouse.com/api/get_recent_summary/?count=20 可以先在浏览器中打开看看数据的格式。 在前一节中，我们检查了网络情况，并打印了返回值。在本节中，我们将从结果中打印出返回的结果。 try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); HttpURLConnection connection = ( HttpURLConnection ) blogFeedUrl . openConnection (); connection . connect (); responseCode = connection . getResponseCode (); if ( responseCode == HttpURLConnection . HTTP_OK ){ InputStream inputStream = connection . getInputStream (); Reader reader = new InputStreamReader ( inputStream ); int contentLength = connection . getContentLength (); char [] charArray = new char [ contentLength ]; reader . read ( charArray ); String resonseData = new String ( charArray ); Log . v ( TAG , resonseData ); } else { Log . i ( TAG , \"Unsuccessful HTTP Response Code: \" + responseCode ); } } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( IOException e ) { Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( Exception e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } 我们主要看中间 if 判断这一部分。 responseCode == HttpURLConnection.HTTP_OK 用来判断数据是否成功获取 请求返回结果从 InputStream inputStream = connection.getInputStream(); 中获取，然后使用 Reader reader = new InputStreamReader(inputStream); 来读取。 Reader 读取的是 char[] 类型，因此需要声明一个 char[] 数组，数组长度是返回内容的长度，通过 connection.getContentLength() 获取 char[] 转换为 String ，并调用 Log.v 输出，这里的 v 是指verbose 6 从JSON格式中解析数据 Android提供了内建对象用来做JSON解析： JSONObject JSONArray ： JSONObject 数组 6.1 声明JSONObject JSONObject jsonResponse = new JSONObject ( responseData ); 6.2 获取JSONObject中的数据 JSONObject 提供了很多获取数据的方法，比如 getString , getInt , getJSONArray 等。 注意 ， getJSONArray 返回 JSONArray 对象。 String status = jsonResponse . getString ( \"status\" ); JSONArray jsonPosts = jsonResponse . getJSONArray ( \"posts\" ); 6.3 使用JSONArray for ( int i = 0 ; i < jsonPosts . length (); i ++){ JSONObject jsonPost = jsonPosts . getJSONObject ( i ); String title = jsonPost . getString ( \"title\" ); Log . i ( TAG , \"Post \" + i + \": \" + title ); } 整个方法如下： protected String doInBackground ( Object ... params ) { int responseCode = 1 ; try { URL blogFeedUrl = new URL ( \"http://blog.teamtreehouse.com/api/get_recent_summary/?count=\" + NUMBER_OF_POSTS ); HttpURLConnection connection = ( HttpURLConnection ) blogFeedUrl . openConnection (); connection . connect (); responseCode = connection . getResponseCode (); if ( responseCode == HttpURLConnection . HTTP_OK ){ InputStream inputStream = connection . getInputStream (); Reader reader = new InputStreamReader ( inputStream ); int contentLength = connection . getContentLength (); char [] charArray = new char [ contentLength ]; reader . read ( charArray ); String responseData = new String ( charArray ); JSONObject jsonResponse = new JSONObject ( responseData ); String status = jsonResponse . getString ( \"status\" ); Log . v ( TAG , status ); JSONArray jsonPosts = jsonResponse . getJSONArray ( \"posts\" ); for ( int i = 0 ; i < jsonPosts . length (); i ++){ JSONObject jsonPost = jsonPosts . getJSONObject ( i ); String title = jsonPost . getString ( \"title\" ); Log . i ( TAG , \"Post \" + i + \": \" + title ); } } else { Log . i ( TAG , \"Unsuccessful HTTP Response Code: \" + responseCode ); } } catch ( MalformedURLException e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( IOException e ) { Log . e ( TAG , \"Eception Caught:\" , e ); } catch ( Exception e ){ Log . e ( TAG , \"Eception Caught:\" , e ); } return \"Response Status\" + responseCode ; }","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-03-cong-wang-luo-zhong-huo-qu-shu-ju.html"},{"title":"使用Android开发一个博客阅读器-02 从头开始创建","text":"1创建项目和ListActivity 1.1 创建项目 创建Android项目，项目名称BlogReader，视图名称为MainListActivity。 1.2 更改Activity 打开MainListActivity.java文件，修改继承为 ListActivity ，如下 public class MainListActivity extends ListActivity 此时，会提示有错，主要是因为没有导入ListActivity这个类。在eclipse中，有一个快捷键可以快速修正这个错误： ctrl+shift+o 。这个快捷键不仅会导入没有使用到的快捷键，还会去除没有使用的import。 1.3 更改activity_main_list.xml 删除生成的TextView 添加 ListView ，如下所示： <ListView android:id= \"@+id/listView1\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:layout_alignParentLeft= \"true\" android:layout_alignParentTop= \"true\" > </ListView> 更改 ListView 的ID 如果我们给 ListView 分配了一个特殊的ID，Android会自动为 ListActivity 调用这个 ListView ，修改上面的 ListView 如下： <ListView android:id= \"@android:id/list\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:layout_alignParentLeft= \"true\" android:layout_alignParentTop= \"true\" > </ListView> 删除 RelativeLayout 自动生成的padding，整个layout文件如下： <RelativeLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:tools= \"http://schemas.android.com/tools\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" tools:context= \"liulx.blogreader.MainListActivity\" > <ListView android:id= \"@android:id/list\" android:layout_width= \"match_parent\" android:layout_height= \"match_parent\" android:layout_alignParentLeft= \"true\" android:layout_alignParentTop= \"true\" > </ListView> </RelativeLayout> 预览图： 2 处理没有数据的情况 当博客列表中没有数据时，我们最好给用户一个提醒，让用户知道是没有数据，而不是在加载数据。 ListActivity 提供了一个简单的方法来完成这件事。我们添加一个 TextView ，它能同 ListActivity 协同工作来完成这个工作，不过需要给它添加一个特殊的 id ，用来在list为空时显示。 <TextView android:id= \"@android:id/empty\" android:layout_width= \"match_parent\" android:layout_height= \"wrap_content\" android:layout_alignParentLeft= \"true\" android:layout_alignParentTop= \"true\" android:text= \"@string/no_data\" /> 当list中包含数据时， TextView 就会自动隐藏。 此时，因为没有数据，程序运行后是这个样子： 3 向List中添加数据 3.1 添加数组数据 打开MainListActivity.java，添加数组变量： protected String [] names = { \"刘理想\" , \"Andrew\" , \"Bubble\" , \"Cellia\" , \"Mark\" , \"Stone\" , \"Bingo\" , \"Stefanie\" }; 3.2 添加 ArrayAdapter 在 onCreate 中添加如下两行： ArrayAdapter < String > adapter = new ArrayAdapter < String >( this , android . R . layout . simple_list_item_1 , names ); setListAdapter ( adapter ); 其中 ArrayAdapter(Context context, int resource, T[] objects) 的变量分别如下： context上下文 对应列表项的layout，使用系统自带的 android.R.layout.simple_list_item_1 objects是数据源，我们使用了 names 这个数组 运行后效果图 4. 关于@String资源 4.1 在java文件中引用res/values/strings.xml中定义的字符串 使用 Context 类的 getString 方法： getString ( R . string . hello ) 4.2 添加字符串数组 打开res/values/strings.xml文件，添加字符串数组如下： <string-array name= \"names\" > <item> 刘理想 </item> <item> Andrew </item> <item> Bubble </item> <item> Cellia </item> <item> Mark </item> <item> Stone </item> <item> Bingo </item> <item> Stefanie </item> </string-array> 更改java 文件中的数组声明： protected String [] names ; 4.3 调用字符串数组 通过以下方法 Resources resource = getResources (); names = resource . getStringArray ( R . array . names ); 其中 getResources 获得资源， resource.getStringArrary 获得数组。","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-02-cong-tou-kai-shi-chuang-jian.html"},{"title":"使用Android开发一个博客阅读器-01 使用Master-Detail模板","text":"项目地址：https://github.com/liulixiang1988/android_demo/tree/master/MasterDetailExample 我们使用Master-Detail模板来做本应用的模板。 建立Master-Detail模板 新建Android项目，命名为MasterDetailExample，模板类型选择为Master-Detail。 理解Master-Details模板 ListFraments和DetailFragments DummyContent用来作为MVC中的Model，保存List数据。 Fragments中几种方法的调用顺序 1. onAttach(Activity activity) 第一个被调用 包含Fragment的Activity必须实现 Callbacks 接口。 @Override public void onAttach ( Activity activity ) { super . onAttach ( activity ); // Activities containing this fragment must implement its callbacks. if (!( activity instanceof Callbacks )) { throw new IllegalStateException ( \"Activity must implement fragment's callbacks.\" ); } mCallbacks = ( Callbacks ) activity ; } 2. onCreate(Bundle savedInstanceState) 第二个被调用 这里设置一些数据项。 @Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); // TODO: replace with a real list adapter. setListAdapter ( new ArrayAdapter < DummyContent . DummyItem >( getActivity (), android . R . layout . simple_list_item_activated_1 , android . R . id . text1 , DummyContent . ITEMS )); } 3. onViewCreated(View view, Bundle savedInstanceState) 第三个被调用 @Override public void onViewCreated ( View view , Bundle savedInstanceState ) { super . onViewCreated ( view , savedInstanceState ); // Restore the previously serialized activated item position. if ( savedInstanceState != null && savedInstanceState . containsKey ( STATE_ACTIVATED_POSITION )) { setActivatedPosition ( savedInstanceState . getInt ( STATE_ACTIVATED_POSITION )); } } 4. 对于ListFragment，当点击时， onListItemClick(ListView listView, View view, int position, long id) 被调用 @Override public void onListItemClick ( ListView listView , View view , int position , long id ) { super . onListItemClick ( listView , view , position , id ); // Notify the active callbacks interface (the activity, if the // fragment is attached to one) that an item has been selected. mCallbacks . onItemSelected ( DummyContent . ITEMS . get ( position ). id ); } 理解DetailActivity源码 DetailActivity中包含的Fragment是手工添加的，而非通过Layout文件添加。添加的代码在 onCreate 方法中。 我们使用 fragment.setArguments(arguments) 来设置参数，其中参数 arguments 是 Bundle 类型。 @Override protected void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . activity_blogpost_detail ); // 添加返回按钮 getActionBar (). setDisplayHomeAsUpEnabled ( true ); // savedInstanceState is non-null when there is fragment state // saved from previous configurations of this activity // (e.g. when rotating the screen from portrait to landscape). // In this case, the fragment will automatically be re-added // to its container so we don't need to manually add it. // For more information, see the Fragments API guide at: // // http://developer.android.com/guide/components/fragments.html // if ( savedInstanceState == null ) { // Create the detail fragment and add it to the activity // using a fragment transaction. Bundle arguments = new Bundle (); //传递列表行到Fragment中 arguments . putString ( BlogPostDetailFragment . ARG_ITEM_ID , getIntent (). getStringExtra ( BlogPostDetailFragment . ARG_ITEM_ID )); //创建Fragment BlogPostDetailFragment fragment = new BlogPostDetailFragment (); fragment . setArguments ( arguments ); getFragmentManager (). beginTransaction () . add ( R . id . blogpost_detail_container , fragment ) . commit (); } } 理解DetailFragment源码 DetailFragment中包含一个 mItem ，它是 DummyContent.DummyItem 类型。 在 onCreate 方法中，我们使用 getArguments 来获取传递的 Bundle 类型的参数，然后再调用 Bundle.getString() 方法就能获取 Bundle 中的数据。 @Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); if ( getArguments (). containsKey ( ARG_ITEM_ID )) { // Load the dummy content specified by the fragment // arguments. In a real-world scenario, use a Loader // to load content from a content provider. mItem = DummyContent . ITEM_MAP . get ( getArguments (). getString ( ARG_ITEM_ID )); } } 再来看看 onCreateView 方法，用 mItem.content 来填充数据，我们也可以换成其他的数据类型。 @Override public View onCreateView ( LayoutInflater inflater , ViewGroup container , Bundle savedInstanceState ) { View rootView = inflater . inflate ( R . layout . fragment_blogpost_detail , container , false ); // Show the dummy content as text in a TextView. if ( mItem != null ) { (( TextView ) rootView . findViewById ( R . id . blogpost_detail )). setText ( mItem . content ); } return rootView ; }","tags":"Android","url":"/shi-yong-androidkai-fa-yi-ge-bo-ke-yue-du-qi-01-shi-yong-master-detailmo-ban.html"},{"title":"Nancy Web框架","text":"Nancy框架 一、创建第一个Nancy应用 安装 Nancy项目模板 创建 Nancy Empty Web Application with ASP.NET Hosting 添加 Nancy module ,它是一个标准C#类，通过添加下面几行代码定义了web应用的路由处理方法。 编译并运行。 public class HelloModule : NancyModule { public HelloModule() { Get[\"/\"] = parameters => \"Hello World\"; } } 二、探索Nancy的module Module继承自 NancyModule 类。Module是必不可少的.它不仅定义了路由，还提供了许多其他信息，比如请求、上下文、构造响应的辅助方法、视图渲染等等。 1. 模块能够在全局被发现 可以在任意地方定义module，比如外部的dll等，这为代码的复用带来很大的方便。不用担心效率问题，扫描module只在程序启动时发生。 2. 使用模块为路由创建一个根 类似命名空间的概念，在创建构造方法时传给base一个名称。 public class ResourceModule : NancyModule { public ResourceModule() : base(\"/products\") { // would capture routes to /products/list sent as a GET request Get[\"/list\"] = parameters => { return \"The list of products\"; }; } } 三、定义路由 路由是在module的构造方法中定义的。为了定义一个路由，你需要声明 方法 + 模式 + 动作 +(可选) 条件 比如： public class ProductsModule : NancyModule { public ProductsModule() { Get[\"/products/{id}\"] = _ => { //do something }; } } 或者异步 public class ProductsModule : NancyModule { public ProductsModule() { Get[\"/products/{id}\", runAsync: true] = async (_, token) => { //do something long and tedious }; } } 1. 方法 支持HTTP常见方法： DELETE , GET , HEAD , OPTIONS , POST , PUT , PATCH 2. 模式 模式能够自定义，Nancy提供了一些常用的： 字面量 - /some/literal/segments 捕获片段 - /{name} ，获取URL的片段，并传给路由的Action 捕获可选片段 - /{name?} ，添加了一个问号，片段就是可选的了 捕获可选/默认片段 - /{name?default} 正则片段 - /(?<age>[\\d]{1,2}) ，使用命名捕获组来捕获片段，如果不需要捕获，使用非捕获组，比如 (?:regex-goes-here) 贪心片段 - /{name*} ，从/处开始捕获 贪心正则捕获 - &#94;(?<name>[a-z]{3, 10}(?:/{1})(?<action>[a-z]{5, 10}))$ 多个捕获片段 - /{file}.{extension} 或者 /{file}.ext 3. 模式的优先级 4. 动作 动作时一个lambda表达式 Func<dynamic, dynamic> ，输入时 DynamicDictionary ，详见 此处 . 响应可以使任意的model，最终的结果会被 Content Negotiation 处理。但是如果返回值是 Response 类型，则原样返回。 Response 对象有几个隐形转换操作： 1. int 变为Http的状态 2. HttpStatusCode 枚举值 3. string 直接是相应的body 4. Action<Stream> 则写道response stream中 5. 条件 路由条件用来过滤（比如登录非登录）。使用 Func<NancyContext, bool> 的lambda表达式定义. Post[\"/login\", (ctx) => ctx.Request.Form.remember] = _ => { return \"Handling code when remember is true!\"; } Post[\"/login\", (ctx) => !ctx.Request.Form.remember] = _ => { return \"Handling code when remember is false!\"; } 6. 路由片段约束 Get [ \"/intConstraint/{value:int}\" ] = _ => \"Value \" + _ .value + \" is an integer.\" ; 只有为int的才会匹配。 约束： - int - decimal - guid - bool - alpha - datetime - datetime(format) - min(minimum) - max(maximum) - range(minimum, maximum) - minlength(length) - maxlength(length) - length(minimum, maximum) 6.1 自定义约束 实现 IRouteSegmentConstraint 接口，或者继承自 - RouteSegmentConstraintBase<T> - Base class for a named constraint. - ParameterizedRouteSegmentConstraintBase<T> - Base class for a named constraint that accepts arguments. 例子 一个email约束 public class EmailRouteSegmentConstraint : RouteSegmentConstraintBase < string > { public override string Name { get { return \"email\" ; } } protected override bool TryMatch ( string constraint , string segment , out string matchedValue ) { if ( segment . Contains ( \"@\" )) { matchedValue = segment ; return true ; } matchedValue = null ; return false ; } } 用法 Get [ \"/profile/{value:email}\" ] = _ => \"Value \" + _ .value + \" is an e-mail address.\" ; 7. 选择去调用路由的秘诀 一个请求有时符合多个模式，此时记住： 1. module的顺序在启动时不定 2. 同一module中的路由是按顺序来的 3. 多个匹配中，得分最高的匹配 4. 得分相同的匹配按照启动时的顺序匹配 8. 疯狂的路由 一些可能的用法： // would capture routes like /hello/nancy sent as a GET request Get [ \"/hello/{name}\" ] = parameters => { return \"Hello \" + parameters . name ; }; // would capture routes like /favoriteNumber/1234, but not /favoriteNumber/asdf as a GET request Get [ \"/favoriteNumber/{value:int}\" ] = parameters => { return \"So your favorite number is \" + parameters . value + \"?\" ; }; // would capture routes like /products/1034 sent as a DELETE request Delete [ @\"/products/(?<id>[\\d]{1,7})\" ] = parameters => { return 200 ; }; // would capture routes like /users/192/add/moderator sent as a POST request Post [ \"/users/{id}/add/{category}\" ] = parameters => { return HttpStatusCode . OK ; }; 四、自定义路由 http://www.philliphaydon.com/2013/04/nancyfx-implementing-your-own-routing/ 五、异步 1. 语法 Before/After管道、主路由委托都可以使用async.语法绝大部分与同步代码一致，但需要注意下面的变化： before/after钩子接受两个参数，context和cancellation token(取消令牌)，而不仅仅是context 路由定义有一个附加的bool参数，并且委托接受两个参数，一个捕获的参数，另一个cancellation token. 2 语法例子 public MainModule () { Before += async ( ctx , ct ) => { this . AddToLog ( \"Before Hook Delay\\n\" ); await Task . Delay ( 5000 ); return null ; } ; After += async ( ctx , ct ) => { this . AddToLog ( \"After Hook Delay\\n\" ); await Task . Delay ( 5000 ); this . AddToLog ( \"After Hook Complete\\n\" ); ctx . Response = this . GetLog (); } ; Get [ \"/\" , true ] = async ( x , ct ) => { this . AddToLog ( \"Delay 1\\n\" ); await Task . Delay ( 1000 ); this . AddToLog ( \"Delay 2\\n\" ); await Task . Delay ( 1000 ); this . AddToLog ( \"Executing async http client\\n\" ); var client = new HttpClient (); var res = await client . GetAsync ( \"http://nancyfx.org\" ); var content = await res . Content . ReadAsStringAsync (); this . AddToLog ( \"Response: \" + content . Split ( '\\n' ) [ 0 ] + \"\\n\" ); return ( Response ) this . GetLog (); } ; } 六、查看DynamicDictionary DynamicDictionary 类似字典，但功能更多.从请求中获取的值都保存到它里面。可以使用属性或者index来使用捕获的值。 Get[\"/hello/{name}\"] = parameters => { return \"Hello \" + parameters.name; }; Get[\"/goodbye/{name}\"] = parameters => { return \"Goodbye \" + parameters[\"name\"]; }; 存储的值可以显示或者隐式的转换为基础类型或者特殊属性.使用 HasValue 决定是否被赋值。值已经实现了 IEquatable<> 和 IConvertible 接口。 七、module的before/after钩子 除了为特定的路由定义处理程序,module还可以拦截匹配某个路由的请求,请求前后都能做到。重要的是要理解,只有传入的请求匹配模块的路由之一，这些拦截器才会被调用。 1. 在路由被调用前拦截请求 Before拦截器能让你修改请求，甚至可以通过返回一个response来放弃请求。 Before += ctx => { return <null or a Response object>; }; 定义Before拦截器的语法与定义路由有些不同。因为它是定义在module上，被所有路由调用，所以不需要匹配模式。 传给拦截器的是当前请求的NancyContext实例。 最后的不同就是拦截器的返回值，如果返回 null ，拦截器将主动权转给路由；如果返回 Response 对象，则路由不起作用。 2. After拦截器 与定义Before烂机器相同，但是没有返回值。 After += ctx => { // Modify ctx.Response }; Before拦截器可以修改Request，相应的，After拦截器可以修改Response。 八、Application的Before,After和OnError管道 应用管道能在所有的路由上执行，是全局性的。 1.Before拦截 应用级的 Before 钩子通过 Func<NancyContext, Response> 函数定义： pipelines.BeforeRequest += (ctx) => { return <null or a Response object>; }; 异步版本的： pipelines.BeforeRequest += async (ctx, token) => { return <null or a Response object>; }; 2. After拦截 After拦截器通过`Action 定义： pipelines.AfterRequest += (ctx) => { // Modify ctx.Response }; 3. 错误拦截器 OnError 拦截器用来拦截路由发生的错误。通过它可以获取 NancyContext 和发生的异常。 OnError 拦截器通过 Func<NancyContext, Exception, Response> 函数定义： pipelines.OnError += (ctx, ex) => { return null; }; System.AggregateExceptions在OnError管道中的注意事项： 路由是通过许多嵌套的Task( System.Threading.Tasks.Task )来执行的。如果那个任务出现了问题，异常会被包装到 System.AggregateException 。 System.AggregateException 可以持有任意个异常。 如果只有一个异常，Nancy会解包异常并且交给 OnError 管道。如果发生多个异常，Nancy会使用 System.AggregateException ，以避免吞异常。 4. 构建自己的钩子 在 Bootstrapper 中创建系统级的钩子.可以在 ApplicationStartup 或者 RequestStartup 方法中定义它们。这是因为也许你需要在钩子中使用容器中的一些东西。两个方法的不同之处在于范围不同。 protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines) { } protected override void RequestStartup(TinyIoCContainer requestContainer, IPipelines pipelines, NancyContext context) { } 通过使用 pipelines 中适当的属性来创建钩子。它允许你获取 BeforeRequest , AfterRequest 和 OnError 属性。 九、模型绑定 发送数据给Nancy可以有多种方法，比如Query String, 路由捕获参数、请求体request body。手工处理这些不同的方法也可以，但是还有一种方法就是统一处理，绑定到 model 。 Nancy只用一行代码就能处理上述的所有情况，并且能接受 JSON 和 XML 形式的请求。 也可以扩展Nancy的模型绑定。 Nancy的模型绑定在 NancyModule 中被定义为一个单独的扩展方法。该扩展在 Nancy.ModelBinding 命名空间里，并且添加了Bind()和BindTo()方法 Foo f = this.Bind(); var f = this.Bind<Foo>(); var f = this.BindTo(instance); 上面3个有着相同的功能，他们提供了做同一事物的不同方法。前两个使用Bind()重载来创建 Foo 类型的实例，并且绑定；BindTo()则绑定到现有实例。 1. 屏蔽不想要的信息 var f = this.Bind<Foo>(f => f.id, f => f.creator, f => f.createddate); 或者 var f = this.Bind<Foo>(\"id\", \"creator\", \"createddate\"); 当绑定到到arrary, list或者ienumerable时，屏蔽的是序列中的元素。 2. 绑定配置 使用 BindingConfig 实例来修改model binder的默认行为。 下面是 BindingConfig 提供的一些配置项： 属性 描述 默认 BodyOnly 是否只绑定request body。这种情况下，request和context参数都不会被绑定。如果没有body并且没有选项，那么绑定就不会放生 false IgnoreErrors 是否忽略绑定错误并且继续下一个属性 false Overwrite 丙丁是否可以覆盖没有默认值的属性 true 不准Overwrite还有一个快捷方法： BindingConfig.NoOverwrite 3. 反序列化rich request body payloads(负载) 有时你像在请求中发送结构化的数据，比如 JSON 或者 XML ，并且绑定到模型。模型绑定器支持这种反序列化。 Nancy支持两种反序列化：JSON和XML。绑定器根据Http的 Content-type 头来决定使用哪一种反序列化。 默认使用JSON反序列化来处理 application/json , text/json 和 application/vnd....+json 。同样的使用XML反序列化来处理 application/xml , text/xml 和 application/vnd....+xml 对于其他模型绑定器，你可以使用自己的反序列化，并且Nancy会自动检测他们，任何用户定义的绑定器的优先级都高于内建的。 注意： 如果你使用Nancy.Json.JsonSetting.MaxJsonLength Exceeded错误，那是因为你的payloads太高了，在Bootstrapper中更改限制： ApplicationStartup 中设置 Nancy.Json.JsonSettings.MaxJsonLength=int.MaxValue 4. 模型绑定Checkbox 要绑定复选框到bool值，确定设置 value=true ： < input type = \"checkbox\" name = \"rememberMe\" value = \"true\" /> public class LoginModel { public bool RememberMe { get; set; } } 5. 绑定到list 5.1 绑定arrary到单独的对象 如果有一个form: < form action = \"/ArrayOnObject\" method = \"post\" > < input type = \"text\" name = \"Tags\" value = \"Tag1,Tag2,Tag3\" /> < input type = \"text\" name = \"Ints\" value = \"1,2,3,4,4,5,6,3,2,21,1\" /> < input type = \"submit\" value = \"Submit\" /> </ form > 而且有一个类： public class Posts { public string[] Tags { get; set; } public int[] Ints { get; set; } } 使用一个简单的语句： var listOfPosts = this.Bind<Posts>(); 5.2 绑定到对象的list < form action = \"/SimpleListDemo\" method = \"post\" > User 1: < input type = \"text\" name = \"Name[0]\" value = \"thecodejunkie\" /> Commits < input type = \"text\" name = \"Commits[0]\" value = \"1068\" /> < br /> User 2: < input type = \"text\" name = \"Name[1]\" value = \"grumpydev\" /> Commits < input type = \"text\" name = \"Commits[1]\" value = \"1049\" /> < br /> User 3: < input type = \"text\" name = \"Name[2]\" value = \"jchannon\" /> Commits < input type = \"text\" name = \"Commits[2]\" value = \"109\" /> < br /> User 4: < input type = \"text\" name = \"Name[3]\" value = \"prabirshrestha\" /> Commits < input type = \"text\" name = \"Commits[3]\" value = \"75\" /> < br /> User 5: < input type = \"text\" name = \"Name[4]\" value = \"phillip-haydon\" /> Commits < input type = \"text\" name = \"Commits[4]\" value = \"40\" /> < br /> < input type = \"submit\" value = \"Test the binding thingy\" /> </ form > 可以使用 this.Bind<List<User>>(); 来绑定对象列表： public class User { public string Name { get; set; } public int Commits { get; set; } } 5.3 HTML form中的List分隔符 两种分隔符 下划线( Name_1 , Name_2 等) 括号( Name[1] , Name[2] 等) 十、Bootstrapper bootstrapper负责自动发现模型、自定义模型绑定、依赖等等。可以被替换掉。 1. 简单的修改bootstrapper public class CustomBootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoCContainer container, IPipelines pipelines) { // your customization goes here } } 2. 找到合适的bootstrapper 应用启动时，它会寻找自定义的bootstrap，如果没有找到，则使用 DefaultNancyBootstrap 。每个应用只能有 一个 bootstrapper. 如果有多个，则Nancy寻找最底层的bootstrapper。 3. 使用自动注册 注入自己的依赖到NancyModule中 public class Home : NancyModule { public Home(IMessageService service) { //If there is only one implementation of IMessageService in the application, // TinyIoC will resolve the dependency on its own and inject it in the module. } } 十一、视图引擎 视图引擎就是输入\"模板\"和\"模型\"，输出HTML（大部分情况下）到浏览器。 Nancy默认使用 SuperSimpleViewEngine 。它支持一些必要的功能：layout布局、partials部分、models模型、conditions条件和iterations循环。你可以使用这个而不无需其他依赖。它支持 .html 和 .sshtml 文件。 @Master['MasterPage'] @Section['Content'] < p > This content from the index page < p > < h3 > Partials </ h3 > < p > Login box below rendered via a partial view with no model. </ p > < div id = \"login\" > @Partial['login']; </ div > < p > Box below is rendered via a partial with a sub-model passed in. </ p > < p > The submodel is a list which the partial iterates over with Each </ p > < div id = \"users\" > @Partial['user', Model.Users]; </ div > < h3 > Encoding </ h3 > < p > Model output can also be encoded: </ p > < p > @!Model.NaughtyStuff </ p > @EndSection 除此之外，Nancy还支持Razor, Spark, NDjango和dotLiquid引擎。通过添加引用，Nancy会自动的根据文件后缀名调用对应的引擎。 1. 在路由中渲染视图 Get[\"/products\"] = parameters => { return View[\"products.html\", someModel]; }; 模板说明： 1. 视图文件名: \"products.html\" 2. 如果没有后缀，而且有多个同名模板，则会收到 AmbigiousViewsException 错误。 3. 一个相对于跟的路径(比如： products/products.html ) 更多参见 视图位置约定 2.从模型中解析视图的名称 如果值传递给View一个模型，Nancy会用模型名（去掉\"Model\"后缀）作为视图名。 Get[\"/products\"] = parameters => { return View[new ProductsModel()]; }; 如果找不到，就会报406 Not Acceptable. 十二、超简单视图引擎 SSVE基于正则，支持 sshtml , html , html 文件后缀。 模型可以是标准类型，或者 ExpandoObjects （或者实现了 IDynamicMetaObjectProvider 实现了 IDictionary<string, object> 的对象）。 所有的命令都可以有分号，但不是必须的。 [.Parameters] 这样的参数可以使任意层级的，比如 This.Property.That.Property 。 注意：所有引号都是_单引号_. 1. 标准变量替换 如果变量不能替换，则使用 [Err!] 替换。 语法： @Model[.Parameters] 例子： Hello @Model.Name, your age is @Model.User.Age 2. 循环 循环不能嵌套 语法： @Each[.Parameters] [@Current[.Parameters]] @EndEach @Each 表示循环； @Current 表示当前变量，使用方法同 @Model 。 例子： @Each.Users Hello @Current.Name! @EndEach 3. 条件 参数必须是bool，或能隐式转化。嵌套的@If @IfNot不支持。 语法： @If[Not].Parameters [contents] @EndIf 例子： @IfNot.HasUsers No users found! @EndIf 4. 隐式条件 如果module实现了 ICollection ，那你就能使用隐式转换。使用 Has 前缀。 语法： Has[CollectionPropertyName] 例子： @If.HasUsers Users found! @EndIf 5. HTML编码 @Model 和 @Current 都可以有一个 ! ，用来编码HTML： 语法： @!Model[.Parameter] @!Current[.Parameter] 例子： @!Model.Test @Each @!Current.Test @EndEach 6. 部分Patials 语法： @Partial['<view name>'[, Model.Property]] 例子： // Renders the partial view with the same model as the parent @Partial['subview.sshtml']; // Renders the partial view using the User as the model @Partial['subview.sshtml', Model.User]; 7. Master页和section 可以声明master页和节。不必为每个节提供内容。Master能用 @Module ，并且扩展名可以省略。 可以多次使用 @Section 语法 @Master['<name>'] @Section['<name>'] @EndSection 例子： // master.sshtml <html> <body> @Section['Content']; </body> </html> // index.sshtml @Master['master.sshtml'] @Section['Content'] This is content on the index page @EndSection 8. 防止伪造token 防止CSRF 语法： @AntiForgeryToken 例子： @AntiForgeryToken 9. 路径扩展 扩展相对路径为整体路径。 语法： @Path['<relative-path>'] 例子： @Path['~/relative/url/image.png'] 10. 扩展SSVE 十二、Razor引擎 这个Razor引擎跟ASP.NET MVC的有点不一样。 注意，Nancy仍然绑定模型到 @Model ，而不是ASP.NET中的 @model 1. 安装Razor 只需要添加 Nancy.ViewEngines.Razor.dll （使用nuget安装 Nancy.ViewEngines.Razor ）。然后试图模板以 cshtml 或 vbhtml 结尾即可。 2. 配置Razor 十三、实现自己的视图引擎需要注意的地方 十四、视图位置约定 1. 查看默认约定 视图位置的约定通过 Func<string, dynamic, ViewLocationContext, string> 方法以及下面的一些默认约定来定义。 1.1 根约定 (viewName, model, viewLocationContext) => { return viewName; } 这个约定会在根目录里寻找视图。但是如果视图包含一个相对路径，视图名称执行对应于根路径的路径。比如，视图 admin/index 会在 admin/index 目下寻找视图。 1.2 视图文件夹约定 (viewName, model, viewLocationContext) => { return string.Concat(\"views/\", viewName); } 很简单，视图 admin/index 会在 views/admin/index 下查找对应的视图。 1.3 视图和模块路径约定 (viewName, model, viewLocationContext) => { return string.Concat(\"views/\", viewLocationContext.ModulePath, \"/\", viewName); } 对于模块products的视图 admin/index ，会在 views/products/admin/index 中查找视图。 1.4 模块路径约定 (viewName, model, viewLocationContext) => { return string.Concat(viewLocationContext.ModulePath, \"/\", viewName); } 这个约定会在与模块名相同的文件夹中查找视图。 1.5 模块名称约定 (viewName, model, viewLocationContext) => { return string.Concat(viewLocationContext.ModuleName, \"/\", viewName); } 查找以模块名为前缀的对应视图。 1.6 视图模块名称约定 (viewName, model, viewLocationContext) => { return string.Concat(\"views/\", viewLocationContext.ModuleName, \"/\", viewName); } 查找views文件夹下以模块名为前缀的对应视图。 2. 从模型类型推断是退名 如果没有提供视图名而只提供了视图，那么： Customer 类型的模型-> Customer 视图名 CustomerModel 类型的模型-> Customer 视图名 3. 自定义约定 自定义一个bootstrapper，然后添加约定到 Conventions.ViewLocationConventions 集合。 比如： public class CustomConventionsBootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoCContainer container, Nancy.Bootstrapper.IPipelines pipelines) { this.Conventions.ViewLocationConventions.Add((viewName, model, context) => { return string.Concat(\"custom/\", viewName); }); } } 比如这个会查找custom文件夹下的视图名称。 ViewLocationConventions 是一个标准的列表，可以进行修改。 3. 使用IConventions定义自己的约定 你也可以实现 IConvention 接口，并在 Initialise 方法中添加约定到 ViewLocationConventions 属性中。 Nancy会定位所有接口的实现，并且执行约定，这些发生在他们被传递给bootstrapper的 ConfigureConventions 方法之前。 十五、本地化 Nancy内建了本地化。有一系列的 约定 描述了如何决定当前文化，还有一些根据文化选择视图的 约定 。 所以，对于 de-DE 的文化他会寻找 Home-de-DE 的视图。 不仅如此，还会有rese文件，比如 Text.resx ， Text.de-DE.resx （可以被 重写 ). Razor本地化的 例子 十六、测试应用 使用 NuGet 来安装 Nancy.Testing 。 测试应当与主应用分开。 为了测试路由，使用helper类 Browser 。使用bootstrap实例化Browser。 [Fact] public void Should_return_status_ok_when_route_exists() { // Given var bootstrapper = new DefaultNancyBootstrapper(); var browser = new Browser(bootstrapper); // When var result = browser.Get(\"/\", with => { with.HttpRequest(); }); // Then Assert.Equal(HttpStatusCode.OK, result.StatusCode) ; } 十七、根路径 Nancy通过 IRootPathProvider 接口的唯一方法 GetRootPath 来确定根路径。 1. 改变跟路径 改变根路径需要做两件事： 首先，自定义一个类实现 IRootPathProvider ： public class CustomRootPathProvider : IRootPathProvider { public string GetRootPath() { return \"What ever path you want to use as your application root\"; } } 注意，根路径是绝对路径。 其次，在自定义的Bootstrapper中重写 RootPathProvider 属性。 public class CustomBootstrapper : DefaultNancyBootstrapper { protected override IRootPathProvider RootPathProvider { get { return new CustomRootPathProvider(); } } } 2. 上传文件 在Nancy中要上传文件，你需要接受上传文件的content stream, 在磁盘上创建文件，并将stream写入到磁盘。 var uploadDirectory = Path.Combine(pathProvider.GetRootPath(), \"Content\", \"uploads\"); if (!Directory.Exists(uploadDirectory)) { Directory.CreateDirectory(uploadDirectory); } foreach (var file in Request.Files) { var filename = Path.Combine(uploadDirectory, file.Name); using (FileStream fileStream = new FileStream(filename, FileMode.Create)) { file.Value.CopyTo(fileStream); } } 上例中的 pathProvider 是在模块的构造函数中传递进来的，通过它的 GetRootPath() 来获取跟路径。 public HomeModule(IRootPathProvider pathProvider) 十八、管理静态内容 简而言之：把东西都放到 /Content 文件夹内，仅此而已 十九、诊断 Nancy自带诊断功能： http://<address-of-your-application>/_Nancy/ 1. 配置到dashboard的访问 添加密码： public class CustomBootstrapper : DefaultNancyBootstrapper { protected override DiagnosticsConfiguration DiagnosticsConfiguration { get { return new DiagnosticsConfiguration { Password = @\"A2 \\6 mVtH/XRT\\p,B\" }; } } } 2. 去除诊断 public class CustomBootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoc.TinyIoCContainer container, IPipelines pipelines) { DiagnosticsHook.Disable(pipelines); } } 3. 有哪些工具呢？ Information , Interactive Diagnostics , Request Tracing , Configuration 3.1 信息 3.2 配置 Nancy中 StaticConfiguration 可以用来配置程序的行为，配置页面提供了配置方法。 注意，系统重启后配置页面的内容失效。 要想永久保存配置，请在bootstrapper的 ApplicationStartup 中设置。 3.3 请求跟踪 请求跟踪因为性能原因默认关闭，可以再 Configuration 页开启，也可以这样： public class CustomBootstrapper : DefaultNancyBootstrapper { protected override void ApplicationStartup(TinyIoC.TinyIoCContainer container, IPipelines pipelines) { StaticConfiguration.EnableRequestTracing = true; } } 跟踪日志可以通过 NancyContext 中得到。和容易添加自己的内容： public class HomeModule : NancyModule { public HomeModule() { Get[\"/\"] = parameters => { this.Context.Trace.TraceLog.WriteLog(s => s.AppendLine(\"Root path was called\")); return HttpStatusCode.Ok; }; } } WriteLog 方法是用一个接受 StringBuilder 的函数是为了调试关闭时直接不调用函数，从而避免性能损耗。 3.4 交互式的诊断 只要实现了 IDiagnosticsProvider 接口，Nancy诊断会自动发现它，并且把它暴露给交互工具。 （1）IDiagnosticsProvider接口 /// <summary> /// Defines the functionality a diagnostics provider. /// </summary> public interface IDiagnosticsProvider { /// <summary> /// Gets the name of the provider. /// </summary> /// <value> A <see cref= \"string\" /> containing the name of the provider. </value> string Name { get; } /// <summary> /// Gets the description of the provider. /// </summary> /// <value> A <see cref= \"string\" /> containing the description of the provider. </value> string Description { get; } /// <summary> /// Gets the object that contains the interactive diagnostics methods. /// </summary> /// <value> An instance of the interactive diagnostics object. </value> object DiagnosticObject { get; } } （2）可诊断的对象 任何公共方法都会暴露给交互诊断面板。方法可以是能被JSON序列化的任意类型。类型的返回值会被返回成 JSON Report Format （3）提供描述给方法 两种方法： 1、使用attribute: Nancy.Diagnostics.DescriptionAttribute 2、使用property：使用与方法同名但添加了 Description 后缀的属性，比如 NameOfYourMethodDescription 描述了 NameOfYourMethod 方法。 （4）自定义模板输出 （5）创建诊断提供者 二十、添加自己的favicon 1. 替换默认的FavIcon 在应用中防止一个_favicon_的文件，名称以 .icon 或 .png 结尾即可。 2. 使用内嵌icon 在Bootstrapper中重写 FavIcon 属性： public class Bootstrapper : DefaultNancyBootstrapper { private byte[] favicon; protected override byte[] FavIcon { get { return this.favicon?? (this.favicon= LoadFavIcon()); } } private byte[] LoadFavIcon() { //TODO: remember to replace 'AssemblyName' with the prefix of the resource using (var resourceStream = GetType().Assembly.GetManifestResourceStream(\"AssemblyName.favicon.ico\")) { var tempFavicon = new byte[resourceStream.Length]; resourceStream.Read(tempFavicon, 0, (int)resourceStream.Length); return tempFavicon; } } } 3. 移除ICON 设置Bootstrapper的 FavIcon 属性为 null 。 二十一、添加自定义的错误页面 第一篇:http://mike-ward.net/blog/post/00824/custom-error-pages-in-nancyfx 第二篇：https://blog.tommyparnell.com/custom-error-pages-in-nancy/ 二十二、加密帮助方法 命名空间: Nancy.Cryptography 1. IEncryptionProvider 接口 /// <summary> /// Provides symmetrical encryption support /// </summary> public interface IEncryptionProvider { /// <summary> /// Encrypt and base64 encode the string /// </summary> /// <param name= \"data\" > Data to encrypt </param> /// <returns> Encrypted string </returns> string Encrypt(string data); /// <summary> /// Decrypt string /// </summary> /// <param name= \"data\" > Data to decrypt </param> /// <returns> Decrypted string </returns> string Decrypt(string data); } Nancy提供了两个默认实现 NoEncryptionProvider :没有加密，仅仅是base64 RijndaelEncryptionProvider : 使用Rijndael算法，使用256位的key和128为的初始向量，加密base64字符串。 2. IHmacProvider 接口 用来签名，防止篡改。 /// <summary> /// Creates Hash-based Message Authentication Codes (HMACs) /// </summary> public interface IHmacProvider { /// <summary> /// Gets the length of the HMAC signature in bytes /// </summary> int HmacLength { get; } /// <summary> /// Create a hmac from the given data /// </summary> /// <param name= \"data\" > Data to create hmac from </param> /// <returns> Hmac bytes </returns> byte[] GenerateHmac(string data); /// <summary> /// Create a hmac from the given data /// </summary> /// <param name= \"data\" > Data to create hmac from </param> /// <returns> Hmac bytes </returns> byte[] GenerateHmac(byte[] data); } Nancy也提供了一个默认实现： DefaultHmacProvider ，使用 IKeyGenerator 来产生一个key来用SHA-256来进行hash。 3. IKeyGenerator 接口 用来产生key来加密和数字签名。 /// <summary> /// Provides key byte generation /// </summary> public interface IKeyGenerator { /// <summary> /// Generate a sequence of bytes /// </summary> /// <param name= \"count\" > Number of bytes to return </param> /// <returns> Array <see cref= \"count\" /> bytes </returns> byte[] GetBytes(int count); } Nancy提供了两个默认实现。 RandomKeyGenerator 使用 RNGCryptoServiceProvider 产生了一个随机定长的key PassphraseKeyGenerator 使用密码、静态盐以及可选循环数字，以及 Rfc2898DeriveBytes 来产生一个key 注意 ，如果使用 PassphraseKeyGenerator ，它的初始化应当在应用启动时使用，因为它太慢了。这意味着盐是静态的，因此密码一定要足够长和复杂。 4. 加密配置类型CryptographyConfiguration 这是一个存储 IEncryptionProvider 和 IHmacProvider 的简便方法。它有两个静态属性： Default 使用 RijndaelEncryptionProvider 和 DefaultHmacProvider ，两个都使用 RandomKeyGenerator 。 NoEncryption 使用 NoEncryption 和 DefaultHmacProvider ，两个也都使用 RandomKeyGenerator . 可以单独使用 CryptographyConfiguration ，也可以在bootstrapper中配置一个： /// <summary> /// Gets the cryptography configuration /// </summary> protected virtual CryptographyConfiguration CryptographyConfiguration { get { return CryptographyConfiguration.Default; } } 二十三、Content negotiation(内容协商) 当返回不是 Response 类型时，使用response processor来根据请求的 Accept 来处理。 1. Response Processor public interface IResponseProcessor { /// <summary> /// Gets a set of mappings that map a given extension (such as .json) /// to a media range that can be sent to the client in a vary header. /// </summary> IEnumerable <Tuple <string, MediaRange > > ExtensionMappings { get; } /// <summary> /// Determines whether the the processor can handle a given content type and model. /// </summary> ProcessorMatch CanProcess(MediaRange requestedMediaRange, dynamic model, NancyContext context); /// <summary> /// Process the response. /// </summary> Response Process(MediaRange requestedMediaRange, dynamic model, NancyContext context); } Response Processor是自发现的，也可以在Bootstrap中配置。 public class Bootstrapper : DefaultNancyBootstrapper { protected override NancyInternalConfiguration InternalConfiguration { get { var processors = new[] { typeof(SomeProcessor), typeof(AnotherProcessor) }; return NancyInternalConfiguration.WithOverrides(x => x.ResponseProcessors = processors); } } } 1.1 匹配优先级 当相应准备转化请求媒体的格式时，Nancy会查询所有的processor的 CanProcess 方法，并且会聚合 ProcessorMatch 的返回值。 ProcessorMatch 类型确保每个processor让Nancy知道它们对媒体类型的支持程度。 public class ProcessorMatch { /// <summary> /// Gets or sets the match result based on the content type /// </summary> public MatchResult RequestedContentTypeResult { get; set; } /// <summary> /// Gets or sets the match result based on the model /// </summary> public MatchResult ModelResult { get; set; } } MatchResult 枚举了匹配程度： public enum MatchResult { /// <summary> /// No match, nothing to see here, move along /// </summary> NoMatch, /// <summary> /// Will accept anything /// </summary> DontCare, /// <summary> /// Matched, but in a non-specific way such as a wildcard match or fallback /// </summary> NonExactMatch, /// <summary> /// Exact specific match /// </summary> ExactMatch } 所有的 ProcessorMatch 会按照Match程度降序排列，最匹配的被执行。如果有两个匹配程度相同，Nancy会选择其中一个。 1.2 默认响应处理器 Nancy提供了一些默认响应处理器 JsonProcessor - 当请求类型为 application/json 或者 application/vnd.foobar+json 时，转化返回值为json； ViewProcessor - 当请求类型为 text/html 时，使用返回值作为model，返回视图。视图使用 视图位置约定 ； XmlProcessor - 当请求为 application/xml 或者为 application/vnd.foobar+xml 时，返回xml。 2. 控制协商 Nancy.Responses.Negotiation 命名空间中的 Negotiator 用来控制协商。 Negotiator 有一个属性： NegotiationContext . NegotiationContext 可以用来控制响应的协商。 但是一般不会直接使用 Negotiator 和 NegotiationContext ，因为 NancyModule 包含了一个帮助方法 Negotiate ，用来更好的创造 Negotiator 实例。 在路由中使用 Negotiator 的例子： Get[\"/\"] = parameters => { return Negotiate .WithModel(new RatPack {FirstName = \"Nancy \"}) .WithMediaRangeModel(\"text/html\", new RatPack {FirstName = \"Nancy fancy pants\"}) .WithView(\"negotiatedview\") .WithHeader(\"X-Custom\", \"SomeValue\"); }; Negotiator 包含了用来配置返回 Negotiator 实例的一些方法。 WithHeader - 添加一个Http头； WithHeaders - 添加一个Http的头集合； WithView - 使用视图； WithModel - 使用模型； WithMediaRangeModel - 使用特定的媒体类型和模型，如果失败了，就使用 WithModel 指定的模型； WithFullNegotiation - 设置允许媒体类型为 */* 的帮助方法； WithAllowedMediaRange - 指定允许的媒体范围。默认是\"/\",但是一旦指定一个特定的内容类型，通配符就会被移走。 WithStatusCode - 状态码 3. 支持文件扩展名 Nancy支持基于扩展名来设置协商的处理，此时传递正常的可接受的头。 例子： Get[\"/ratpack\"] = parameters => { return new RatPack {FirstName = \"Nancy \"}); }; 它既可以通过 /ratpack 和设置的 application/json 头来调用，也可以使用 /ratpack.json 并且不设置 application/json 来调用，两个结果一样。 内部Nancy是通过检测扩展名，并查询可用的响应处理器的 ExtensionMappings 属性来查看是否有支持的扩展。如果有，就调用并且设置对应的头信息，但是如果有更优先的处理器，则用更优先的处理器，除非更优先的处理器失败了，才会使用扩展。 4. 强制可接受的头(Accept Header) 约定的格式： Func< IEnumerable<Tuple<string, decimal>>, NancyContext, IEnumerable<Tuple<string, decimal>>> 这个函数接受 NancyContext 和当前头，并且期望你返回修改后的可接受头列表。 默认情况下，Nancy在 Nancy.Conventions.BuiltInAcceptHeaderCoercions class 中提供了如下约定，其中加*的表示是默认默认被转换的： BoostHtml (*) - 如果text/html的优先级低于其他内容类型，则提高优先级； CoerceBlankAcceptHeader (*) - 如果没有指定请求头，就分配一个默认的； CoerceStupidBrowsers - 对于老浏览器，替换请求头，即使它们说是请求xml还是返回html。 更改哪一个强制起作用时在bootstrapper中的 ConfigureConventions 来设置的： public class Bootstrapper : DefaultNancyBootstrapper { protected override void ConfigureConventions(NancyConventions nancyConventions) { base.ConfigureConventions(nancyConventions); this.Conventions.AcceptHeaderCoercionConventions.Add((acceptHeaders, ctx) => { // Modify the acceptHeaders by adding, removing or updating the current // values. return acceptHeaders; }); } } 当然你也可以继承你自己的bootstrapper。 5. 使用IConventions来定义自己的约定 可以通过实现 IConventions 接口来创造一个类，并在它的 Initialise 方法中添加自己的约定到传递进来的参数的 AcceptHeaderCoercionConventions 属性中。 在所有的接口被传递给bootstrapper的 ConfigureConventions 的方法之前，Nancy会定位所有的接口实现，并且激发这些约定。 6. 自动协商头 Nancy会自动添加链接和各种各样的头到协商响应中。链接头链接。连接头会连接到根据文件扩展来的其他代表中。 7. 更多信息 Nancy and Content Negotiation Revisting Content Negotiation and APIs part 1 Revisting Content Negotiation and APIs part 2 Revisting Content Negotiation and APIs part 3 二十四、使用转换器来扩展序列化 二十五、授权 Nancy中的验证使用扩展点：比如应用管道、模块管道、 NancyContext 和其他的一些扩展方法。所以你可以写自己的验证来替换默认提供的验证。 Nancy提供了以下几种验证，通过Nuget安装： 表单( Nancy.Authentication.Forms ) 基本( Nancy.Authentication.Basic ) 无状态( Nancy.Authentication.Stateless ) 1. 了解用户 Nancy中用户使用 IUserIdentity 接口代表，它提供了一些用户的基本信息： public interface IUserIdentity { /// <summary> /// Gets or sets the name of the current user. /// </summary> string UserName { get; set; } /// <summary> /// Gets or set the claims of the current user. /// </summary> IEnumerable <string> Claims { get; set; } } 你应当提供基于自己应用需求的类来实现自己的用户接口。 要获得当前用户，只需要获取 NancyContext 的 CurrentUser 属性。返回 null 值表明当前请求未认证，其他的则表示已认证。 context在Nancy的大部分地方都能获取，所以不必担心能否获取当前请求的用户身份。 2. 保护你的资源 可以在模块级和应用级来保护资源，方法是检测 NancyContext.CurrentUser 属性不为null。 这个任务可以通过在 模块管道 的 Before 中实现。这个钩子允许我们终结当前请求的执行，返回其它资源，比如当未验证用户视图访问安全资源时： public class SecureModule : NancyModule { public SecureModule() { Before += ctx => { return (this.Context.CurrentUser == null) ? new HtmlResponse(HttpStatusCode.Unauthorized) : null; }; // Your routes here } } 在每个模块上添加安全代码违反了DRY原则，更是一个无聊的任务。使用扩展方法！ Nancy有一些扩展方法包装了这些任务，彻底的减少了要写的代码量。 下面是一些可用的扩展方法： RequiresAuthentication - 确保验证用户是可用的，或者返回 HttpStatusCode.Unauthorized . 对于认证的用户， CurrentUser 不能为 null ，而且 UserName 不能为空； RequiresClaims - 用户必须满足声明列表中所有的条件才能获取资源； RequiresAnyClaim - 见上一条，但是只需满足任意一条； RequiresValidatedClaims - 通过自定义函数，来全部自我掌控验证流程，函数格式 Func<IEnumerable<string>, bool> ； RequiresHttps - 只允许https访问； 这些都是 NancyModule 类的扩展方法，要使用它们需要添加 Nancy.Security 命名空间。 使用扩展方法，前面的例子可以这样写： public class SecureModule : NancyModule { public SecureModule() { this.RequiresAuthentication(); } // Your routes here } 当然还可以这样写： public class SecureModule : NancyModule { public SecureModule() { this.RequiresHttps(); this.RequiresAuthentication(); this.RequiresClaims(new [] { \"Admin\" }); } // Your routes here } 用户必须通过https，被授权，而且拥有Admin claim才能访问上面的路由。 3. 创造你自己的安全扩展 为了创造自己的安全扩展，你只需要添加扩展方法到 NancyModule ，并且绑定到 Before 管道，并检查证书。 比如，下面说明了 RequiresAuthentication 如何工作的： public static class ModuleSecurity { public static void RequiresAuthentication(this NancyModule module) { module.Before.AddItemToEndOfPipeline(RequiresAuthentication); } private static Response RequiresAuthentication(NancyContext context) { Response response = null; if ((context.CurrentUser == null) || String.IsNullOrWhiteSpace(context.CurrentUser.UserName)) { response = new Response { StatusCode = HttpStatusCode.Unauthorized }; } return response; } } 4. 实现自己的验证provider 实际的验证provider实现根据不同的需求变化很大，但是基本模式如下： 应用管道 的 Before 钩子用来检查请求的证书（比如cookie, headers等等）。如果发现证书，则验证用户并授权给 NancyContext 的 CurrentUser 属性。 模块管道 的 Before 钩子用来确认当前的请求是被认证的用户执行，如果不是，则拒绝并返回 HttpStatusCode.Unauthorized 应用管道 的 After 钩子用来检查请求是否因为认证失败而被丢弃，比如检查 HttpStatusCode.Unauthorized (401)状态码。如果检测到了就帮助用户去认证，比如重定向到login表单或者使用header的帮助通知客户端。 5. 无状态认证 无状态认证就是在每个请求中进行检查，根据请求的一些信息，来决定是否应该被确认为一个已认证的请求。 比如你检查请求来确认查询字符串的参数是否传递了api key，或者是否包含某些head， 有或者请求是否来自某些特定的ip。 使用无状态认证需要做下面几件事： 1. 安装 Nancy.Authentication.Stateless 包 2. 配置并开启无状态认证 3. 保护资源 5.1 配置并开启无状态认证 在bootstrapper中添加： StatelessAuthentication.Enable(pipelines, statelessAuthConfiguration); 被传递到 StatelessAuthentication.Enable 方法中的 statelessAuthConfiguration 变量，是一个 StatelessAuthenticationConfiguration 类型的实例，它能够让你自定义无状态认证提供者的行为。 定义 StatelessAuthenticationConfiguration 类型实例的时候，需要有一个 Func<NancyContext, IUserIdentity> 类型的参数。这个函数用来检查请求或者context中的其他相关内容，并且在请求未通过验证时返回 null ，否则返回合适的 IUserIdentity . 5.2 简单配置 var configuration = new StatelessAuthenticationConfiguration(ctx => { if (!ctx.Request.Query.apikey.HasValue) { return null; } // This would where you authenticated the request. IUserApiMapper is // not a Nancy type. var userValidator = container.Resolve<IUserApiMapper>(); return userValidator.GetUserFromAccessToken(ctx.Request.Query.apikey); }); 6. Form认证 详细例子见Nancy解决方案中 Nancy.Demo.Authentication.Forms 例子 为了开启form认证，需要完成： 安装 Nancy.Authentication.Forms 包 实现 IUserMapper 实现路由来处理login和logout 配置并开启Form认证 6.1 User mapper User mapper用来负责从标示符identifier映射到用户。标示符是一个令牌，被存储在认证cookie中，用来代表执行请求的用户身份，避免每次请求时输入证书。 使用GUID来做标示符，如果用username来做标示符容易被嗅探并攻击。GUID还很难读取，而且每个GUID都不一样，增加了嗅探的难度。 注意，需要知道标示符对每个用户来说都是永久的并且是唯一的。 IUserMapper 接口的定义： public interface IUserMapper { /// <summary> /// Get the real username from an identifier /// </summary> /// <param name= \"identifier\" > User identifier </param> /// <param name= \"context\" > The current NancyFx context </param> /// <returns> Matching populated IUserIdentity object, or empty </returns> IUserIdentity GetUserFromIdentifier(Guid identifier, NancyContext context); } 6.2 修改应用，处理form认证 有了 IUserMapper 后，下一步就是在不需要认证的地方添加login和logout了。 下面是一个模块的基础框架。请注意资源的路径和模块的名称可以使任意的： public class LoginModule : NancyModule { public LoginModule() { Get[\"/login\"] = parameters => { // Called when the user visits the login page or is redirected here because // an attempt was made to access a restricted resource. It should return // the view that contains the login form }; Get[\"/logout\"] = parameters => { // Called when the user clicks the sign out button in the application. Should // perform one of the Logout actions (see below) }; Post[\"/login\"] = parameters => { // Called when the user submits the contents of the login form. Should // validate the user based on the posted form data, and perform one of the // Login actions (see below) }; } } Nancy.Authentication.Forms 命名空间中有一些扩展方法可供使用： LoginAndRedirect - 登录用户并重定向用户到他们来时的url。或者也可以提供一个预留的url，用来在没有重定向url时使用。如果使用form提交，注意使用action=\"\"，因为它会保留returnUrl原封不动。 LoginWithoutRedirect - 登录用户，并且返回响应和状态码200(ok) Login 会调用当前请求的 IsAjaxRequest 的扩展方法，并且如果不是Ajax调用，则执行 LoginAndRedirect 方法，否则执行 LoginWithoutRedirect 方法 LogoutAndRedirect - 登出用户，并提供重定向 LogoutWithoutRedirect - 登出用户并返回状态码为200(OK)的响应 Logout 会调用当前请求的 IsAjaxRequest 方法，如果不是ajax请求，则执行 LogoutAndRedirect ，否则执行 LogoutWithoutRedirect 注意1： Nancy.Extensions.RequestExtensions 中的 IsAjaxRequest 扩展方法会检查 X-Requested-With 头，并且在其包含值 XMLHttpRequest 时返回true 注意2： 请确认路径的定义login和logout的页面没有要求使用登录。 6.3 启用form认证 在bootstrapper中添加： FormsAuthentication.Enable(pipelines, formsAuthConfiguration); 既可以在 ApplicationStartup 中又可以在 RequestStartup 中添加。到底在何处加，取决于 IUserMapper ，即user mapper到底是有应用级的生命周期还是请求级的生命周期。 传递给 FormsAuthentication.Enable 方法的 formsAuthConfiguration 变量是 FormsAuthenticationConfiguration 类型，它能让你自定义form认证提供者的行为。 比如，下面是一个基本的认证配置： var formsAuthConfiguration = new FormsAuthenticationConfiguration() { RedirectUrl = \"~/login\", UserMapper = container.Resolve<IUserMapper>(), }; 下面是一些配置项： RedirectingQuerystringKey ：默认名是 returnUrl RedirectingUrl ：未认证的用户应当被重定向的url，一般是登录页面 ~/login UserMapper : IUserMapper 在认证时应该被使用 RequiresSSL : SSL DisableRedirect : 遇到未认证时，是否重定向到登陆页 CryptographyConfiguration : CryptographyConfiguration.Default 与form认证cookie配合使用。 CryptographyConfiguration.Default 是默认的。 6.4 关于加密，还有一些话 默认使用 RandomKeyGenerator ，这意味着每次程序启动时会产生一个新的秘钥，那么应用重启回到这认证cookie失效，在多台机器负载均衡时也会出现这种问题，别怕，看看 加密配置 下面是一个例子： var cryptographyConfiguration = new CryptographyConfiguration( new RijndaelEncryptionProvider(new PassphraseKeyGenerator(\"SuperSecretPass\", new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 })), new DefaultHmacProvider(new PassphraseKeyGenerator(\"UberSuperSecure\", new byte[] { 1, 2, 3, 4, 5, 6, 7, 8 }))); var config = new FormsAuthenticationConfiguration() { CryptographyConfiguration = cryptographyConfiguration, RedirectUrl = \"/login\", UserMapper = container.Resolve<IUserMapper>(), }; 6.5 跟多 Forms authentication with nancyfx Multiple forms authentication sections 7. 令牌认证 详细例子在Nancy解决方案中的 Nancy.Demo.Authentication.Token 中。 7.1 认识Nancy的令牌认证 Nancy令牌认证工程是为了多种客户端(iOS, Android, Angular SPA等等)能与统一后台Nancy应用而创建的。 7.2 基本原理 令牌认证与授权在下面这些需求下应运而生： 没有cookie（不适所有的客户端都是浏览器） 避免一旦用户被认证/授权后，从后端数据存储中取回用户和权限信息 允许客户端应用在第一次授权后保存令牌，以便为后续请求使用 通过单向加密算法确保令牌没有被篡改，阻止嗅探冒充令牌攻击 使用有期限的可配置的key来进行令牌生成 使用server端的文件系统来存储私钥，这样即使应用重启也能恢复。注意：可以使用内存存储作为测试。 7.3 使用 7.3.1 Nancy配置 令牌认证可以像form认证那样： public class Bootstrapper : DefaultNancyBootstrapper { protected override void RequestStartup(TinyIoCContainer container, IPipelines pipelines, NancyContext context) { TokenAuthentication.Enable(pipelines, new TokenAuthenticationConfiguration(container.Resolve<ITokenizer>())); } } 令牌从 IUserIdentity 和 NancyContext 中，通过实现 ITokenizer 接口产生。默认实现是 Tokenizer ，它提供了一些可配置的方法。默认情况下，它产生一个令牌包含下面部分： 用户名 Pipe separated list of user claims UTC当前时间 客户端的\"User-Agent\"头（必须） 建议配置Tokenizer，使用其他附加能代表用户唯一设备的信息。 下面举例说明了如何初始化用户认证，并且返回生成的令牌给客户端： public class AuthModule : NancyModule { public AuthModule(ITokenizer tokenizer) : base(\"/auth\") { Post[\"/\"] = x => { var userName = (string)this.Request.Form.UserName; var password = (string)this.Request.Form.Password; var userIdentity = UserDatabase.ValidateUser(userName, password); if (userIdentity == null) { return HttpStatusCode.Unauthorized; } var token = tokenizer.Tokenize(userIdentity, Context); return new { Token = token, }; }; Get[\"/validation\"] = _ => { this.RequiresAuthentication(); return \"Yay! You are authenticated!\"; }; Get[\"/admin\"] = _ => { this.RequiresClaims(new[] { \"admin\" }); return \"Yay! You are authorized!\"; }; } } 7.3.2 客户端配置 一旦你的客户端接收到了token，那么你必须使用token来设置HTTP头： Authorization : Token { your - token - goes - here } 8. 幕后的工作 https://github.com/NancyFx/Nancy/commit/9ae0a5494bc335c3d940d730ae5d5f18c1018836","tags":"DotNET","url":"/nancy-webkuang-jia.html"},{"title":"Django REST Framework笔记-01 介绍与安装","text":"一、 Django Rest Framework介绍 项目地址：http://www.django-rest-framework.org/ Django REST framewrok（简称DRF），强大而且灵活的工具箱，它使创建Web API变得简单。 你需要使用REST框架的一些原因： 基于Web可浏览的API能让你赢得更多开发者 包含OAuth1a和OAuth2的认证机制 序列化同时支持ORM和非ORM的数据源 自定义，如果不想用更为强大的功能，可以只使用常规的函数视图 大量的文档，牛叉的社区支持 大公司比如Mozilla和Eventbrite都用它，靠谱~ 二、安装需求 REST框架具有以下要求： Python(2.6.5+, 2.7, 3.2, 3.3) Django(1.4.2+, 1.5, 1.6, 1.7) 下面的包是可选的： Markdown (2.1.0+) - 支持可浏览的API PyYAML (3.10+) - 支持YAML的content-type defusedxml (0.3+) - 支持XML的content-type django-filter (0.5.4+) - 支持过滤 django-oauth-plus (2.0+)和 oauth2 (1.5.211+) - 支持OAuth 1.0a django-oauth2-provider (0.2.3+) - 支持OAuth 2.0 django-guardian (1.1.1+) - 支持对象级别的权限控制 注意 : oauth2 包很容易让人误解为OAuth2，其实只支持OAuth 1.0a，并且注意在Python3中OAuth 1.0a和Oauth2.0不能同时存在。 三、安装 1、使用 pip 进行安装，包含那些你想要的可选包： pip install djangorestframework pip install markdown # Markdown support for the browsable API. pip install django-filter # Filtering support 或者从github上克隆： git clone git@github.com:tomchristie/django-rest-framework.git 2、添加 rest_framework 到settings.py的 INSTALLED_APPS INSTALLED_APPS = ( ... 'rest_framework' , ) 3、(可选)如果想要增加可浏览的API，你也将需要添加REST框架的login和logout视图。添加如下行到根 urls.py 文件中。 urlpatterns = patterns ( '' , ... url ( r'&#94;api-auth/' , include ( 'rest_framework.urls' , namespace = 'rest_framework' )) ) 注意 ，URL路径可以是任意的。但是必须使用 'rest_framework' 命名空间来包含 'rest_framework.urls' 四、例子 来看一个用REST框架建立基于model的简单API例子。 我们将创建一个获取获取工程用户信息的读写API。 所有REST框架的全局设置都被保存到一个叫做 REST_FRAMEWORK 的配置字典中。我们在 settings.py 模块中添加下面的内容： REST_FRAMEWORK = { # 使用Django标准的`django.contrib.auth`权限, # 或者对未验证的用户使用只读权限 'DEFAULT_PERMISSION_CLASSES' : [ 'rest_framework.permissions.DjangoModelPermissionsOrAnonReadOnly' ] } 不要忘了在 INSTALLED_APPS 中添加 rest_framework 。 现在我们已经准备好了创建API了。下面是项目的根 urls.py 模块： from django.conf.urls import url , include from django.contrib.auth.models import User from rest_framework import routers , serializers , viewsets # Serializers 定义了如何展示API class UserSerializer ( serializers . HyperlinkedModelSerializer ): class Meta : model = User fields = ( 'url' , 'username' , 'email' , 'is_staff' ) # ViewSets定义了View的行为 class UserViewSet ( viewsets . ModelViewSet ): queryset = User . objects . all () serializer_class = UserSerializer # Routers提供了一种简单的方法来自动决定如何路由 router = routers . DefaultRouter () router . register ( r'users' , UserViewSet ) # 使用自动路由来提供API # 另外，提供了登录查看web API的功能 urlpatterns = [ url ( r'&#94;' , include ( router . urls )), url ( r'&#94;api-auth/' , include ( 'rest_framework.urls' , namespace = 'rest_framework' )) ] 现在可以在浏览器中输入http://127.0.0.1:8000/来打开API了。并且查看你刚创建的'users' API。如果你在右上角点登录，那么现在就应该可以添加、创建和删除用户了。 五、快速开始 迫不及待的想要开始了？ 快速开始 是最快的方法让你能够创建并运行REST API的方法。 六、教程 教程将让你通过REST框架创建每一部分。学习它需要一些时间，但是它会让你对每一部分如何相互匹配在一起邮个全方位的了解，强烈建议读一下。 1-序列化 2-请求和相应 3-基于类的视图 4-认证与权限 5-关系和超链接API 6-视图集合和路由 为了测试，我们提供了一个API教程结束时的例子，在 这里 .","tags":"Python","url":"/django-rest-frameworkbi-ji-01-jie-shao-yu-an-zhuang.html"},{"title":"Android学习笔记-06 Android用户界面之布局","text":"1 Relative Layout 根据子元素来调整位置 2 Framely Layout 一直在左上角，速度快 3 Linear Layout 一个挨着一个排列，可以水平排列，也可以垂直排列。 有一个weight属性，表示子对象分割父级对象分割的比例。 4 Table Layout 最外层是Table Layout，垂直布局 里层是Table Row，水平布局 5 通过应用程序动态的添加子对象 5.1 创建一个Layout文件 <LinearLayout xmlns:android= \"http://schemas.android.com/apk/res/android\" android:orientation= \"vertical\" android:layout_width= \"fill_parent\" android:layout_height= \"fill_parent\" android:id = \"@+id/linear_layout\" > </LinearLayout> 5.2 在Activity中添加 public class MainActivity extends Activity { private Button btn ; private LinearLayout linearLayout ; private View . OnClickListener onClickListern = new View . OnClickListener () { @Override public void onClick ( View v ) { linearLayout . removeView ( v ); } }; /** * Called when the activity is first created. */ @Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); setContentView ( R . layout . main ); linearLayout = ( LinearLayout ) findViewById ( R . id . linear_layout ); for ( int i = 0 ; i < 5 ; i ++){ btn = new Button ( this ); btn . setText ( \"点我\" + i ); btn . setOnClickListener ( onClickListern ); linearLayout . addView ( btn ); } } } 其中，btn是在程序中声明的，Layout的addView方法添加子元素","tags":"Android","url":"/androidxue-xi-bi-ji-06-androidyong-hu-jie-mian-zhi-bu-ju.html"},{"title":"Android学习笔记 - 04 Android四大核心组件之Content Provider","text":"Android学习笔记 - 04 Android四大核心组件之Content Provider 一、概述 Content Provider用于应用之间共享数据，比如读取联系人数据，或者自己应用的数据共享给其它的应用 如果要共享数据，必须指定一个URI 本节主要读取其它应用的数据，这里以联系人数据为例。 二、用法 1、读取联系人，使用查询，返回游标，然后遍历游标 Cursor c = getContentResolver (). query ( ContactsContract . Contacts . CONTENT_URI , null , null , null , null ); while ( c . moveToNext ()){ System . out . println ( \">>>>>>>\" + c . getString ( c . getColumnIndex ( ContactsContract . Contacts . DISPLAY_NAME )) + \"\\t\" + c . getString ( c . getColumnIndex ( ContactsContract . Contacts . PHONETIC_NAME ))); } 2、在AndroidManifest.xml的 节点下添加读取权限： <uses-permission android:name=\"android.permission.READ_CONTACTS\" />","tags":"Android","url":"/androidxue-xi-bi-ji-04-androidsi-da-he-xin-zu-jian-zhi-content-provider.html"},{"title":"Android学习笔记 - 05 Android应用核心之Intent","text":"Android学习笔记 - 05 Android应用核心之Intent 1 Intent IntentFilter对象介绍 Intent是与基本组件相关联的数据对象，每个基本组件都有一个对应的Intent，Intent指定了对应的组件对象。 IntentFilter用来描述一个Intent 1.1 使用Component引用对象 Intent i = new Intent (); i . setComponent ( new ComponentName ( \"liulx.L06Intent\" , \"liulx.L06Intent.Aty1\" )); startActivity ( i ); setComponent 用来设置Component ComponentName 用来通过包名和类名来创建对象 这种使用 ComponentName 的方法创建Acitivity的方法属于 显示创建对象 1.2 使用Action建立对象 1.2.1 创建Action 如果需要使用Action来启动一个Activity的话，需要给这个Activity配置一个 intent-filter ，打开AndroidManifest.xml文件，找到相应的Acitivity，添加 intent-filter 节点： <activity android:name= \".Aty1\" android:label= \"Aty1\" > <intent-filter> <action android:name= \"liulx.L06Intent.intent.action.Aty1\" /> <category android:name= \"android.intent.category.DEFAULT\" /> </intent-filter> </activity> intent-filter 的作用是给Activity添加地址，其中的 action 的名字规则是 包名.intent.action.名称 ，它就是Activity的地址。 一般还需添加一个 category ,使用 DEFAULT 即可。 1.2.2 根据Action来创建对象 在需要创建对象（Activity/Service等)的地方，使用Action来创建： Intent i = new Intent ( \"liulx.L06Intent.intent.action.Aty1\" ); 注意： 与 setComponent 方法不同，通过action创建的方法叫做 隐式创建 ,它不需要知道类的包名和类的全名，只需要知道Action地址就可以了。 2 实例：打开图片 2.1 使用默认图片查看工具打开图片 File f = new File ( \"/storage/sdcard0/001.jpg\" ); Intent i = new Intent ( Intent . ACTION_VIEW ); i . setDataAndType ( Uri . fromFile ( f ), \"image/*\" ); startActivity ( i ); 2.2 使用自己的Activity打开图片 首先，创建一个Activity,并且，它设置对应的AndroidManifest.xml public class ImageViewer extends Activity { ImageView iv ; @Override public void onCreate ( Bundle savedInstanceState ) { super . onCreate ( savedInstanceState ); iv = new ImageView ( this ); //使用iv来做ContentView setContentView ( iv ); //设置图片的URI iv . setImageURI ( getIntent (). getData ()); } } 注意， intent-filter 的设置，action name用VIEW，category用DEFAULT, data的mimeType为\"image/*\"， schema为\"file\"表示本地文件。 <activity android:name= \".ImageViewer\" > <intent-filter> <action android:name= \"android.intent.action.VIEW\" /> <category android:name= \"android.intent.category.DEFAULT\" /> <data android:mimeType= \"image/*\" android:scheme= \"file\" /> </intent-filter> </activity> 3 实例：打电话与打开网页 3.1 打电话 Intent i = new Intent ( Intent . ACTION_VIEW ); i . setData ( Uri . parse ( \"tel:10086\" )); startActivity ( i ); 3.2 打开网页 Intent i = new Intent ( Intent . ACTION_VIEW , Uri . parse ( \"http://www.baidu.com\" )); startActivity ( i );","tags":"Android","url":"/androidxue-xi-bi-ji-05-androidying-yong-he-xin-zhi-intent.html"},{"title":"Android学习笔记 - 03 Android四大核心组件之BroadCast","text":"Android学习笔记 - 03 Android四大核心组件之BroadCast 一、BroadCast Receiver静态声明 1、声明BroadCast Receiver public class MyBroadCast extends BroadcastReceiver { @Override public void onReceive ( Context context , Intent intent ) { } } 一旦广播接收器接收到消息，就会执行 onReceive 方法 2、Activity发送消息给BroadCast 消息的发送是使用 sendBroadcast 方法，传递给它一个 Intent private void btnSendBroadCast_click (){ Intent i = new Intent ( this , MyBroadCast . class ); i . putExtra ( \"txt\" , \"理想，你好\" ); sendBroadcast ( i ); } 3、Broadcast Receiver接收消息的处理方法 @Override public void onReceive ( Context context , Intent intent ) { System . out . println ( \"Receive Message:\" + intent . getStringExtra ( \"txt\" )); } 二、 Broad Receiver动态声明 1、声明一个Broadcast Receiver 这里声明广播接收器时同时声明了一个ACTION用来给别的应用或Activity注册使用 public class MyBroadCast2 extends BroadcastReceiver { //Action格式：包名+intent.action.类名 public static final String ACTION = \"liulx.L04BroadCast.intent.action.MyBroadCast2\" ; @Override public void onReceive ( Context context , Intent intent ) { System . out . println ( \"接收数据：\" + intent . getStringExtra ( \"txt\" )); } } 2、打开AndroidManifest.xml文件 注释掉 <!--<receiver android:name=\".MyBroadCast2\"/>--> 3、打开Activity 添加3个按钮，分别是 btnRegisterBC ， btnUnregiserBC , btnSendBC 添加一个BroadCastReceiver实例 private final MyBroadCast2 mybc = new MyBroadCast2() ; 按钮的点击方法分别为： private void btnRegisterBC_click (){ registerReceiver ( mybc , new IntentFilter ( MyBroadCast2 . ACTION )); } private void btnUnregisterBC_click (){ unregisterReceiver ( mybc ); } private void btnSendBroadCast2_click (){ //这里使用Action来声明Intent Intent i = new Intent ( MyBroadCast2 . ACTION ); i . putExtra ( \"txt\" , \"Hello, 理想\" ); sendBroadcast ( i ); } 说明： - 注册Broadcast使用 registerReceiver ，其中的IntentFilter是用之前的Action来声明，起到过滤的作用; - 取消注册，使用 unregisterReceiver ; - 发送消息给广播，是用Action声明的Intent.","tags":"Android","url":"/androidxue-xi-bi-ji-03-androidsi-da-he-xin-zu-jian-zhi-broadcast.html"},{"title":"Android学习笔记-02 Android 四大核心组件之Service","text":"Android学习笔记-02 Android 四大核心组件之Service 一、Service声明 新建基于Service的类 在Mainifest中添加Service 在aty中添加两个按钮btnStart, btnStop 添加方法，让main实现OnClickListener public void onClick ( View v ){ switch ( v . getId ()){ case R . id . btnStart : break ; case R . id . btnStop : break ; } } 创建Intent serviceIntent = new Intent(this, EchoService.class) 在btn的click方法中startService(serviceIntent)和stopService(serviceIntent) 在service类中重写onCreate() onDestroy()方法 eclipse cmd+d:删除行 二、绑定服务 创建btn1,2 在click中bindService(serviceIntent, this, Content)，unBind 让class实现 在Service中创建onBind() public IBinder onBind ( Intent arg0 ){ return esb ;} private final EchoServiceBinder esb = new ...{} public class EchoServiceBinder extends Binder { ... } 注意 ： 通过start service的服务在aty销毁时不会销毁 bind service的夫妇在aty销毁时会跟着销毁 三、service与aty通信 在service中添加timer和tasktimer public void startTimer (){ if ( timer == null ){ timer = new Timer (); timerTask = new TimerTask () { @Override public void run () { i ++; System . out . println ( i ); } }; timer . schedule ( timerTask , 1000 , 1000 ); } } public void stopTimer (){ if ( timer != null ){ timerTask . cancel (); timer . cancel (); timer = null ; timerTask = null ; } } private Timer timer ; private TimerTask timerTask ; 这一步与service和activity通信无关，但是这一步可以用来做服务与服务器的通信 在service的 onCreate 和 unDestroy 方法中启动和停止timer @Override public boolean onUnbind ( Intent intent ) { System . out . println ( \"服务-取消服务绑定\" ); return super . onUnbind ( intent ); } @Override public void onCreate () { System . out . println ( \"Service Create\" ); startTimer (); super . onCreate (); } 在service类中，提供公共方法，以备后面通信时使用，比如： private int i = 0 ; public int getInt (){ return i ; } 在Activity方法中获取Service对象 private EchoService echoService ; @Override public void onServiceConnected ( ComponentName name , IBinder binder ) { System . out . println ( \"应用已经绑定服务\" ); echoService = (( EchoService . EchoBinder ) binder ). getService (); } 最后就可以在Activity中使用Service了 @Override public void onClick ( View v ) { switch ( v . getId ()){ //... case R . id . btnUnbindService : unbindService ( this ); echoService = null ; break ; case R . id . btnGetCurrentNumber : if ( echoService != null ){ System . out . println ( \"当前获取的数字是：\" + echoService . getInt ()); } break ; } }","tags":"Android","url":"/androidxue-xi-bi-ji-02-android-si-da-he-xin-zu-jian-zhi-service.html"},{"title":"Android学习笔记-01 Android四大核心组件之Actity","text":"Android学习笔记-01 Android四大核心组件之Actity 一、Actity生命周期 1、生命周期的七个方法 eclipse快捷键alt+/自动提示 二、新建Activity 1、添加Activity类 2、在manifest中添加 3、添加layout 4、重写actiy的 onCreate 方法，使用 setContentView 设置layout 三、通信 在main的acity中添加button 按钮 在 onCreate 中添加 findViewById(R.id.btnId) ,使用 cmd+1 自动转换 添加点击事件 //点击 btn . setOnClickListener ( new View . OnClickListern (){ @Override public void onClick ( View v ){ Intent i = new Intent ( MainAcitity . this , Acty1 . class ); startActivity ( i ); } }) 四、关闭Aty 1、添加按钮 在click中添加 finish() 五、在aty间传递数据 两种传递进去，一种传递出来 1、Intent i.putExtra(\"数据名称\", \"文本内容\") 在第二个Aty中： getIntent().getStringExtra(\"数据名称\") 2、Intent.putExtra(string, bundle) //存 Bundle data = new Bundle (); data . putString ( \"txt\" , \"hello\" ) i . putExtra ( data ) //取 Bundle data = getIntent (). getExtras (); String txt = data . getString ( \"txt\" ); 3、取得第二个Aty传回的数据 startActivityForResult ( i , 0 ) protected onActivityResult ( int requestCode , int resultCode , Intent data ){ string result = data . getStringExtra ( \"result\" ) } //存 Intent i = new Intent (); i . putExtra ( \"result\" , \"hello\" ) setResult ( 0 , i ); finish ();","tags":"Android","url":"/androidxue-xi-bi-ji-01-androidsi-da-he-xin-zu-jian-zhi-actity.html"},{"title":"使用Pelican搭建博客","text":"1 环境配置 1.1 安装Pelican 注 :以下是在windows环境下安装pelican，Python版本使用的是3.41版本，该版本自带pip工具 pip install virtualenv virtualenv pelican_env cd pelican_env \\s cript . \\a ctivate.bat 上面的命令创建并激活了pelican_env，下面在该环境下开始安装pelican工具 pip install pelican markdown ghp-import 1.2 创建Github Page 在Github上创建一个仓库，仓库名是 用户名.github.io ，注意这里的用户名是自己的用户名。如下图所示. 创建好后，克隆到本地 git clone https://github.com/liulixiang1988/liulixiang1988.github.io cd liulixiang1988.github.io 2 使用Pelican写博客 2.1 创建Pelican博客 创建分支 git checkout -b source 创建Pelican pelican-quickstart 创建的过程中，会问你一些问题，你可以参考下面的回答。 > Where do you want to create your new web site? [ . ] > What will be the title of this web site? Buttermilch > Who will be the author of this web site? Tony Stark > What will be the default language of this web site? [ en ] > Do you want to specify a URL prefix? e.g., http://example.com ( Y/n ) n > Do you want to enable article pagination? ( Y/n ) > How many articles per page do you want? [ 10 ] > Do you want to generate a Fabfile/Makefile ... and publishing? ( Y/n ) > Do you want an auto-reload & simpleHTTP ... and site development? ( Y/n ) > Do you want to upload your website using FTP? ( y/N ) > Do you want to upload your website using SSH? ( y/N ) > Do you want to upload your website using Dropbox? ( y/N ) > Do you want to upload your website using S3? ( y/N ) > Do you want to upload your website using Rackspace Cloud Files? ( y/N ) 2.2 创建Markdown的博文 在content目录下创建一个test.md的文件，然后用记事本或者notepad++或者sublime text打开，编写如下内容。 Title : 你好，世界！ Date : 2014 - 08 - 22 16 : 08 Category : Python Tags : python Author : 刘理想 Summary : 你好，世界！ 你好，世界，世界，你好。 2.3 本地测试 编写好了之后，就可以在本地进行测试了。 make html make serve 2.4 提交更改 git add . git commit -m \"initial commit\" 2.5 发布 git branch gh-pages ghp-import output git checkout master git merge gh-pages git push --all 参考 http://ntanjerome.org/blog/how-to-setup-github-user-page-with-pelican","tags":"Python","url":"/shi-yong-pelicanda-jian-bo-ke.html"},{"title":"[翻译]使用Python的魔术方法创造更好的正则API","text":"原文 在此 我的一个同事说他怀念Ruby的正则表达式语法糖。我没有用过Ruby的正则表达式，但是我熟悉Python的，并且知道它的API需要一些语法糖来弥补一下。 首先，从正则表达式中获取分组需要2步。第一步，调用match()或者search()，并且将结果付值给一个变量。然后，需要检察结果是否为None(表示是否有找到匹配)。最后，如果匹配确实存在，你可以安全地取出分组。下面是一个例子： >>> import re >>> match_obj = re . match ( '([0-9]+)' , '123foo' ) >>> match_obj # What is `match_obj`? < _sre . SRE_Match object at 0x7fd1bb000828 > >>> match_obj . groups ()( '123' ,) >>> match_obj = re . match ( '([0-9]+)' , 'abc' ) >>> match_objNone 依我来看，如果能像下面这样就更好了： >>> re.get_matches('([0-9]+)', '123foo')('123',) >>> re.get_matches('([0-9]+)', 'abc')None 另一个我常遇到的问题是弄混re.sub的参数，re.sub是用来查找和替换用的。所需要的参数按照顺序依次是模式(pattern)，替换(replacement)，还有字符串。由于更重各样的原因，对我来说search_string放在replacement前面看着更起来更直接。 不幸的是，弄混这些参数将会导致看上去正确的结果。下面是个例子，为了把单词foo用bar来代替。 >>> re.sub('foo', 'replace foo with bar', 'bar') 'bar' >>> re.sub('foo', 'bar', 'replace foo with bar') 'replace bar with bar' 在上面例子中，有时我们会推测输入的字符串仅仅是foo 糖 为了有趣，我把加了一些语法糖的helper class和python的正则表达式放在了一起。我不是要每个人都这样做，我的目的是为了让它更有趣，能给你在改进其它库的语法时给你一些启发。 在我展示具体实现之前，先说说我设计的几个API的例子。 在一步操作中同事完成查找和匹配。 >>> def has_lower(s): ... return bool(R/'[a-z]+'/s) >>> has_lower('This contains lower-case') True >>> has_lower('NO LOWER-CASE HERE!') False 获取分组也很简单 >>> list(R/'([0-9]+)'/'extract 12 the 456 numbers') ['12', '456'] 最后，你可以适用字符串插入操作来执行替换。 >>> R/'(foo|bar)'/'replace foo and bar' % 'Huey!' 'replace Huey! and Huey!' 则么样，是不是很有意思？ 实现 具体的实现时非常直接的，并且依赖于Python的魔术方法来提供API。如果有一个简单的技巧，那就是使用元类(metaclass)来实现classmethod的操作符重载。 import re class _R ( type ): def __div__ ( self , regex ): return R ( regex ) class R ( object ): __metaclass__ = _R def __init__ ( self , regex ): self . _regex = re . compile ( regex ) def __div__ ( self , s ): return RegexOperation ( self . _regex , s ) class RegexOperation ( object ): def __init__ ( self , regex , search ): self . _regex = regex self . _search = search def search ( self ): match = self . _regex . search ( self . _search ) if match is not None : return match . groups () def __len__ ( self ): return self . _regex . search ( self . _search ) is not None def __mod__ ( self , replacement ): return self . _regex . sub ( replacement , self . _search ) def __iter__ ( self ): return iter ( self . _regex . findall ( self . _search )) 一步一步的分解操作，希望它能简化背后发生了什么。 调用R/ 将会调用_R类的__div__方法，它使一个工厂方法，用来生产R实例。 >>> R/'foo' <rx.R at 0x7f77c00831d0> 然后，通过调用R对象的__div__，我们获得一个RegexOperation实例，所以R.__div__是另一种工厂方法。 >>> r_obj = R/'foo' >>> r_obj / 'bar' <rx.RegexOperation at 0x7f77c00837d0> 最后一个对象，RegexOperation，实现了一些魔术方法来匹配、替换和测试匹配的存在性。 评论 1楼 很酷的运算符重载＋1 造轮子-1 你的代码： >>> list(R/'([0-9]+)'/'extract 12 the 456 numbers') ['12', '456'] 我认为比Python本身的要复杂： >>> re.findall('([0-9]+)', 'extract 12 the 456 numbers') ['12', '456'] 如果没有明显的分组，re.findall()将会返回一个group 0的匹配的list；如果定义了多个分组，re.findall()返回由每个分组组成的tuple构成的list： >>> re.findall('([A-Z])([0-9]+)', 'A133 B873 xxx yyy C946') [('A', '133'), ('B', '873'), ('C', '946')] 非常有趣的文章。我赞同你对re.sub参数列表顺序的看法。 我想说re.findall()返回空列表，如果没有匹配就返回空列表。 同样，re.finditer()提供了一个匹配对象的迭代器。 2楼 正则表达式高级教程： http://www.cofoh.com/advanced-regex-tutorial-python/traps 3楼 使用parsely库可以用来写复杂的正则。","tags":"Python","url":"/fan-yi-shi-yong-pythonde-mo-zhu-fang-fa-chuang-zao-geng-hao-de-zheng-ze-api.html"},{"title":"python里被遗忘的else","text":"本文讨论的是python中的 for … else 和 while…else 语法，最少被用到也最容易被误解的语法特性。 python中的 for 和 while 循环都又一个可选的 else （有点像if语句和try语句中的那样），当循环正常完成时执行。也就是说， else 只有在循环正常退出时才能执行。 break 、 return 或者循环中产生的异常都不会让 else 正常执行。 >>> for i in range ( 5 ): ... print ( i ) ... else : ... print ( 'Iterated over everything :)' ) ... 01234 Iterated over everything :) 上面的代码里，我们遍历了 range(5) 。由于我们让循环正常完成，所以 else 语句也执行了，并且打印出了Iterated over everything:). 相反的，如果我们用 break 等语法退出循环， else 就不会被执行。 >>> for i in range ( 5 ): ... if i == 2 : ... break ... print ( i ) ... else : ... print ( 'Iterated over everything :)' ) ... 01 注意，即使循环序列是空的， else 也会被执行，毕竟所有的循环都已经正常走完。 >>> for i in []: ... print ( i ) ... else : ... print ( 'Still iterated over everything (i.e. nothing)' ) ... Still iterated over everything ( i . e . nothing ) 而且，不要忘了哦，不要忘了哦，上面的内容对 `while...else` 也适用哦。 `` ` python >>> i = 0 >>> while i <= 5 : ... i += 1 ... print i ... else : ... print 'Yep' ... 12345 Yep 但是，为什么呢？ else 语句在循环中的一个通常用法是实现搜索循环，比如你要实现搜索符合某个条件的元素，如果没有符合条件的元素就执行额外的处理或者引发异常 for x in data : if meets_condition ( x ): break else : # raise error or do additional processing 如果没有 else 你就需要设置一个标识，然后检察这个标识用来确认是否有符合条件的元素。 condition_is_met = False for x in data : if meets_condition ( x ): condition_is_met = True if not condition_is_met : # raise error or do additional processing 这并不是啥了不起的大事，毕竟你在其它语言中不得不这样做。但是如同python中的其它特性一样，else语句可以让这种做法更优雅，更Pythonic。在上面的利子中，适用else使你的代码更符合Python之道。 并不存在不得不在循环中适用 else 语句的情况，然和情况下你都可以适用标识变量等方法。但是 else 语句让代码更优雅，可读性更高。有些人认为它更Pythonic，表达的意思更清楚（Hi，我也是呢！），另一些或许认为它让人困惑并且多余。就我个人来说，我件事在循环中适用 else 语句，除非有更好的方法让代码变的更加易读(对我来说，可以归结为如何保持代码的可读性）","tags":"Python","url":"/pythonli-bei-yi-wang-de-else.html"},{"title":"醉笑陪公三万场","text":"在百度上看到 这篇 。昨日参加同事婚礼，不胜唏嘘。 东武望馀杭 云海天涯两杳茫 何日功成名遂了，还乡 醉笑陪公三万场 不用诉离觞 痛饮从来别有肠 今夜送归灯火冷，河塘 堕泪羊公却姓杨 再后来，又有滚滚红尘中进行了改编： 楼高日尽 望断天涯路 来时陌上初熏 有情风万里卷潮来 推枕惘然不见 分携如昨到处萍漂泊 浩然相对今夕何年 谁道人生无再少 依旧梦魂中 但有旧欢新怨 人生底事往来如梭 醉笑陪君三万场 不诉离伤 禅心已失人间爱 又何曾梦觉 这些个千生万生只在 踏尽红尘何处是吾乡","tags":"生活","url":"/2014-04-19.html"},{"title":"吃烧烤！","text":"与媳妇一起去吃烧烤，点的太多，吃的有点撑，回来肚子疼。。。","tags":"生活","url":"/bbq.html"},{"title":"你好，世界！","text":"你好，世界！这是我使用pelican和github搭建的博客。以前转战多次，这次应该会定下来了。","tags":"生活","url":"/hello-world.html"}]}